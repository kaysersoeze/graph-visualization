{"version":3,"file":"lib/c_assets.js","sources":["lib/c/brent.c","lib/c/frprmn.c","lib/c/gradient.c","lib/c/graph.c","lib/c/json.c","lib/c/linmin.c","lib/c/math2d.c","lib/c/minimizer.c","lib/c/mnbrak.c","lib/c/objective.c","lib/c/process_json.c","lib/c/util.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA;AAAA;AACA;AAAA;AAEA;AAGA;;;AADA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAIA;AAAA;;;AAAA;AACA;AA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","sourcesContent":["/*****************************************************************************\n * Author: Numerical Recipies in C, Ludvig Sundström\n *\n * File Name: brent.c\n *\n * Description: \n * Given a function func, and given a bracketing triplet of abcissas ax, bx, cx\n * (such that bx is between ax and cx, and func(bx) is less than both f(ax) and\n * f(cx)), this routine isolates the minimum to a ffractional precition of\n * about tol using Brent's method.The abcissa of the minimum is returned as\n * xmin, and the minimum function value is returned as brent, the returned\n * function value.\n *\n * Creation Date : 25-06-2015\n *\n *****************************************************************************/\n\n#include <math.h>\n#include \"util.h\"\n#include \"constants.h\"\n\nfloat brent(struct vertex **vs, struct bond **bs, float ax, float bx, float cx,\n        float (*func)(float, struct vertex **, struct bond **), float tol,\n        float *xmin)\n{\n    int iter;\n    float a,b,d,etemp,fu,fv,fw,fx,p,q,r,tol1,tol2,u,v,w,x,xm;\n    float e=0.0;\n    void rt_error(); \n\n    a=(ax < cx ? ax : cx);\n    b=(ax > cx ? ax : cx);\n    x = w = v = bx;\n    fw = fv = fx = (*func)(x, vs, bs);\n    for (iter = 1;iter <= ITMAX; iter++) {\n        xm = 0.5 * (a + b);\n        tol2 = 2.0 * (tol1 = tol * fabs(x) + ZEPS);\n        if (fabs(x-xm) <= (tol2-0.5*(b-a))) {\n            *xmin=x;\n            return fx;\n        }\n        if (fabs(e) > tol1) {\n            r = (x - w) * (fx - fv);\n            q =(x - v) * (fx - fw);\n            p = (x - v) * q - (x - w) * r;\n            q = 2.0 * (q - r);\n            if (q > 0.0) p = -p;\n            q=fabs(q);\n            etemp=e;\n            e=d;\n            if (fabs(p) >= fabs(0.5*q*etemp) || p <= q*(a-x) || p >= q*(b-x))\n                d=CGOLD*(e=(x >= xm ? a-x : b-x));\n            else {\n                d=p/q;\n                u=x+d;\n                if (u-a < tol2 || b-u < tol2)\n                    d=SIGN(tol1,xm-x);\n            }\n        } else {\n            d=CGOLD*(e=(x >= xm ? a-x : b-x));\n        }\n        u=(fabs(d) >= tol1 ? x+d : x+SIGN(tol1,d));\n        fu = (*func)(u, vs, bs);\n        if (fu <= fx) {\n            if (u >= x) a=x; else b=x;\n            SHFT(v,w,x,u)\n                SHFT(fv,fw,fx,fu)\n        } else {\n            if (u < x) a=u; else b=u;\n            if (fu <= fw || w == x) {\n                v=w;\n                w=u;\n                fv=fw;\n                fw=fu;\n            } else if (fu <= fv || v == x || v == w) {\n                v=u;\n                fv=fu;\n            }\n        }\n    }\n    rt_error(\"Too many iterations in brent\");\n    *xmin=x;\n    return fx;\n}\n\n#undef ITMAX\n#undef CGOLD\n#undef ZEPS\n#undef SHFT\n","/*****************************************************************************\n\n * Author : Numerical recepies in C, modiefied by Ludvig Sundström\n\n * File Name : frprmn.c\n\n * Purpose : Performs Fletcher-Reeves-Polak-Ribiere minimization Given a\n * Set of vertices vs and a set of bonds bs, performs minimization on a\n * function func using its gradient calculated by dfunc. The convergence\n * tolerance of func is ftol.  Returned quatities are p - the location of the\n * minimum, iter - the number of iterations performed and fret - the minimum\n * value of value.  Calls routine linmin to perform line minimizations.\n\n * Creation Date : 25-06-2015\n\n *****************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#include \"constants.h\"\n#include \"util.h\"\n\n#define FREEALL free(xi);free(h);free(g);\n\nvoid linmin(struct vertex **vs, struct bond **bs, int nv, int nb, float xi[],\n        int n, float *fret, float (*func)());\n\nvoid frprmn(struct vertex **vs, struct bond **bs, int nv, int nb, float ftol,\n        int *iter, float *fret, float (*func)(), void (*dfunc)())\n{\n    int i, its, n;\n    float gg, gam, fp, dgg;\n    float *g, *h, *xi;\n    \n    n = nv * 2;\n    \n    g = vector(n);\n    h = vector(n);\n    xi = vector(n);\n\n    fp = (*func)(vs, bs, nv, nb);\n    (*dfunc)(vs, bs, nv, nb, xi);\n        \n    for (i = 0; i < n; i++) {\n        g[i] = -xi[i];\n        xi[i] = h[i] = g[i];\n    }\n    for (its = 0; its < ITMAX; its++) {\n        *iter = its;\n        linmin(vs, bs, nv, nb, xi, n, fret, func);\n        if (2.0 * fabs(*fret - fp) <= ftol * (fabs(*fret) + fabs(fp) + EPS)) {\n            FREEALL;\n            return;\n        }\n        fp = (*func)(vs, bs, nv, nb);\n        (*dfunc)(vs, bs, nv, nb, xi);\n        dgg = gg = 0.0;\n        for (i = 0; i < n; i++) {\n            gg += g[i] * g[i];\n            dgg += (xi[i] + g[i]) * xi[i];\n        }\n        if (fabs(gg) < EPS) {\n            FREEALL;\n            return;\n        }\n        gam = dgg / gg;\n        for (i = 0; i < n; i++) {\n            g[i] = -xi[i];\n            xi[i] = h[i] = g[i] + gam * h[i];\n        }\n    }\n    FREEALL\n    rt_error(\"Too many iterations in frprmn()\");\n}\n\n","/*****************************************************************************\n\n* File Name: gradient.c\n\n* Author: Ludvig Sundström\n\n* Description: The gradient of the objective function.\n\n* Creation Date: 06-07-2015\n\n*****************************************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#include \"constants.h\"\n#include \"util.h\"\n\nstatic void addForce(struct point f, int i, float *df)\n{\n    *(df + i * 2) += f.x;\n    *(df + i * 2 + 1) += f.y;\n}\n\nstatic void dfunc1(struct vertex **vs, int nv, float *df)\n{\n    int i, cx, cy;\n    float dx, dy;\n    struct vertex *vi;\n    struct point frc;\n    cx = PANEL_X / 2;\n    cy = PANEL_Y / 2;\n    for (i = 0; i < nv; i++) {\n        vi = *(vs + i);\n        dx = vi->pos->x - (float) cx;    \n        dy = vi->pos->y - (float) cy;\n        frc.x = -2 * WG * dx;\n        frc.y = -2 * WG * dy;\n        addForce(frc, i, df);\n    }\n}\n\nstatic void dfunc2rep(struct vertex **vs, int nv, float *df)\n{\n    int i, j;\n    float dij, dx, dy, critlen;\n    struct point frci;\n    struct vertex *vi, *vj;\n    for (i = 0; i < nv - 1; i++) {\n        for (j = i + 1; j < nv; j++) {\n            vi = *(vs + i);\n            vj = *(vs + j);\n            dx = vi->pos->x - vj->pos->x;\n            dy = vi->pos->y - vj->pos->y; \n            dij = sqrtf(dx * dx + dy * dy);\n            if (fabs(dij) < MIN_DIST) {\n                dij = MIN_DIST;\n            } \n            critlen = vi->radius + vj->radius + PADDING;\n            if (critlen > dij) {\n                frci.x = 2 * WR * dx * (dij - critlen) / dij;\n                frci.y = 2 * WR * dy * (dij - critlen) / dij;\n            } else {\n                frci.x = 0;\n                frci.y = 0;\n            }\n            addForce(frci, i, df);\n            addForce(negate(frci), j, df);\n        }\n    }\n}\n\nstatic void dfunc2attr(struct bond **bs, int nb, float *df)\n{\n    int i;\n    float d0i, dx, dy, di, wi;\n    struct bond *bptr;\n    struct point frci;\n    for (i = 0; i < nb; i++) {\n        bptr = *(bs + i);  \n        wi = bptr->fst->mass * bptr->snd->mass * DEFAULT_STIFFNESS;\n        d0i = bptr->dist0 * SPRING_LENGTH;\n        dx = bptr->fst->pos->x - bptr->snd->pos->x;\n        dy = bptr->fst->pos->y - bptr->snd->pos->y; \n        di = sqrtf(dx * dx + dy * dy);\n        if (fabs(di) <  0.01) {\n            di = 0.01;\n        } \n        frci.x = -2 * wi * dx * (di - d0i) / di;\n        frci.y = -2 * wi * dy * (di - d0i) / di;\n        addForce(frci, bptr->fst->id, df);\n        addForce(negate(frci), bptr->snd->id, df);\n    }\n}\n\nstatic void dfunc2(struct vertex **vs, struct bond **bs, int nv, int nb, \n        float *df) \n{\n    dfunc2attr(bs, nb, df);\n    dfunc2rep(vs, nv, df);\n}\n\n\nvoid dfunc3(struct point *ps, struct bond *bs, float *df)\n{\n    //TBI TODO\n}\n\nvoid dfunc(struct vertex **vs, struct bond **bs, int nv, int nb, float *df) \n{\n    dfunc1(vs, nv, df);\n    dfunc2(vs, bs, nv, nb, df);\n}\n\n\n//////// TESTS \n\n#include \"../../tests/minunit.h\"\n\n/*char *test_gradient() {*/\n\n    /*struct vertex **vs_test;*/\n    /*struct bond *bs_test;*/\n\n    /*float gap = 100; */\n    /*int nv = 8; */\n    /*float dist = 1;*/\n    /*float stiffness = 1;*/\n    /*float mass = 1;*/\n    /*float radius = 1;*/\n    /*char type = 'r';*/\n\n    /*return 0;*/\n/*}*/\n\n","/*****************************************************************************\n\n* File Name: graph.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 07-07-2015\n\n*****************************************************************************/\n\n#include <stdlib.h>\n#include <math.h>\n\n#include \"graph.h\"\n\nstruct vertex *mk_vertex(int id, struct point *pos, float mass, float radius, \n        char type) \n{\n    struct vertex *rtn = malloc(sizeof(struct vertex));\n    rtn->id = id;\n    rtn->pos = pos;\n    rtn->mass = mass;\n    rtn->radius = radius;\n    rtn->type = type;\n    return rtn;\n}\n\nstruct bond *mk_bond(struct vertex *fst, struct vertex *snd, float dist0, \n        float k)\n{\n    struct bond *rtn = malloc(sizeof(struct bond));\n    rtn->fst = fst;\n    rtn->snd = snd;\n    rtn->dist0 = dist0;\n    rtn->k = k;\n    return rtn;\n}\n\n","/* vim: set et ts=3 sw=3 sts=3 ft=c:\n *\n * Copyright (C) 2012, 2013, 2014 James McLaughlin et al.  All rights reserved.\n * https://github.com/udp/json-parser\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *   notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"json.h\"\n\n#ifdef _MSC_VER\n#ifndef _CRT_SECURE_NO_WARNINGS\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n#endif\n\nconst struct _json_value json_value_none;\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\ntypedef unsigned int json_uchar;\n\nstatic unsigned char hex_value (json_char c)\n{\n    if (isdigit(c))\n        return c - '0';\n\n    switch (c) {\n        case 'a': case 'A': return 0x0A;\n        case 'b': case 'B': return 0x0B;\n        case 'c': case 'C': return 0x0C;\n        case 'd': case 'D': return 0x0D;\n        case 'e': case 'E': return 0x0E;\n        case 'f': case 'F': return 0x0F;\n        default: return 0xFF;\n    }\n}\n\ntypedef struct\n{\n    unsigned long used_memory;\n\n    unsigned int uint_max;\n    unsigned long ulong_max;\n\n    json_settings settings;\n    int first_pass;\n\n    const json_char * ptr;\n    unsigned int cur_line, cur_col;\n\n} json_state;\n\nstatic void * default_alloc (size_t size, int zero, void * user_data)\n{\n    return zero ? calloc (1, size) : malloc (size);\n}\n\nstatic void default_free (void * ptr, void * user_data)\n{\n    free (ptr);\n}\n\nstatic void * json_alloc (json_state * state, unsigned long size, int zero)\n{\n    if ((state->ulong_max - state->used_memory) < size)\n        return 0;\n\n    if (state->settings.max_memory\n            && (state->used_memory += size) > state->settings.max_memory)\n    {\n        return 0;\n    }\n\n    return state->settings.mem_alloc (size, zero, state->settings.user_data);\n}\n\nstatic int new_value (json_state * state,\n        json_value ** top, json_value ** root, json_value ** alloc,\n        json_type type)\n{\n    json_value * value;\n    int values_size;\n\n    if (!state->first_pass)\n    {\n        value = *top = *alloc;\n        *alloc = (*alloc)->_reserved.next_alloc;\n\n        if (!*root)\n            *root = value;\n\n        switch (value->type)\n        {\n            case json_array:\n\n                if (value->u.array.length == 0)\n                    break;\n\n                if (! (value->u.array.values = (json_value **) json_alloc\n                            (state, value->u.array.length * sizeof (json_value *), 0)) )\n                {\n                    return 0;\n                }\n\n                value->u.array.length = 0;\n                break;\n\n            case json_object:\n\n                if (value->u.object.length == 0)\n                    break;\n\n                values_size = sizeof (*value->u.object.values) * value->u.object.length;\n\n                if (! (value->u.object.values = (json_object_entry *) json_alloc\n                            (state, values_size + ((unsigned long) value->u.object.values), 0)) )\n                {\n                    return 0;\n                }\n\n                value->_reserved.object_mem = (*(char **) &value->u.object.values) + values_size;\n\n                value->u.object.length = 0;\n                break;\n\n            case json_string:\n\n                if (! (value->u.string.ptr = (json_char *) json_alloc\n                            (state, (value->u.string.length + 1) * sizeof (json_char), 0)) )\n                {\n                    return 0;\n                }\n\n                value->u.string.length = 0;\n                break;\n\n            default:\n                break;\n        };\n\n        return 1;\n    }\n\n    if (! (value = (json_value *) json_alloc\n                (state, sizeof (json_value) + state->settings.value_extra, 1)))\n    {\n        return 0;\n    }\n\n    if (!*root)\n        *root = value;\n\n    value->type = type;\n    value->parent = *top;\n\n#ifdef JSON_TRACK_SOURCE\n    value->line = state->cur_line;\n    value->col = state->cur_col;\n#endif\n\n    if (*alloc)\n        (*alloc)->_reserved.next_alloc = value;\n\n    *alloc = *top = value;\n\n    return 1;\n}\n\n#define whitespace \\\n    case '\\n': ++ state.cur_line;  state.cur_col = 0; \\\ncase ' ': case '\\t': case '\\r'\n\n#define string_add(b)  \\\n    do { if (!state.first_pass) string [string_length] = b;  ++ string_length; } while (0);\n\n#define line_and_col \\\n    state.cur_line, state.cur_col\n\nstatic const long\nflag_next             = 1 << 0,\n                      flag_reproc           = 1 << 1,\n                      flag_need_comma       = 1 << 2,\n                      flag_seek_value       = 1 << 3, \n                      flag_escaped          = 1 << 4,\n                      flag_string           = 1 << 5,\n                      flag_need_colon       = 1 << 6,\n                      flag_done             = 1 << 7,\n                      flag_num_negative     = 1 << 8,\n                      flag_num_zero         = 1 << 9,\n                      flag_num_e            = 1 << 10,\n                      flag_num_e_got_sign   = 1 << 11,\n                      flag_num_e_negative   = 1 << 12,\n                      flag_line_comment     = 1 << 13,\n                      flag_block_comment    = 1 << 14;\n\njson_value * json_parse_ex (json_settings * settings,\n        const json_char * json,\n        size_t length,\n        char * error_buf)\n{\n    json_char error [json_error_max];\n    const json_char * end;\n    json_value * top, * root, * alloc = 0;\n    json_state state = { 0 };\n    long flags;\n    long num_digits = 0, num_e = 0;\n    json_int_t num_fraction = 0;\n\n    /* Skip UTF-8 BOM\n    */\n    if (length >= 3 && ((unsigned char) json [0]) == 0xEF\n            && ((unsigned char) json [1]) == 0xBB\n            && ((unsigned char) json [2]) == 0xBF)\n    {\n        json += 3;\n        length -= 3;\n    }\n\n    error[0] = '\\0';\n    end = (json + length);\n\n    memcpy (&state.settings, settings, sizeof (json_settings));\n\n    if (!state.settings.mem_alloc)\n        state.settings.mem_alloc = default_alloc;\n\n    if (!state.settings.mem_free)\n        state.settings.mem_free = default_free;\n\n    memset (&state.uint_max, 0xFF, sizeof (state.uint_max));\n    memset (&state.ulong_max, 0xFF, sizeof (state.ulong_max));\n\n    state.uint_max -= 8; /* limit of how much can be added before next check */\n    state.ulong_max -= 8;\n\n    for (state.first_pass = 1; state.first_pass >= 0; -- state.first_pass)\n    {\n        json_uchar uchar;\n        unsigned char uc_b1, uc_b2, uc_b3, uc_b4;\n        json_char * string = 0;\n        unsigned int string_length = 0;\n\n        top = root = 0;\n        flags = flag_seek_value;\n\n        state.cur_line = 1;\n\n        for (state.ptr = json ;; ++ state.ptr)\n        {\n            json_char b = (state.ptr == end ? 0 : *state.ptr);\n\n            if (flags & flag_string)\n            {\n                if (!b)\n                {  sprintf (error, \"Unexpected EOF in string (at %d:%d)\", line_and_col);\n                    goto e_failed;\n                }\n\n                if (string_length > state.uint_max)\n                    goto e_overflow;\n\n                if (flags & flag_escaped)\n                {\n                    flags &= ~ flag_escaped;\n\n                    switch (b)\n                    {\n                        case 'b':  string_add ('\\b');  break;\n                        case 'f':  string_add ('\\f');  break;\n                        case 'n':  string_add ('\\n');  break;\n                        case 'r':  string_add ('\\r');  break;\n                        case 't':  string_add ('\\t');  break;\n                        case 'u':\n\n                                   if (end - state.ptr < 4 || \n                                           (uc_b1 = hex_value (*++ state.ptr)) == 0xFF ||\n                                           (uc_b2 = hex_value (*++ state.ptr)) == 0xFF ||\n                                           (uc_b3 = hex_value (*++ state.ptr)) == 0xFF ||\n                                           (uc_b4 = hex_value (*++ state.ptr)) == 0xFF)\n                                   {\n                                       sprintf (error, \"Invalid character value `%c` (at %d:%d)\", b, line_and_col);\n                                       goto e_failed;\n                                   }\n\n                                   uc_b1 = (uc_b1 << 4) | uc_b2;\n                                   uc_b2 = (uc_b3 << 4) | uc_b4;\n                                   uchar = (uc_b1 << 8) | uc_b2;\n\n                                   if ((uchar & 0xF800) == 0xD800) {\n                                       json_uchar uchar2;\n\n                                       if (end - state.ptr < 6 || (*++ state.ptr) != '\\\\' || (*++ state.ptr) != 'u' ||\n                                               (uc_b1 = hex_value (*++ state.ptr)) == 0xFF ||\n                                               (uc_b2 = hex_value (*++ state.ptr)) == 0xFF ||\n                                               (uc_b3 = hex_value (*++ state.ptr)) == 0xFF ||\n                                               (uc_b4 = hex_value (*++ state.ptr)) == 0xFF)\n                                       {\n                                           sprintf (error, \"Invalid character value `%c` (at %d:%d)\", b, line_and_col);\n                                           goto e_failed;\n                                       }\n\n                                       uc_b1 = (uc_b1 << 4) | uc_b2;\n                                       uc_b2 = (uc_b3 << 4) | uc_b4;\n                                       uchar2 = (uc_b1 << 8) | uc_b2;\n\n                                       uchar = 0x010000 | ((uchar & 0x3FF) << 10) | (uchar2 & 0x3FF);\n                                   }\n\n                                   if (sizeof (json_char) >= sizeof (json_uchar) || (uchar <= 0x7F))\n                                   {\n                                       string_add ((json_char) uchar);\n                                       break;\n                                   }\n\n                                   if (uchar <= 0x7FF)\n                                   {\n                                       if (state.first_pass)\n                                           string_length += 2;\n                                       else\n                                       {  string [string_length ++] = 0xC0 | (uchar >> 6);\n                                           string [string_length ++] = 0x80 | (uchar & 0x3F);\n                                       }\n\n                                       break;\n                                   }\n\n                                   if (uchar <= 0xFFFF) {\n                                       if (state.first_pass)\n                                           string_length += 3;\n                                       else\n                                       {  string [string_length ++] = 0xE0 | (uchar >> 12);\n                                           string [string_length ++] = 0x80 | ((uchar >> 6) & 0x3F);\n                                           string [string_length ++] = 0x80 | (uchar & 0x3F);\n                                       }\n\n                                       break;\n                                   }\n\n                                   if (state.first_pass)\n                                       string_length += 4;\n                                   else\n                                   {  string [string_length ++] = 0xF0 | (uchar >> 18);\n                                       string [string_length ++] = 0x80 | ((uchar >> 12) & 0x3F);\n                                       string [string_length ++] = 0x80 | ((uchar >> 6) & 0x3F);\n                                       string [string_length ++] = 0x80 | (uchar & 0x3F);\n                                   }\n\n                                   break;\n\n                        default:\n                                   string_add (b);\n                    };\n\n                    continue;\n                }\n\n                if (b == '\\\\')\n                {\n                    flags |= flag_escaped;\n                    continue;\n                }\n\n                if (b == '\"')\n                {\n                    if (!state.first_pass)\n                        string [string_length] = 0;\n\n                    flags &= ~ flag_string;\n                    string = 0;\n\n                    switch (top->type)\n                    {\n                        case json_string:\n\n                            top->u.string.length = string_length;\n                            flags |= flag_next;\n\n                            break;\n\n                        case json_object:\n\n                            if (state.first_pass)\n                                (*(json_char **) &top->u.object.values) += string_length + 1;\n                            else\n                            {  \n                                top->u.object.values [top->u.object.length].name\n                                    = (json_char *) top->_reserved.object_mem;\n\n                                top->u.object.values [top->u.object.length].name_length\n                                    = string_length;\n\n                                (*(json_char **) &top->_reserved.object_mem) += string_length + 1;\n                            }\n\n                            flags |= flag_seek_value | flag_need_colon;\n                            continue;\n\n                        default:\n                            break;\n                    };\n                }\n                else\n                {\n                    string_add (b);\n                    continue;\n                }\n            }\n\n            if (state.settings.settings & json_enable_comments)\n            {\n                if (flags & (flag_line_comment | flag_block_comment))\n                {\n                    if (flags & flag_line_comment)\n                    {\n                        if (b == '\\r' || b == '\\n' || !b)\n                        {\n                            flags &= ~ flag_line_comment;\n                            -- state.ptr;  /* so null can be reproc'd */\n                        }\n\n                        continue;\n                    }\n\n                    if (flags & flag_block_comment)\n                    {\n                        if (!b)\n                        {  sprintf (error, \"%d:%d: Unexpected EOF in block comment\", line_and_col);\n                            goto e_failed;\n                        }\n\n                        if (b == '*' && state.ptr < (end - 1) && state.ptr [1] == '/')\n                        {\n                            flags &= ~ flag_block_comment;\n                            ++ state.ptr;  /* skip closing sequence */\n                        }\n\n                        continue;\n                    }\n                }\n                else if (b == '/')\n                {\n                    if (! (flags & (flag_seek_value | flag_done)) && top->type != json_object)\n                    {  sprintf (error, \"%d:%d: Comment not allowed here\", line_and_col);\n                        goto e_failed;\n                    }\n\n                    if (++ state.ptr == end)\n                    {  sprintf (error, \"%d:%d: EOF unexpected\", line_and_col);\n                        goto e_failed;\n                    }\n\n                    switch (b = *state.ptr)\n                    {\n                        case '/':\n                            flags |= flag_line_comment;\n                            continue;\n\n                        case '*':\n                            flags |= flag_block_comment;\n                            continue;\n\n                        default:\n                            sprintf (error, \"%d:%d: Unexpected `%c` in comment opening sequence\", line_and_col, b);\n                            goto e_failed;\n                    };\n                }\n            }\n\n            if (flags & flag_done)\n            {\n                if (!b)\n                    break;\n\n                switch (b)\n                {\nwhitespace:\n                    continue;\n\n                    default:\n\n                    sprintf (error, \"%d:%d: Trailing garbage: `%c`\",\n                            state.cur_line, state.cur_col, b);\n\n                    goto e_failed;\n                };\n            }\n\n            if (flags & flag_seek_value)\n            {\n                switch (b)\n                {\nwhitespace:\n                    continue;\n\n                    case ']':\n\n                    if (top && top->type == json_array)\n                        flags = (flags & ~ (flag_need_comma | flag_seek_value)) | flag_next;\n                    else\n                    {  sprintf (error, \"%d:%d: Unexpected ]\", line_and_col);\n                        goto e_failed;\n                    }\n\n                    break;\n\n                    default:\n\n                    if (flags & flag_need_comma)\n                    {\n                        if (b == ',')\n                        {  flags &= ~ flag_need_comma;\n                            continue;\n                        }\n                        else\n                        {\n                            sprintf (error, \"%d:%d: Expected , before %c\",\n                                    state.cur_line, state.cur_col, b);\n\n                            goto e_failed;\n                        }\n                    }\n\n                    if (flags & flag_need_colon)\n                    {\n                        if (b == ':')\n                        {  flags &= ~ flag_need_colon;\n                            continue;\n                        }\n                        else\n                        { \n                            sprintf (error, \"%d:%d: Expected : before %c\",\n                                    state.cur_line, state.cur_col, b);\n\n                            goto e_failed;\n                        }\n                    }\n\n                    flags &= ~ flag_seek_value;\n\n                    switch (b)\n                    {\n                        case '{':\n\n                            if (!new_value (&state, &top, &root, &alloc, json_object))\n                                goto e_alloc_failure;\n\n                            continue;\n\n                        case '[':\n\n                            if (!new_value (&state, &top, &root, &alloc, json_array))\n                                goto e_alloc_failure;\n\n                            flags |= flag_seek_value;\n                            continue;\n\n                        case '\"':\n\n                            if (!new_value (&state, &top, &root, &alloc, json_string))\n                                goto e_alloc_failure;\n\n                            flags |= flag_string;\n\n                            string = top->u.string.ptr;\n                            string_length = 0;\n\n                            continue;\n\n                        case 't':\n\n                            if ((end - state.ptr) < 3 || *(++ state.ptr) != 'r' ||\n                                    *(++ state.ptr) != 'u' || *(++ state.ptr) != 'e')\n                            {\n                                goto e_unknown_value;\n                            }\n\n                            if (!new_value (&state, &top, &root, &alloc, json_boolean))\n                                goto e_alloc_failure;\n\n                            top->u.boolean = 1;\n\n                            flags |= flag_next;\n                            break;\n\n                        case 'f':\n\n                            if ((end - state.ptr) < 4 || *(++ state.ptr) != 'a' ||\n                                    *(++ state.ptr) != 'l' || *(++ state.ptr) != 's' ||\n                                    *(++ state.ptr) != 'e')\n                            {\n                                goto e_unknown_value;\n                            }\n\n                            if (!new_value (&state, &top, &root, &alloc, json_boolean))\n                                goto e_alloc_failure;\n\n                            flags |= flag_next;\n                            break;\n\n                        case 'n':\n\n                            if ((end - state.ptr) < 3 || *(++ state.ptr) != 'u' ||\n                                    *(++ state.ptr) != 'l' || *(++ state.ptr) != 'l')\n                            {\n                                goto e_unknown_value;\n                            }\n\n                            if (!new_value (&state, &top, &root, &alloc, json_null))\n                                goto e_alloc_failure;\n\n                            flags |= flag_next;\n                            break;\n\n                        default:\n\n                            if (isdigit (b) || b == '-')\n                            {\n                                if (!new_value (&state, &top, &root, &alloc, json_integer))\n                                    goto e_alloc_failure;\n\n                                if (!state.first_pass)\n                                {\n                                    while (isdigit (b) || b == '+' || b == '-'\n                                            || b == 'e' || b == 'E' || b == '.')\n                                    {\n                                        if ( (++ state.ptr) == end)\n                                        {\n                                            b = 0;\n                                            break;\n                                        }\n\n                                        b = *state.ptr;\n                                    }\n\n                                    flags |= flag_next | flag_reproc;\n                                    break;\n                                }\n\n                                flags &= ~ (flag_num_negative | flag_num_e |\n                                        flag_num_e_got_sign | flag_num_e_negative |\n                                        flag_num_zero);\n\n                                num_digits = 0;\n                                num_fraction = 0;\n                                num_e = 0;\n\n                                if (b != '-')\n                                {\n                                    flags |= flag_reproc;\n                                    break;\n                                }\n\n                                flags |= flag_num_negative;\n                                continue;\n                            }\n                            else\n                            {  sprintf (error, \"%d:%d: Unexpected %c when seeking value\", line_and_col, b);\n                                goto e_failed;\n                            }\n                    };\n                };\n            }\n            else\n            {\n                switch (top->type)\n                {\n                    case json_object:\n\n                        switch (b)\n                        {\nwhitespace:\n                            continue;\n\n                            case '\"':\n\n                            if (flags & flag_need_comma)\n                            {  sprintf (error, \"%d:%d: Expected , before \\\"\", line_and_col);\n                                goto e_failed;\n                            }\n\n                            flags |= flag_string;\n\n                            string = (json_char *) top->_reserved.object_mem;\n                            string_length = 0;\n\n                            break;\n\n                            case '}':\n\n                            flags = (flags & ~ flag_need_comma) | flag_next;\n                            break;\n\n                            case ',':\n\n                            if (flags & flag_need_comma)\n                            {\n                                flags &= ~ flag_need_comma;\n                                break;\n                            }\n\n                            default:\n                            sprintf (error, \"%d:%d: Unexpected `%c` in object\", line_and_col, b);\n                            goto e_failed;\n                        };\n\n                        break;\n\n                    case json_integer:\n                    case json_double:\n\n                        if (isdigit (b))\n                        {\n                            ++ num_digits;\n\n                            if (top->type == json_integer || flags & flag_num_e)\n                            {\n                                if (! (flags & flag_num_e))\n                                {\n                                    if (flags & flag_num_zero)\n                                    {  sprintf (error, \"%d:%d: Unexpected `0` before `%c`\", line_and_col, b);\n                                        goto e_failed;\n                                    }\n\n                                    if (num_digits == 1 && b == '0')\n                                        flags |= flag_num_zero;\n                                }\n                                else\n                                {\n                                    flags |= flag_num_e_got_sign;\n                                    num_e = (num_e * 10) + (b - '0');\n                                    continue;\n                                }\n\n                                top->u.integer = (top->u.integer * 10) + (b - '0');\n                                continue;\n                            }\n\n                            num_fraction = (num_fraction * 10) + (b - '0');\n                            continue;\n                        }\n\n                        if (b == '+' || b == '-')\n                        {\n                            if ( (flags & flag_num_e) && !(flags & flag_num_e_got_sign))\n                            {\n                                flags |= flag_num_e_got_sign;\n\n                                if (b == '-')\n                                    flags |= flag_num_e_negative;\n\n                                continue;\n                            }\n                        }\n                        else if (b == '.' && top->type == json_integer)\n                        {\n                            if (!num_digits)\n                            {  sprintf (error, \"%d:%d: Expected digit before `.`\", line_and_col);\n                                goto e_failed;\n                            }\n\n                            top->type = json_double;\n                            top->u.dbl = (double) top->u.integer;\n\n                            num_digits = 0;\n                            continue;\n                        }\n\n                        if (! (flags & flag_num_e))\n                        {\n                            if (top->type == json_double)\n                            {\n                                if (!num_digits)\n                                {  sprintf (error, \"%d:%d: Expected digit after `.`\", line_and_col);\n                                    goto e_failed;\n                                }\n\n                                top->u.dbl += ((double) num_fraction) / (pow (10.0, (double) num_digits));\n                            }\n\n                            if (b == 'e' || b == 'E')\n                            {\n                                flags |= flag_num_e;\n\n                                if (top->type == json_integer)\n                                {\n                                    top->type = json_double;\n                                    top->u.dbl = (double) top->u.integer;\n                                }\n\n                                num_digits = 0;\n                                flags &= ~ flag_num_zero;\n\n                                continue;\n                            }\n                        }\n                        else\n                        {\n                            if (!num_digits)\n                            {  sprintf (error, \"%d:%d: Expected digit after `e`\", line_and_col);\n                                goto e_failed;\n                            }\n\n                            top->u.dbl *= pow (10.0, (double)\n                                    (flags & flag_num_e_negative ? - num_e : num_e));\n                        }\n\n                        if (flags & flag_num_negative)\n                        {\n                            if (top->type == json_integer)\n                                top->u.integer = - top->u.integer;\n                            else\n                                top->u.dbl = - top->u.dbl;\n                        }\n\n                        flags |= flag_next | flag_reproc;\n                        break;\n\n                    default:\n                        break;\n                };\n            }\n\n            if (flags & flag_reproc)\n            {\n                flags &= ~ flag_reproc;\n                -- state.ptr;\n            }\n\n            if (flags & flag_next)\n            {\n                flags = (flags & ~ flag_next) | flag_need_comma;\n\n                if (!top->parent)\n                {\n                    /* root value done */\n\n                    flags |= flag_done;\n                    continue;\n                }\n\n                if (top->parent->type == json_array)\n                    flags |= flag_seek_value;\n\n                if (!state.first_pass)\n                {\n                    json_value * parent = top->parent;\n\n                    switch (parent->type)\n                    {\n                        case json_object:\n\n                            parent->u.object.values\n                                [parent->u.object.length].value = top;\n\n                            break;\n\n                        case json_array:\n\n                            parent->u.array.values\n                                [parent->u.array.length] = top;\n\n                            break;\n\n                        default:\n                            break;\n                    };\n                }\n\n                if ( (++ top->parent->u.array.length) > state.uint_max)\n                    goto e_overflow;\n\n                top = top->parent;\n\n                continue;\n            }\n        }\n\n        alloc = root;\n    }\n\n    return root;\n\ne_unknown_value:\n\n    sprintf (error, \"%d:%d: Unknown value\", line_and_col);\n    goto e_failed;\n\ne_alloc_failure:\n\n    strcpy (error, \"Memory allocation failure\");\n    goto e_failed;\n\ne_overflow:\n\n    sprintf (error, \"%d:%d: Too long (caught overflow)\", line_and_col);\n    goto e_failed;\n\ne_failed:\n\n    if (error_buf)\n    {\n        if (*error)\n            strcpy (error_buf, error);\n        else\n            strcpy (error_buf, \"Unknown error\");\n    }\n\n    if (state.first_pass)\n        alloc = root;\n\n    while (alloc)\n    {\n        top = alloc->_reserved.next_alloc;\n        state.settings.mem_free (alloc, state.settings.user_data);\n        alloc = top;\n    }\n\n    if (!state.first_pass)\n        json_value_free_ex (&state.settings, root);\n\n    return 0;\n}\n\njson_value * json_parse (const json_char * json, size_t length)\n{\n    json_settings settings = { 0 };\n    return json_parse_ex (&settings, json, length, 0);\n}\n\nvoid json_value_free_ex (json_settings * settings, json_value * value)\n{\n    json_value * cur_value;\n\n    if (!value)\n        return;\n\n    value->parent = 0;\n\n    while (value)\n    {\n        switch (value->type)\n        {\n            case json_array:\n\n                if (!value->u.array.length)\n                {\n                    settings->mem_free (value->u.array.values, settings->user_data);\n                    break;\n                }\n\n                value = value->u.array.values [-- value->u.array.length];\n                continue;\n\n            case json_object:\n\n                if (!value->u.object.length)\n                {\n                    settings->mem_free (value->u.object.values, settings->user_data);\n                    break;\n                }\n\n                value = value->u.object.values [-- value->u.object.length].value;\n                continue;\n\n            case json_string:\n\n                settings->mem_free (value->u.string.ptr, settings->user_data);\n                break;\n\n            default:\n                break;\n        };\n\n        cur_value = value;\n        value = value->parent;\n        settings->mem_free (cur_value, settings->user_data);\n    }\n}\n\nvoid json_value_free (json_value * value)\n{\n    json_settings settings = { 0 };\n    settings.mem_free = default_free;\n    json_value_free_ex (&settings, value);\n}\n\n","/*****************************************************************************\n\n * Author: Numerical recepies in C, modified by Ludvig Sundström\n\n * File Name: linmin.c\n\n * Description: \n * Given an n-dimensional point p[1..n] and an n-dimensional direction\n * xi[1..n], moves and resets p to where the function func(p) takes on a\n * minimum along the direction xi from p, and replaces xi by the actual vector\n * displacement that p was moved. Also returns as fret the value of func at the\n * returned location p. This is actually all accomplished by calling the\n * routines mnbrak and brent.  \n\n * Creation Date: 25-06-2015\n\n *****************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"constants.h\"\n#include \"util.h\"\n\nint ncom; \nfloat *pcom, *xicom, (*nrfunc)();\n\nint numv, numb;\n\nfloat brent(struct vertex **vs, struct bond **bs, float ax, float bx, float cx,\n        float (*f)(float, struct vertex **, struct bond **bs), float tol, \n        float *xmin);   \n\nvoid mnbrak(struct vertex **vs, struct bond **bs, float *ax, float *bx, \n        float *cx, float *fa, float *fb, float *fc, float (*func)(float, \n        struct vertex **, struct bond **));   \n\nfloat f1dim(float x, struct vertex **vs, struct bond **bs);   \n\nvoid linmin(struct vertex **vs, struct bond **bs, int nv, int nb,\n        float *xi, int n, float *fret, float (*func)())   \n{   \n    int i;   \n    float xx, xmin, fx, fb, fa, bx, ax;   \n\n    numv = nv;\n    numb = nb;\n    ncom = n; \n    pcom = vector(n);   \n    xicom = vector(n);   \n    \n    nrfunc = func;   \n    for (i = 0; i < ncom; i += 2) {\n        struct vertex *vptr = *(vs + i / 2);\n        pcom[i] = vptr->pos->x;\n        pcom[i + 1] = vptr->pos->y;\n        xicom[i] = xi[i];   \n        xicom[i + 1] = xi[i + 1];   \n    }\n    ax = 0.0; \n    xx = 1.0;   \n    mnbrak(vs, bs, &ax, &xx, &bx, &fa, &fx, &fb, f1dim);   \n    *fret = brent(vs, bs, ax, xx, bx, f1dim, TOL, &xmin);   \n    for (i=0; i < n; i++) { \n        xi[i] *= xmin;   \n    }   \n    free(xicom);\n    free(pcom);\n}   \n\nfloat f1dim(float x, struct vertex **vs, struct bond **bs)   \n{   \n    int i;   \n    float f;\n    for (i = 0; i < ncom; i += 2) {\n        struct vertex *vptr = *(vs + i / 2);\n        vptr->pos->x = pcom[i] + x * xicom[i];\n        vptr->pos->y = pcom[i + 1] + x * xicom[i + 1];\n    }\n    f = (*nrfunc)(vs, bs, numv, numb);\n    return f;\n} \n\n","/*****************************************************************************\n\n* File Name: math2D.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 06-07-2015\n\n*****************************************************************************/\n\n#include <stdlib.h>\n#include <math.h>\n#include \"math2d.h\"\n\nstruct point *mk_point(float x, float y) \n{\n    struct point *rtn = malloc(sizeof(struct point));\n    rtn->x = x;\n    rtn->y = y;\n    return rtn;\n}\n\nstruct vector2D mk_vector(struct point src, struct point tar)\n{\n    struct vector2D rtn;\n    rtn.src = src;\n    rtn.tar = tar;\n    rtn.x = src.x - tar.x;\n    rtn.y = src.y - tar.y;\n    rtn.len = sqrtf(rtn.x * rtn.x + rtn.y * rtn.y);\n    return rtn;\n}\n\nstruct point negate(struct point p) \n{\n    struct point rtn;\n    rtn.x = -p.x;\n    rtn.y = -p.y;\n    return rtn;\n}\n\nstruct point add(struct point p1, struct point p2) \n{\n    struct point rtn;\n    rtn.x = p1.x + p2.x;\n    rtn.y = p1.y + p2.y;\n    return rtn;\n}\n\nfloat dot(struct vector2D v1, struct vector2D v2)\n{   \n    return v1.x * v2.x + v1.y * v1.y;\n}\n\n","/***************************************************************************** \n * Author: Ludvig Sundström\n\n * File Name: minimizer.c\n * Description: Defines an energy function and its derivatives aswell as\n * working as minimize() which is the exported function by emscripten.\n\n * Creation Date: 24-06-2015\n\n *****************************************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n\n#include \"util.h\"\n#include \"constants.h\"\n\nvoid process_json(const char *filename, struct vertex **vs, struct bond **bs,\n        struct point **ps, int *nv, int *nb);\n\nfloat func(struct vertex **, struct bond **, int, int);\n\nvoid dfunc(struct vertex **, struct bond **, int, int, float *);\n\nvoid frprmn(struct vertex **vs, struct bond **bs, int nv, int nb, float ftol,\n        int *iter, float *fret, float (*func)(), void (*dfunc)());\n\nstatic void set_positions(struct point **ps, int nv) {\n    int i, n, vdim, rows, cols;\n    float gapx, gapy, offsetx, offsety, x, y;\n    n = nv; \n    while (fabs(sqrt(n) - (int) sqrt(n)) > 0.01) {\n        n++;\n    }\n    vdim = sqrt(n);\n    gapx = PANEL_X / vdim;\n    gapy = PANEL_Y / vdim;\n    offsetx = gapx / 2;\n    offsety = gapy / 2;\n    rows = 0;\n    cols = -1;\n    for (i = 0; i < nv; i++) {\n        if (i % vdim == 0) {\n            rows++;\n            cols = 0; \n        }\n        x = cols * gapx + offsetx;\n        y = rows * gapy + offsety; \n        *(ps + i) = mk_point(x, y);\n        cols++;\n    }\n}\n\nstatic void toarrays(struct vertex **vs, struct bond **bs, float *vsarr, \n        int *bsarr, int nv, int nb)\n{\n    int i;\n    for (i = 0; i < nv; i++) {\n        *(vsarr + i * 2) = (*(vs + i))->pos->x;\n        *(vsarr + i * 2 + 1) = (*(vs + i))->pos->y;\n    }\n    *bsarr = nb;\n    for (i = 1; i < nb + 1; i++) {\n        *(bsarr + i * 2) = (*(bs + i - 1))->fst->id;\n        *(bsarr + i * 2 + 1) = (*(bs + i - 1))->snd->id;\n    }\n}\n\nint minimize (const char *fname, float *varr, int *barr, const int len) \n{\n\n    float (*objective)(struct vertex **, struct bond **, int, int);\n    void (*gradient)(struct vertex **, struct bond **, int, int, float *);\n    int nv, nb, maxbonds;\n    struct point **ps;\n    struct vertex **vs;\n    struct bond **bs;\n    float *fret;\n    int *iter;\n\n    nv = len / 2;\n    maxbonds = (nv * (nv - 1)) / 2;\n    objective = func;\n    gradient = dfunc;\n    ps = malloc(sizeof(void *) * nv);\n    vs = malloc(sizeof(void *) * nv);\n    bs = malloc(sizeof(void *) * maxbonds);\n    iter = malloc(sizeof(int));\n    fret = malloc(sizeof(float));\n    \n    if (ps == NULL || vs == NULL || bs == NULL || iter == NULL || fret == NULL)\n    {\n        rt_error(\"Error in minimize when allocating memory\");\n    }\n\n    set_positions(ps, nv); \n    process_json(fname, vs, bs, ps, &nv, &nb);\n    if ((float)nb > (float)nv * logf((float)nv)) {\n        printf(\"Warning: B greater than V * log(V)\\n\");\n    }\n    frprmn(vs, bs, nv, nb, FTOL, iter, fret, objective, gradient);\n    toarrays(vs, bs, varr, barr, nv, nb);\n\n    printf(\"%d iterations\\n\", *iter);\n\n    free(ps);\n    free_vertices(vs, nv);\n    free_bonds(bs, nb);\n    free(fret);\n    free(iter);\n\n    return 0;\n}\n\nint main(int argc, char *argv[]) {\n\n    const char *filename = \"data/52.json\";\n    int len = 104;\n    int nv = len / 2;\n    float *vsarr = malloc(sizeof(float) * nv * 2); \n    int *bsarr = malloc(sizeof(int) * (nv * (nv - 1) + 4)); \n\n    minimize(filename, vsarr, bsarr, len);\n\n}\n\n","/*****************************************************************************\n * Author: Numerical Recipies in C, Ludvig Sundström\n *\n * File Name: mnbrak.c\n *\n * Description: \n * Given a function func, and given distinct initial points ax, bx, this\n * routine searches in the downhill direction (defined by the function as\n * evaluated at the initial points) and returns new points ax, bx, cx that\n * bracket a minimum of the function. Also returned are the function values at\n * the three points fa, fb, fc\n *\n * Creation Date : 09-07-2015\n *\n *****************************************************************************/\n\n#include <stdio.h>\n#include <math.h>\n#include \"util.h\"\n#include \"constants.h\"\n\nvoid mnbrak(struct vertex **vs, struct bond **bs, float *ax, float *bx, \n        float *cx, float *fa, float *fb, float *fc, \n        float (*func)(float, struct vertex **, struct bond **))\n{\n    float ulim, u, r, q, fu, dum;\n\n    *fa=(*func)(*ax, vs, bs);\n    *fb=(*func)(*bx, vs, bs);\n    if (*fb > *fa) {\n        SHFT(dum,*ax,*bx,dum);\n        SHFT(dum,*fb,*fa,dum);\n    }\n    *cx=(*bx)+GOLD*(*bx-*ax);\n    *fc=(*func)(*cx, vs, bs);\n    while (*fb > *fc) {\n        r=(*bx-*ax)*(*fb-*fc);\n        q=(*bx-*cx)*(*fb-*fa);\n        u=(*bx)-((*bx-*cx)*q-(*bx-*ax)*r)/ (2.0*SIGN(MAX(fabs(q-r),TINY),q-r));\n        ulim=(*bx)+GLIMIT*(*cx-*bx);\n        if ((*bx-u)*(u-*cx) > 0.0) {\n            fu=(*func)(u, vs, bs);\n            if (fu < *fc) {\n                *ax=(*bx);\n                *bx=u;\n                *fa=(*fb);\n                *fb=fu;\n                return;\n            } else if (fu > *fb) {\n                *cx=u;\n                *fc=fu;\n                return;\n            }\n            u=(*cx)+GOLD*(*cx-*bx);\n            fu=(*func)(u, vs, bs);\n        } else if ((*cx-u)*(u-ulim) > 0.0) {\n            fu=(*func)(u, vs, bs);\n            if (fu < *fc) {\n                SHFT(*bx,*cx,u,*cx+GOLD*(*cx-*bx));\n                SHFT(*fb,*fc,fu,(*func)(u, vs, bs));\n            }\n        } else if ((u-ulim)*(ulim-*cx) >= 0.0) {\n            u=ulim;\n            fu=(*func)(u, vs, bs);\n        } else {\n            u=(*cx)+GOLD*(*cx-*bx);\n            fu=(*func)(u, vs, bs);\n        }\n        SHFT(*ax,*bx,*cx,u)\n        SHFT(*fa,*fb,*fc,fu)\n    }\n}\n\n","/*****************************************************************************\n\n* File Name: objective.c \n* Author: Ludvig Sundström\n\n* Description: The objective function F = F1 + F2 + F3 + F4 where FN considers\n* N nodes. \n\n* Creation Date: 05-07-2015\n\n*****************************************************************************/\n\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"constants.h\"\n#include \"util.h\"\n\n#include \"../../tests/minunit.h\"\n\nstatic float func1(struct vertex **vs, int nv) {\n    // Should we add repulsion from walls here? TODO\n    int i, cx, cy;\n    float dxc, dyc, rtn;\n    struct vertex *vi;\n    cx = PANEL_X / 2; cy = PANEL_Y / 2;\n    rtn = 0;\n    for (i = 0; i < nv; i++) {\n        vi = *(vs + i);\n        dxc = vi->pos->x - (float) cx;    \n        dyc = vi->pos->y - (float) cy;\n        rtn += WG * (powf(dxc, 2) + powf(dyc, 2));\n    }\n    return rtn;\n}\n\nstatic float func2attr(struct bond **bs, int nb) \n{\n    int i;\n    float rtn, d0i, di, wi, dx, dy;\n    struct bond *bptr;\n    rtn = 0; for (i = 0; i < nb; i++) {\n        bptr = *(bs + i);\n        d0i = bptr->dist0 * SPRING_LENGTH;\n        wi = bptr->fst->mass * bptr->snd->mass * bptr->k;\n        dx = bptr->fst->pos->x - bptr->snd->pos->x;\n        dy = bptr->fst->pos->y - bptr->snd->pos->y;\n        di = sqrtf(dx * dx + dy * dy);\n        if (fabs(di) <  MIN_DIST) {\n            di = MIN_DIST;\n        } \n        rtn += wi * powf(di - d0i, 2);\n    }\n    return rtn;\n}\n\nstatic float func2rep(struct vertex **vs, int nv) \n{\n    int i, j;\n    float rtn, ri, rj, dx, dy, dij, critlen;\n    struct vertex *vi, *vj;\n    rtn = ri = rj = dx = dy = dij = critlen = 0.0;\n    for (i = 0; i < nv - 1; i++) {\n        for (j = i + 1; j < nv; j++) {\n            vi = *(vs + i);\n            vj = *(vs + j);\n            if (vj != NULL  && vi != NULL && \n                    vi->pos != NULL && vj->pos != NULL) \n            {\n                ri = vi->radius;\n                rj = vj->radius;\n                dx = vi->pos->x - vj->pos->x;\n                dy = vi->pos->y - vj->pos->y;\n                dij = sqrtf(dx * dx + dy * dy);\n                if (fabs(dij) < MIN_DIST) {\n                    dij = MIN_DIST;\n                } \n                critlen = ri + rj + PADDING;\n                if (critlen > dij) {\n                    rtn += WR * powf(dij - critlen, 2);\n                }\n            } else {\n                rt_error(\"NULL-pointer\");\n            }\n        }\n    }\n    return rtn;\n}\n\nstatic float func2(struct vertex **vs, struct bond **bs, int nv, int nb) \n{\n    return func2attr(bs, nb) + func2rep(vs, nv);\n}\n\nstatic float func3(struct point *ps, int nv) \n{\n    int i, j, k; \n    float rtn, s, costheta, theta;\n    struct point pi, pj, pk;\n    struct vector2D vji, vjk;\n    rtn = 0; \n    for (i = 0; i < nv - 2; i++) {\n        for (j = i + 2; j < nv - 1; j++) {\n            for (k = j + 2; k < nv; k++) {\n                pi = *(ps + i);  \n                pj = *(ps + j);  \n                pk = *(ps + k);\n                vji = mk_vector(pi, pj);\n                vjk = mk_vector(pi, pk);\n                s = dot(vji, vjk);\n                costheta = s / (vji.len * vjk.len);\n                theta = fabs(acosf(costheta) - (M_PI / 2));\n                rtn += (1 / powf(theta, 2));\n            }\n        }\n    }\n    //TODO\n    /*return rtn;*/\n    return 0.0;\n}\n\nstatic float func4() \n{\n    // Edge crossings TODO\n    return 0.0;\n}\n\n\nfloat func(struct vertex **vs, struct bond **bs, int nv, int nb) \n{\n    float f1 = func1(vs, nv);\n    float f2 = func2(vs, bs, nv, nb);\n    float rtn = f1 + f2; \n    return rtn;\n}\n///////////////////////////////////////\n\nchar *test_objective() {\n\n    /*struct vertex **vs_test;*/\n    /*struct bond *bs_test;*/\n\n    /*float gap = 100; */\n    /*int nv = 8; */\n    /*float dist = 1;*/\n    /*float stiffness = 1;*/\n    /*float mass = 1;*/\n    /*float radius = 1;*/\n    /*char type = 'r';*/\n\n    /*int nb = 0;*/\n    /*vs_test = malloc(sizeof(struct vertex) * nv);*/\n    /*bs_test = malloc(sizeof(struct bond) * nv * nv);*/\n\n    /*mu_assert(\"Need to be able to allocate\", vs_test != NULL);*/\n    /*mu_assert(\"Need to be able to allocate \", bs_test != NULL);*/\n    /*for (int i = 0; i < nv; i++) {*/\n        /*struct point *pos = mk_point(0, i * gap);*/\n        /**(vs_test + i) = mk_vertex(i, pos, mass, radius, type);*/\n        /*mu_assert(\"mk_vertex should not give NULL\", *(vs_test + i) != NULL);*/\n    /*}*/\n    /*for (int i = 0; i < nv - 1; i++) {*/\n        /*for (int j = i + 1; j < nv; j++) {*/\n            /*struct vertex *vi = *(vs_test + i);*/\n            /*struct vertex *vj = *(vs_test + j);*/\n            /**(bs_test + nb) = mk_bond(vi, vj, dist, stiffness);*/\n            /*nb++;*/\n        /*}*/\n    /*}*/\n\n    /*float e = func(vs_test, bs_test, nv, nb);*/\n    /*float e1 = func1(vs_test, nv);*/\n    /*float e2a = func2attr(bs_test, nb);*/\n    /*float e2r = func2rep(vs_test, nv);*/\n    /*printf(\"%f\\n\", e1);*/\n    /*mu_assert(\"total energy should be bigger than 0\", e > 0 );*/\n    /*mu_assert(\"energy of f1 should be bigger than 0\", e1 > 0 );*/\n    /*mu_assert(\"energy of attraction 2 should be bigger than 0\", e2a > 0 );*/\n    /*mu_assert(\"energy of repuslsino 2 should be bigger than 0\", e2r > 0 );*/\n\n\n    /*return 0;*/\n}\n\n","\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n\n#include \"constants.h\"\n#include \"util.h\"\n#include \"json.h\"\n\nvoid process_json(const char *filename, struct vertex **vs, struct bond **bs,\n        struct point **ps, int *nv, int *nb)\n{\n    FILE *fp;\n    struct stat filestatus;\n    int file_size;\n    char* file_contents;\n    json_char* json;\n    json_value* value;\n\n    int i, id, fstid, sndid;\n    float m, r, len;\n    char t;\n    struct vertex *fst, *snd;\n    struct bond *bptr;\n\n    if ( stat(filename, &filestatus) != 0) {\n        rt_error(\"process_json(): File not found\");\n    }\n    file_size = filestatus.st_size;\n    file_contents = (char *) malloc(filestatus.st_size);\n    if ( file_contents == NULL) {\n        rt_error(\"process_json(): Unable to allocate memory\");\n    }\n\n    fp = fopen(filename, \"rt\");\n\n    if (fp == NULL) {\n        fclose(fp);\n        free(file_contents);\n        rt_error(\"process_json(): Unable to open file\");\n    }\n    if ( fread(file_contents, file_size, 1, fp) != 1 ) {\n        fclose(fp);\n        free(file_contents);\n        rt_error(\"process_json(): Unable to read file\");\n    }\n\n    fclose(fp);\n\n    json = (json_char*)file_contents;\n\n    value = json_parse(json,file_size);\n\n    if (value == NULL) {\n        free(file_contents);\n        rt_error(\"process_json(): Unable to parse data\");\n    }\n\n    json_value *vsarr = value->u.object.values[0].value;\n    *nv = vsarr->u.array.length;\n\n    for (i = 0; i < *nv; i++) {\n        \n        json_value *vertex = vsarr->u.array.values[i];\n        \n        json_value *ident = vertex->u.object.values[0].value;\n        json_value *mass = vertex->u.object.values[1].value;\n        json_value *radius = vertex->u.object.values[2].value;\n        json_value *vertex_type = vertex->u.object.values[3].value;\n\n        if (mass->type == json_integer) {\n            m = (float) mass->u.integer;\n        } else if (mass->type == json_double) {\n            m = (float) mass->u.dbl;\n        } else {\n            fprintf(stderr, \"Bad JSON data\\n\");\n        }\n\n        if (radius->type == json_integer) {\n            r = (float) radius->u.integer;\n        } else if (radius->type == json_double) {\n            r = (float) radius->u.dbl;\n        } else {\n            fprintf(stderr, \"Bad JSON data\\n\");\n        }\n\n        if (vertex_type->type == json_string) {\n            t = vertex_type ->u.string.ptr[0];\n        } else {\n            fprintf(stderr, \"Bad JSON data\\n\");\n        }\n\n        if (ident->type == json_integer) {\n            id = ident->u.integer;\n        } else {\n            fprintf(stderr, \"Bad JSON data\\n\");\n        }\n\n        *(vs + i) = mk_vertex(id, *(ps + i), m, r, t);\n    }\n\n    json_value *bsarr = value->u.object.values[1].value;\n\n    *nb = bsarr->u.array.length;\n\n    for (i = 0; i < *nb; i++) {\n        \n        json_value *bond = bsarr->u.array.values[i];\n        \n        json_value *first = bond->u.object.values[0].value;\n        json_value *second = bond->u.object.values[1].value;\n        json_value *length = bond->u.object.values[2].value;\n\n        if (first->type == json_integer && second->type == json_integer) {\n            fstid = first->u.integer;\n            sndid = second->u.integer;\n        } else {\n            fprintf(stderr, \"Bad JSON data\\n\");\n        }\n\n        if (length->type == json_integer) {\n            len = (float) length->u.integer;\n        } else if (length->type == json_double) {\n            len = (float) length->u.dbl;\n        } else {\n            fprintf(stderr, \"Bad JSON data\\n\");\n        }\n\n        fst = *(vs + fstid);\n        snd = *(vs + sndid);\n\n        bptr = mk_bond(fst, snd, len, DEFAULT_STIFFNESS);\n        *(bs + i) = bptr;\n    }\n    json_value_free(value);\n    free(file_contents);\n}\n\n","/*****************************************************************************\n\n * Author : Ludvig Sundström\n\n * File Name : util.c\n\n * Purpose : \n\n * Creation Date : 26-06-2015\n\n * Last Modified : \n\n *****************************************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n\n#include \"util.h\"\n\nvoid rt_error(char error_text[])\n{\n    fprintf(stderr,\"Run-time error...\\n\");\n    fprintf(stderr,\"%s\\n\",error_text);\n    fprintf(stderr,\"...now exiting to system...\\n\");\n    exit(1);\n}\n\nfloat *vector(long n) \n{\n    float *v = NULL;\n    v = (float *) calloc(n, (size_t)(n * sizeof(float)));\n    if (v == NULL) {\n        rt_error(\"error while allocating memory\");\n        return NULL;\n    }\n    return v;\n}\n\nstruct point *arrtop(float arr[], int n) \n{   \n    int i;\n    struct point *ps = malloc(sizeof(struct point) * n);\n    if (ps == NULL) {\n        rt_error(\"Error while allocating memory\");\n    }\n    for (i = 0; i < n * 2; i += 2) {\n        struct point p;\n        p.x = arr[i]; \n        p.y = arr[i + 1];\n        *(ps + (i / 2)) = p;\n    }\n    return ps;\n}\n\nvoid free_vertices(struct vertex **vs, int nv) \n{\n    int i;\n    for (i = 0; i < nv; i++) {\n        free((*(vs + i))->pos);\n        free(*(vs + i));\n    }\n    free(vs);\n}\n\nvoid free_bonds(struct bond **bs, int nb) \n{\n    int i;\n    for (i = 0; i < nb; i++) {\n        free(*(bs + i));\n    }\n    free(bs);\n}\n\nvoid print_vertex(struct vertex v) {\n    printf(\"vertex {id: %d, position: [%f, %f], mass: %f, radius: %f, \\n\\\n            type: %c}\\n\", v.id, v.pos->x, v.pos->y, v.mass, v.radius, v.type);\n}\n\nvoid print_bond(struct bond b) {\n    printf(\"bond {fst: %d, snd: %d, len: %f, stiffness: %f}\\n\", b.fst->id, \n            b.snd->id, b.dist0, b.k);\n}\n\n"]}