{"version":3,"file":"lib/c_assets.js","sources":["lib/c/bond.c","lib/c/bond_pair.c","lib/c/bond_set.c","lib/c/bracket_minimum.c","lib/c/energy.c","lib/c/gradient.c","lib/c/graph.c","lib/c/grid.c","lib/c/isolate_minimum.c","lib/c/json.c","lib/c/linmin.c","lib/c/minimizer.c","lib/c/pair.c","lib/c/placement.c","lib/c/process_input.c","lib/c/util.c","lib/c/vector.c","lib/c/vertex.c","lib/c/vertex_pair.c","lib/c/vertex_set.c","lib/c/zone.c","lib/c/zone_pair.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;AAWA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;;;;;;;;;;;AAMA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;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","sourcesContent":["/*****************************************************************************\n\n* File Name: Bond.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 28-07-2015\n\n*****************************************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n\n#include \"util.h\"\n#include \"constants.h\"\n#include \"bond.h\"\n\nBondPointer Bond_create(\n        const VertexPointer fst, \n        const VertexPointer snd, \n        const float dist0\n    )\n{\n    fst->mass += 1;\n    snd->mass += 1;\n\n    BondPointer rtn = malloc(sizeof(Bond));\n    rtn->fst = fst;\n    rtn->snd = snd;\n    rtn->dist0 = dist0;\n    return rtn;\n}\n\nstatic float Bond_attraction_weight(const BondPointer bp)\n{\n    return WATR;\n}\n\nfloat Bond_attraction_energy(const BondPointer bp)\n{\n    float d0i, di, wi; \n    d0i = bp->dist0 * SPRING_LENGTH;\n    di = Vector_norm(Vector_sub(bp->snd->pos, bp->fst->pos)); \n    wi = Bond_attraction_weight(bp);\n    return wi * powf(di - d0i, 2);\n}\n\nVector Bond_attraction_gradient(const BondPointer bp)\n{\n    float d0i, wi;\n    d0i = bp->dist0 * SPRING_LENGTH;\n    wi = Bond_attraction_weight(bp);\n\n    Vector vecb;\n    vecb = Vector_sub(bp->snd->pos, bp->fst->pos);\n\n    float di;\n    di = Vector_norm(vecb); \n    if (fabs(di) <  MIN_DIST) {\n        di = MIN_DIST;\n    } \n\n    return Vector_scalar_mult(vecb, 2 * wi * (di - d0i) / di);\n}\n\nvoid Bond_free(BondPointer bp)\n{\n    free(bp);\n}\n\n","/*****************************************************************************\n\n* File Name: bondPair.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 30-07-2015\n\n*****************************************************************************/\n\n#include <stdlib.h>\n#include <math.h>\n\n#include \"util.h\"\n#include \"constants.h\"\n#include \"bond_pair.h\"\n#include \"bond_set.h\"\n\n/* Private ******************************************************************/\n\nstatic float angular_weight(const BondPairPointer b2p)\n{\n   return WANG / (b2p->other1->mass * b2p->other2->mass);\n}\n\nstatic float crossing_weight(const BondPairPointer b2p)\n{\n   return WCRS;\n}\n\n/* Public *******************************************************************/\n\nBondPair BondPair_initialize(Pair pr, BondPairPointer next)\n{\n    BondPair rtn;\n    VertexPointer v0, v1, v2, v3;\n    rtn.fst = (BondPointer) pr.fst;\n    rtn.snd = (BondPointer) pr.snd;\n    v0 = rtn.fst->fst;\n    v1 = rtn.fst->snd;\n    v2 = rtn.snd->fst;\n    v3 = rtn.snd->snd;\n    rtn.next = next;\n    if (v0->id == v2->id) {\n        rtn.common = v0;\n        rtn.other1 = v1;\n        rtn.other2 = v3;\n    } else if (v0->id == v3->id) {\n        rtn.common = v0;\n        rtn.other1 = v1;\n        rtn.other2 = v2;\n    } else if (v1->id == v2->id) {\n        rtn.common = v1;\n        rtn.other1 = v0;\n        rtn.other2 = v3;\n    } else {\n        rtn.common = v1;\n        rtn.other1 = v0;\n        rtn.other2 = v2;\n    }\n    return rtn;\n}\n\nBondPairPointer BondPair_create(Pair pr, BondPairPointer next)\n{\n    BondPairPointer rtn = calloc(1, sizeof(BondPair));\n    *rtn = BondPair_initialize(pr, next);\n    return rtn;\n}\n\n\nvoid BondPair_set_cross(BondPairPointer b2p, Vector cross)\n{\n    BondPointer b0, b1;\n    b0 = b2p->fst; b1 = b2p->snd;\n\n    VertexPointer v0, v1, v2, v3;\n    v0 = b0->fst; v1 = b0->snd; \n    v2 = b1->fst; v3 = b1->snd;\n    \n    *(v0->crs_bof + v2->id) = 1;\n    *(v0->crs_bof + v3->id) = 1;\n\n    *(v1->crs_bof + v2->id) = 1;\n    *(v1->crs_bof + v3->id) = 1;\n\n    *(v2->crs_bof + v0->id) = 1;\n    *(v2->crs_bof + v1->id) = 1;\n\n    *(v3->crs_bof + v0->id) = 1;\n    *(v3->crs_bof + v1->id) = 1;\n\n    b2p->cross = cross;\n}\n\n/**\n * Returns 1 if the lines intersect, otherwise 0. In Vector_addition, if the\n * lines intersect the intersection point may be stored in the const floats i_x\n * and i_y.  \n * Credit: http://stackoverflow.com/users/78216/gavin\n */\nchar BondPair_intersect(const BondPairPointer b2p, float *i_x, float *i_y) \n{\n    \n    BondPointer b0, b1;\n    b0 = b2p->fst; b1 = b2p->snd;\n\n    VertexPointer v0, v1, v2, v3;\n    v0 = b0->fst; v1 = b0->snd; \n    v2 = b1->fst; v3 = b1->snd;\n\n    float p0_x, p0_y, p1_x, p1_y, p2_x, p2_y, p3_x, p3_y;\n    p0_x = v0->pos.x; p0_y = v0->pos.y;\n    p1_x = v1->pos.x; p1_y = v1->pos.y;\n    p2_x = v2->pos.x; p2_y = v2->pos.y;\n    p3_x = v3->pos.x; p3_y = v3->pos.y;\n\n    float s1_x, s1_y, s2_x, s2_y;\n    s1_x = p1_x - p0_x;     \n    s1_y = p1_y - p0_y;\n    s2_x = p3_x - p2_x;     \n    s2_y = p3_y - p2_y;\n\n    float s, t;\n    s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / \n        (-s2_x * s1_y + s1_x * s2_y);\n    t = ( s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / \n        (-s2_x * s1_y + s1_x * s2_y);\n\n    if (s >= MIN_DIST && s <= 1 - MIN_DIST && \n        t >= MIN_DIST && t <= 1 - MIN_DIST)\n    {\n        if (i_x != NULL)\n            *i_x = p0_x + (t * s1_x);\n        if (i_y != NULL)\n            *i_y = p0_y + (t * s1_y);\n        return 1;\n    }\n    return 0; \n}\n\nfloat BondPair_angular_energy(const BondPairPointer b2p)\n{\n    VertexPointer vi, vj, vk;\n    vi = b2p->other1; \n    vj = b2p->common;\n    vk = b2p->other2; \n\n    float xji, yji, xjk, yjk;\n    xji = vi->pos.x - vj->pos.x; yji = vi->pos.y - vj->pos.y;\n    xjk = vk->pos.x - vj->pos.x; yjk = vk->pos.y - vj->pos.y;\n\n    Vector vecji, vecjk;\n    vecji = Vector_initialize(xji, yji);\n    vecjk = Vector_initialize(xjk, yjk);\n    \n    float theta; \n    theta = Vector_angle(vecji, vecjk);\n    \n    float wij, theta0;\n    wij = angular_weight(b2p);\n    theta0 = (2 * M_PI) / (vj->mass - 1);\n\n    return wij * powf(theta - theta0, 2);\n}\n\nPair BondPair_angular_gradient(const BondPairPointer b2p)\n{\n    VertexPointer vi, vj, vk;\n    vi = b2p->other1; \n    vj = b2p->common;\n    vk = b2p->other2; \n    \n    float xji, yji, xjk, yjk; \n    xji = vi->pos.x - vj->pos.x;\n    yji = vi->pos.y - vj->pos.y;\n    xjk = vk->pos.x - vj->pos.x;\n    yjk = vk->pos.y - vj->pos.y;\n\n    if (about(xji, xjk)) {\n        xji += MIN_DIST;\n        xjk -= MIN_DIST;\n    }\n    if (about(yji, yjk)) {\n        yji += MIN_DIST;\n        yjk -= MIN_DIST;\n    }\n\n    Vector vecji, vecjk;\n    vecji = Vector_initialize(xji, yji);\n    vecjk = Vector_initialize(xjk, yjk);\n    \n    float theta0;\n    theta0 = (2 * M_PI) / (vj->mass - 1);\n    \n    float a1, a2; \n    a1 = (xjk * yji - yjk * xji);\n    a2 = (yjk * xji - xjk * yji);\n    \n    float b;\n    b = theta0 - Vector_angle(vecji, vecjk);\n    \n    float c1, c2;\n    c1 = vecjk.len * powf((powf(xji, 2) + powf(yji, 2)), (3/2));\n    c2 = vecji.len * powf((powf(xjk, 2) + powf(yjk, 2)), (3/2));\n    \n    float dn, dd, dsq, d;\n    dn = pow(a2, 2);\n    dd = (powf(xji, 2) + powf(yji, 2)) * (powf(xjk, 2) + powf(yjk, 2));\n    if (dd < MIN_DIST) {\n        dd = MIN_DIST;\n    }\n    dsq = dn / dd;\n    if (dsq < 0) {\n        rt_error(\"Negative square root argument\");\n    }\n    d = sqrtf(dn / dd);\n\n    float aver[4];\n    aver[0] = 2 * yji * a1;\n    aver[1] = 2 * xji * a2;\n    aver[2] = 2 * yjk * a2;\n    aver[3] = 2 * xjk * a1;\n    \n    float c1d, c2d;\n    c1d = c1 * d; c2d = c2 * d;\n\n    if (c1d < MIN_DIST) {\n        c1d = MIN_DIST; \n    } \n    if (c2d < MIN_DIST) {\n        c2d = MIN_DIST;\n    }\n    \n    float dxji, dyji, dxjk, dyjk;\n    dxji = -(aver[0] * b) / c1d;\n    dyji = -(aver[1] * b) / c1d;\n    dxjk = -(aver[2] * b) / c2d;\n    dyjk = -(aver[3] * b) / c2d;\n\n    float wji, wjk;\n\n    wji = angular_weight(b2p);\n    wjk = angular_weight(b2p);\n\n    VectorPointer frcji, frcjk;\n    \n    frcji = Vector_create(dxji, dyji);\n    frcjk = Vector_create(dxjk, dyjk);\n\n    *frcji = Vector_scalar_mult(*frcji, wji);  \n    *frcjk = Vector_scalar_mult(*frcjk, wjk);  \n    \n    return Pair_initialize(frcji, frcjk);\n}\n\nfloat BondPair_crossing_energy(BondPairPointer b2p)\n{\n    VertexPointer vi, vj, vk, vl;\n    vi = b2p->fst->fst; vj = b2p->fst->snd; \n    vk = b2p->snd->fst; vl = b2p->snd->snd;\n    \n    VertexPointer vquad[4] = { vi, vj, vk, vl };\n    \n    VertexSet_sort(vquad, b2p->cross);\n    \n    float dvc1, dvc2; \n    dvc1 = Vector_norm(Vector_sub(b2p->cross, vquad[0]->pos));\n    dvc2 = Vector_norm(Vector_sub(b2p->cross, vquad[1]->pos));\n    \n    float wi = crossing_weight(b2p);\n\n    return wi * (dvc1 + dvc2);\n\n}\n\nPair BondPair_crossing_gradient(BondPairPointer b2p, VertexPointer v0, VertexPointer v1)\n{\n\n    Vector d0, d1;\n    d0 = Vector_sub(b2p->cross, v0->pos); \n    d1 = Vector_sub(b2p->cross, v1->pos); \n\n    float len0, len1;\n    len0 = Vector_norm(d0); len1 = Vector_norm(d1);\n\n    if (equal(len0, 0.0)) {\n        len0 = MIN_DIST;\n    } else if (equal(len1, 0.0)) {\n        len1 = MIN_DIST;\n    }\n    \n    float dx0, dy0, dx1, dy1; \n    dx0 = d0.x / len0;\n    dy0 = d0.y / len0;\n    dx1 = d1.x / len1;\n    dy1 = d1.y / len1;\n\n    Vector *frc0, *frc1; \n    frc0 = Vector_create(dx0, dy0);\n    frc1 = Vector_create(dx1, dy1);\n    \n    float w0, w1;\n    w0 = crossing_weight(b2p);\n    w1 = crossing_weight(b2p);\n\n    *frc0 = Vector_scalar_mult(*frc0, w0);  \n    *frc1 = Vector_scalar_mult(*frc1, w1);  \n    \n    return Pair_initialize(frc0, frc1);\n}\n\nint has_common_vertex(BondPair bpr) \n{\n    BondPointer bp1, bp2;\n    bp1 = bpr.fst; bp2 = bpr.snd;\n    return  bp1->fst->id == bp2->fst->id ||\n            bp1->fst->id == bp2->snd->id || \n            bp1->snd->id == bp2->fst->id ||\n            bp1->snd->id == bp2->snd->id;\n}\n\nvoid BondPairs_free(BondPairPointer b2ps)\n{\n    BondPairPointer b2p = b2ps;\n    while(b2p != NULL) {\n        BondPairPointer tmp = b2p;\n        b2p = b2p->next;\n        free(tmp);\n        tmp = NULL;\n    }\n}\n\n","/*****************************************************************************\n\n* File Name: Bond_set.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 31-07-2015\n\n*****************************************************************************/\n\n#include \"util.h\"\n#include \"vertex_set.h\"\n#include \"bond_set.h\"\n\nBondSet BondSet_initialize(VertexPointer *vs, json_value *contents, int *nbp)\n{\n    int i, fstid, sndid;\n    float len;\n    VertexPointer fst, snd;\n\n    json_value *bsarr = contents->u.object.values[1].value;\n    *nbp = bsarr->u.array.length;\n    int nb;\n    nb = *nbp;\n\n    BondSet rtn;\n    rtn.set = (BondPointer *) Util_allocate(nb, sizeof(BondPointer));\n    rtn.n = nb;\n\n    for (i = 0; i < nb; i++) {\n        \n        json_value *Bond = bsarr->u.array.values[i];\n        \n        json_value *first = Bond->u.object.values[0].value;\n        json_value *second = Bond->u.object.values[1].value;\n        json_value *length = Bond->u.object.values[2].value;\n\n        if (first->type == json_integer && second->type == json_integer) {\n            fstid = first->u.integer;\n            sndid = second->u.integer;\n        } else {\n            rt_error(\"Bad JSON data\");\n        }\n\n        if (length->type == json_integer) {\n            len = (float) length->u.integer;\n        } else if (length->type == json_double) {\n            len = (float) length->u.dbl;\n        } else {\n            rt_error(\"Bad JSON data\\n\");\n        }\n\n        fst = *(vs + fstid);\n        snd = *(vs + sndid);\n\n        BondPointer bp;\n        bp = Bond_create(fst, snd, len);\n        *(rtn.set + i) = bp;\n    }\n\n    return rtn;\n}\n\nBondSetPointer BondSet_create(VertexPointer *vs, json_value *contents, int *nbp)\n{\n    BondSetPointer rtn;\n    rtn = (BondSetPointer) malloc(sizeof(BondSet));\n    *rtn = BondSet_initialize(vs, contents, nbp);\n    return rtn;\n}\n\nvoid BondSet_free(BondSet bs) \n{\n    int i;\n    for (i = 0; i < bs.n; i++) {\n        Bond_free(*(bs.set + i));\n    }\n    free(bs.set);\n}\n\n","/*****************************************************************************\n * Author: Numerical Recipies in C, Ludvig Sundström\n *\n * File Name: mnbrak.c\n *\n * Description: \n * Given a function func, and given distinct initial points ax, bx, this\n * routine searches in the downhill direction (defined by the function as\n * evaluated at the initial points) and returns new points ax, bx, cx that\n * bracket a minimum of the function. Also returned are the function values at\n * the three points fa, fb, fc\n *\n * Creation Date : 09-07-2015\n *\n *****************************************************************************/\n\n#include <stdio.h>\n#include <math.h>\n\n#include \"graph.h\"\n#include \"util.h\"\n#include \"constants.h\"\n\nvoid bracket_minimum(\n        GraphPointer gp, \n        float *ax, \n        float *bx, \n        float *cx, \n        float *fa, \n        float *fb, \n        float *fc, \n        float (*func)(float, GraphPointer)\n    )\n{\n    float ulim, u, r, q, fu, dum;\n\n    *fa=(*func)(*ax, gp);\n    *fb=(*func)(*bx, gp);\n    if (*fb > *fa) {\n        SHFT(dum,*ax,*bx,dum);\n        SHFT(dum,*fb,*fa,dum);\n    }\n    *cx=(*bx)+GOLD*(*bx-*ax);\n    *fc=(*func)(*cx, gp);\n    while (*fb > *fc) {\n        r = (*bx - *ax) * (*fb - *fc);\n        q = (*bx - *cx) * (*fb - *fa);\n        u = (*bx) - ((*bx-*cx)*q-(*bx-*ax)*r) /\n            (2.0 * SIGN(MAX(fabs(q - r), TINY), q - r));\n        ulim = (*bx)+GLIMIT*(*cx-*bx);\n        if ((*bx-u)*(u-*cx) > 0.0) {\n            fu=(*func)(u, gp);\n            if (fu < *fc) {\n                *ax=(*bx);\n                *bx=u;\n                *fa=(*fb);\n                *fb=fu;\n                return;\n            } else if (fu > *fb) {\n                *cx=u;\n                *fc=fu;\n                return;\n            }\n            u=(*cx)+GOLD*(*cx-*bx);\n            fu=(*func)(u, gp);\n        } else if ((*cx-u)*(u-ulim) > 0.0) {\n            fu=(*func)(u, gp);\n            if (fu < *fc) {\n                SHFT(*bx,*cx,u,*cx+GOLD*(*cx-*bx));\n                SHFT(*fb,*fc,fu,(*func)(u, gp));\n            }\n        } else if ((u-ulim)*(ulim-*cx) >= 0.0) {\n            u=ulim;\n            fu=(*func)(u, gp);\n        } else {\n            u = (*cx)+GOLD*(*cx-*bx);\n            fu=(*func)(u, gp);\n        }\n        SHFT(*ax,*bx,*cx,u)\n        SHFT(*fa,*fb,*fc,fu)\n    }\n}\n\n","/*****************************************************************************\n\n* File Name: objective.c \n* Author: Ludvp0g Sundström\n\n* Description: The objective function F = F1 + F2 + F3 + F4 where FN considers\n* N vertices. \n\n* Creation Date: 05-07-2015\n\n*****************************************************************************/\n\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"constants.h\"\n#include \"graph.h\"\n#include \"util.h\"\n\n/* Private ******************************************************************/\n\nstatic float first_order(const GraphPointer gp) {\n\n    float rtn;\n    rtn = 0;\n    int i;\n    for (i = 0; i < gp->vs.n; i++) {\n        VertexPointer v = *(gp->vs.set + i);\n        rtn += Vertex_potential_energy(v);\n    }\n    return rtn;\n}\n\nstatic float second_order_attraction(const GraphPointer gp) \n{\n    float rtn;\n    rtn = 0; \n\n    int i;\n    for (i = 0; i < gp->bs.n; i++) {\n        BondPointer bp;\n        bp = *(gp->bs.set + i);\n        rtn += Bond_attraction_energy(bp);\n    }\n\n    return rtn;\n}\n\nstatic float second_order_repulsion(const GraphPointer gp) \n{\n    float rtn;\n    rtn = 0.0;\n    \n    int i;\n    for (i = 0; i < gp->grd->npz; i++) {\n        ZP zp = *(gp->grd->pzps + i);\n        VertexPointer vp0 = zp->members;\n        while (vp0->next) {\n            VertexPointer vp1;\n            vp1 = vp0->next; \n            while (vp1) {\n                Pair pr;\n                if (vp0->id > vp1->id) {\n                    pr = Pair_initialize(vp1, vp0);\n                } else {\n                    pr = Pair_initialize(vp1, vp0);\n                }\n                rtn += VertexPair_repulsion_energy(pr);\n                vp1 = vp1->next;\n            }\n            vp0 = vp0->next;\n        }\n    }\n    Z2P z2p = gp->grd->azps;\n    while (z2p) {\n        VertexPointer vp0;\n        vp0 = z2p->fst->members;\n        while (vp0) {\n            VertexPointer vp1;\n            vp1 = z2p->snd->members;\n            while (vp1) {\n                Pair pr;\n                if (vp0->id > vp1->id) {\n                    pr = Pair_initialize(vp1, vp0);\n                } else {\n                    pr = Pair_initialize(vp0, vp1);\n                }\n                rtn += VertexPair_repulsion_energy(pr);\n                vp1 = vp1->next;          \n            }\n            vp0 = vp0->next;\n        }\n        z2p = z2p->next;\n    }\n    return rtn;\n}\n\nstatic float second_order(const GraphPointer gp)\n{\n    float e2a, e2r;\n    e2a = second_order_attraction(gp);\n    e2r = second_order_repulsion(gp);\n\n    return e2a + e2r; \n}\n\nstatic float third_order(const GraphPointer gp)\n{\n    if (!gp->con)\n        return 0;\n\n    float rtn;\n    rtn = 0; \n\n    BondPairPointer b2p;\n    b2p = gp->con;\n    while (b2p) {\n        rtn += BondPair_angular_energy(b2p);\n        b2p = b2p->next;\n    }\n\n    return rtn;\n}\n\nstatic float fourth_order(const GraphPointer gp)\n{\n    float rtn;\n    rtn = 0;\n\n    BondPairPointer b2p;\n    b2p = gp->crs;\n    while (b2p) {\n        rtn += BondPair_crossing_energy(b2p);\n        b2p = b2p->next;\n    }\n    return rtn;\n}\n\n/* Public *******************************************************************/\n\nvoid Energy_global(const GraphPointer gp)\n{\n    gp->e = fourth_order(gp);\n}\n\nvoid Energy_local(const GraphPointer gp) \n{\n    float e1, e2, e3, e4;\n    e1 = first_order(gp);\n    e2 = second_order(gp);\n    e3 = third_order(gp);\n    e4 = fourth_order(gp);\n    gp->e = e1 + e2 + e3 + e4;\n}\n\n/* Testing facade ***********************************************************/\n\nfloat (*test_first_order_energy)(const GraphPointer gp) = first_order;\nfloat (*test_second_order_energy)(const GraphPointer gp) = second_order;\nfloat (*test_second_order_attraction_energy)(const GraphPointer gp) = \n        second_order_attraction;\nfloat (*test_second_order_repulsion_energy)(const GraphPointer gp) = \n        second_order_repulsion;\nfloat (*test_third_order_energy)(const GraphPointer gp) = third_order;\nfloat (*test_fourth_order_energy)(const GraphPointer gp) = fourth_order;\n\n","/***************************************************************************** \n \n* File Name: gradient.c\n\n* Author: Ludvig Sundström\n\n* Description: The gradient of the objective function.\n\n* Creation Date: 06-07-2015\n\n*****************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#include \"pair.h\"\n#include \"util.h\"\n#include \"constants.h\"\n#include \"graph.h\"\n#include \"vertex_set.h\"\n\n/* Private ******************************************************************/\n\nstatic void apply_repulsion(const VertexPointer vi, const VertexPointer vj)\n{\n    Vector rpls_grad;\n    Pair pr = Pair_initialize(vi, vj);\n    rpls_grad = VertexPair_repulsion_gradient(pr);\n\n    vi->grad = Vector_add(vi->grad, rpls_grad);\n    vj->grad = Vector_add(vj->grad, Vector_negate(rpls_grad));\n}\n\nstatic void first_order(const GraphPointer gp)\n{\n    int i;\n    for (i = 0; i < gp->vs.n; i++) {\n        VertexPointer v;\n        v = *(gp->vs.set + i);\n        v->grad = Vector_add(v->grad, Vertex_potential_gradient(v));\n    }\n}\n\nstatic void second_order_repulsion(const GraphPointer gp)\n{\n    int i;\n    for (i = 0; i < gp->grd->npz; i++) {\n        ZP z = *(gp->grd->pzps + i);\n        VertexPointer vi = z->members;\n        while (vi->next) {\n            VertexPointer vj;\n            vj = vi->next; \n            while (vj) {\n                if (vi->id > vj->id) {\n                    apply_repulsion(vj, vi);\n                } else {\n                    apply_repulsion(vi, vj);\n                }\n                vj = vj->next;\n            }\n            vi = vi->next;\n        }\n    }\n    Z2P z2p = gp->grd->azps;\n    while (z2p) {\n        VertexPointer vi;\n        vi = z2p->fst->members;\n        while (vi) {\n            VertexPointer vj;\n            vj = z2p->snd->members;\n            while (vj) {\n                if (vi->id > vj->id) {\n                    apply_repulsion(vj, vi);\n                } else {\n                    apply_repulsion(vi, vj);\n                }\n                vj = vj->next;          \n            }\n            vi = vi->next;\n        }\n        z2p = z2p->next;\n    }\n}\n\nstatic void second_order_attraction(const GraphPointer gp)\n{\n    int i;\n    for (i = 0; i < gp->bs.n; i++) {\n        BondPointer b;\n        b = *(gp->bs.set + i);  \n        Vector grad = Bond_attraction_gradient(b);\n        b->fst->grad = Vector_add(b->fst->grad, grad);\n        b->snd->grad = Vector_add(b->snd->grad, Vector_negate(grad));\n    }\n}\n\nstatic void second_order(const GraphPointer gp)\n{\n    second_order_repulsion(gp);\n    second_order_attraction(gp);\n}\n\nstatic void third_order(const GraphPointer gp)\n{\n    if (gp->con == NULL) {\n        return;\n    }\n    BondPairPointer b2p = gp->con;\n    while (b2p) {\n        \n        Pair pr = BondPair_angular_gradient(b2p);\n        VertexPointer vi, vk;\n        vi = b2p->other1; \n        vk = b2p->other2; \n\n        vi->grad = Vector_add(vi->grad, *((VectorPointer) pr.fst));\n        vk->grad = Vector_add(vk->grad, *((VectorPointer) pr.snd));\n        \n        free(pr.fst);\n        free(pr.snd);\n\n        b2p = b2p->next;\n    }\n}\n\nstatic void fourth_order(const GraphPointer gp)\n{\n    BondPairPointer b2p;\n    b2p = gp->crs;\n    while (b2p) {\n\n        VertexPointer vi, vj, vk, vl;\n        vi = b2p->fst->fst; vj = b2p->fst->snd; \n        vk = b2p->snd->fst; vl = b2p->snd->snd;\n\n        VertexPointer vquad[4] = { vi, vj, vk, vl };\n        \n        VertexSet_sort(vquad, b2p->cross);\n        \n        VertexPointer v0, v1;\n        v0 = vquad[0]; v1 = vquad[1];\n\n        Pair pr = BondPair_crossing_gradient(b2p, v0, v1);\n\n        v0->grad = Vector_add(v0->grad, *((VectorPointer) pr.fst));\n        v1->grad = Vector_add(v1->grad, *((VectorPointer) pr.snd));\n        \n        free(pr.fst);\n        free(pr.snd);\n                \n        b2p = b2p->next;\n    }\n}\n\n/* Public *******************************************************************/\n\nvoid Gradient_global(const GraphPointer gp)\n{\n    fourth_order(gp);\n}\n\nvoid Gradient_local(const GraphPointer gp)\n{\n    first_order(gp);\n    second_order(gp);\n    third_order(gp);\n    fourth_order(gp);\n}\n\n/* Test facade *************************************************************/\n\nvoid (*test_first_order_gradient)(const GraphPointer gp) = first_order;\nvoid (*test_second_order_gradient)(const GraphPointer gp) = second_order;\nvoid (*test_second_order_attraction_gradient)(const GraphPointer gp) = second_order_attraction;\nvoid (*test_second_order_repulsion_gradient)(const GraphPointer gp) = second_order_repulsion;\nvoid (*test_third_order_gradient)(const GraphPointer gp) = third_order;\nvoid (*test_fourth_order_gradient)(const GraphPointer gp) = fourth_order;\n\n","/*****************************************************************************\n\n* File Name: graph.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 07-07-2015\n\n*****************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n\n#include \"constants.h\"\n#include \"graph.h\"\n#include \"placement.h\"\n\n#include \"process_input.h\"\n\n/* Private ******************************************************************/\n\nGraphPointer create(VertexSet vs, BondSet bs) \n{\n    \n    GraphPointer rtn; \n    rtn = (GraphPointer) calloc(1, sizeof(Graph));\n    \n    rtn->grd = Grid_create(); \n\n    rtn->vs = vs; rtn->bs = bs;\n\n    Graph_detect_connected(rtn);\n    \n    return rtn;\n}\n\n/** \n * Given a vertex in a graph, assign it a zone.\n */\n\nvoid assign_vertex_to_zone(const GrdP grdp, const VertexPointer v)\n{\n    int i, j;\n    if (v->pos.y >= PANEL_Y) {\n        j = PANEL_Y / PADDING - 1;\n    } else if (v->pos.y <= 0) {\n        j = 0;\n    } else {\n        j = ((int) v->pos.y) / PADDING;\n    }\n    if (v->pos.x >= PANEL_X) {\n        i = PANEL_X / PADDING - 1;\n    } else if (v->pos.x <= 0) {\n        i = 0;\n    } else {\n        i = ((int) v->pos.x) / PADDING;\n    }\n    ZP z = *(grdp->zps + (j * GRID_DIM_X) + i);\n    Grid_append_member(grdp, v, z);\n}\n\n/* Public ******************************************************************/\n\nGraphPointer Graph_create(\n        const char *fname, \n        void (*e_fun)(GraphPointer), \n        void (*f_fun)(GraphPointer)\n    ) \n{\n\n    int nv, nb;\n    Pair pr;\n    pr = process_json(fname, &nv, &nb);\n\n    if ((float) nb > (float) nv * logf((float) nv)) {\n        printf(\"Warning: B greater than V * log(V)\\n\");\n    }\n\n    BondSetPointer bs;\n    bs = (BondSetPointer) pr.snd; \n\n    VertexSetPointer vs;\n    vs = (VertexSetPointer) pr.fst; \n\n    GraphPointer rtn;\n    rtn = create(*vs, *bs);\n\n    rtn->calc_e = e_fun;\n    rtn->calc_f = f_fun;\n\n    Placement_set_spiral(rtn->vs, nv); \n    Graph_reset_dynamics(rtn);\n\n    return rtn;\n}\n\n\nvoid Graph_reset_dynamics(const GraphPointer gph)\n{\n    Grid_reset_dynamics(gph->grd);\n\n    if (gph->crs) BondPairs_free(gph->crs);\n    gph->crs = NULL;\n\n    int i;\n    for (i = 0; i < gph->vs.n; i++) {\n        VertexPointer v = *(gph->vs.set + i);\n        Vertex_reset_dynamics(v);\n        assign_vertex_to_zone(gph->grd, v);\n    }\n\n    Grid_check_adjacent(gph->grd);\n    Graph_detect_crosses(gph);\n}\n\nvoid Graph_detect_crosses(const GraphPointer gph)\n{\n    int i, j;\n    BondPairPointer crs; \n    crs = NULL; \n    for (i = 0; i < gph->bs.n - 1; i++) {\n        for (j = i + 1; j < gph->bs.n; j++) {\n\n            BondPointer b1, b2;\n            b1 = *(gph->bs.set + i);  \n            b2 = *(gph->bs.set + j);  \n\n            float xi, yi;\n\n            int crossing;\n            BondPairPointer b2p;\n            b2p = BondPair_create(Pair_initialize(b1, b2), NULL);\n            crossing = BondPair_intersect(b2p, &xi, &yi);\n            if (crossing) {\n                b2p->next = crs;\n                BondPair_set_cross(b2p, Vector_initialize(xi, yi));\n                crs = b2p;\n            } else {\n                free(b2p);\n                b2p = NULL;\n            }\n        }\n    }\n    gph->crs = crs;\n}\n\nvoid Graph_detect_connected(const GraphPointer gph)\n{\n    int i, j;\n    BondPairPointer con;\n    BondPointer fst, snd;\n    con = NULL; \n    fst = snd = NULL;\n    for (i = 0; i < gph->bs.n - 1; i++) {\n        for (j = i + 1; j < gph->bs.n; j++) {\n            fst = *(gph->bs.set + i);  \n            snd = *(gph->bs.set + j);  \n            Pair pr = Pair_initialize(fst, snd);\n            int match = has_common_vertex(BondPair_initialize(pr , NULL));\n            if (match) {\n                BondPairPointer newpr;\n                newpr = BondPair_create(Pair_initialize(fst, snd), con);\n                con = newpr;\n            }\n        }\n    }\n    gph->con = con;\n}\n\nvoid Graph_run_objective(const GraphPointer gph)\n{\n    (*gph->calc_e)(gph);\n    (*gph->calc_f)(gph);\n}\n\nvoid Graph_free(GraphPointer gph)\n{\n    VertexSet_free(gph->vs);\n    BondSet_free(gph->bs);\n    if (gph->con) BondPairs_free(gph->con);\n    if (gph->crs) BondPairs_free(gph->crs);\n    Grid_free(gph->grd);\n    free(gph->grd);\n    free(gph);\n}\n\n","/*****************************************************************************\n\n* File Name: grid.c\n\n* Author: Ludvig Sundström\n\n* Description: A collection of adjacent zones \n\n* Creation Date: 31-07-2015\n\n*****************************************************************************/\n\n\n#include <stdlib.h>\n\n#include \"pair.h\"\n#include \"constants.h\"\n#include \"grid.h\"\n\n/* Private ******************************************************************/\n\n/* Public *******************************************************************/\n\nGrdP Grid_create()\n{\n    GrdP rtn;\n    rtn = (GrdP) malloc(sizeof(Grd));\n\n    rtn->nz = 0;\n    rtn->zps = (ZP *) malloc(sizeof(Z) * GRID_DIM_X * GRID_DIM_Y);\n    int i, j, id;\n    for (j = 0; j < GRID_DIM_Y; j++) {\n        for (i = 0; i < GRID_DIM_X; i++) {\n            id = (j * GRID_DIM_Y) + i;\n            ZP z = Zone_create(id, i, j, i * PADDING, j * PADDING, \n                    PADDING, PADDING);\n            *(rtn->zps + id) = z;\n            rtn->nz++;\n        }\n    }\n    rtn->is_populated = (int *) malloc(sizeof(int) * rtn->nz);\n    rtn->pzps = (ZP *) malloc(sizeof(void *) * rtn->nz);\n    rtn->azps = NULL;\n    rtn->npz = 0;\n    \n    return rtn;\n}\n\nvoid Grid_append_member(GrdP grdp, const VertexPointer v, const ZP z)\n{\n    v->next = z->members;\n    z->members = v;\n    if (!*(grdp->is_populated + z->id)) {\n        *(grdp->pzps + grdp->npz) = z;\n        grdp->npz++;\n    }\n    *(grdp->is_populated + z->id) = 1;\n}\n\nvoid Grid_check_adjacent(GrdP grdp) \n{\n    int i, j;\n    for (i = 0; i < grdp->npz - 1; i++) {\n        for (j = i + 1; j < grdp->npz; j++) {\n            ZP zi = *(grdp->pzps + i);\n            ZP zj = *(grdp->pzps + j);\n            int diff;\n            diff = zi->id - zj->id;\n            \n           int adj; \n            adj = \n                diff == 1 || \n                diff == -1 || \n                diff == GRID_DIM_X || \n                diff == -GRID_DIM_X ||\n                diff == GRID_DIM_X - 1 ||\n                diff == GRID_DIM_X + 1 ||\n                diff == -GRID_DIM_X - 1 ||\n                diff == -GRID_DIM_X + 1;\n            if (adj) {\n                Pair pr = Pair_initialize(zi, zj);\n                Z2P newz2p = ZonePair_create(pr, grdp->azps);\n                grdp->azps = newz2p;\n            }\n        }\n    }\n}\n\nvoid Grid_reset_dynamics(GrdP grid)\n{\n    if (grid->azps) ZonePairs_free(grid->azps);\n    grid->azps = NULL;\n    grid->npz = 0;\n    int i;\n    for (i = 0; i < grid->nz; i++) {\n        *(grid->is_populated + i) = 0;\n        ZP z = *(grid->zps + i);\n        z->members = NULL;\n    }\n}\n\nvoid Grid_free(GrdP grdp)\n{\n    ZonePairs_free(grdp->azps);\n    Zones_free(grdp->zps, grdp->nz);\n    free(grdp->pzps);\n    free(grdp->zps);\n    free(grdp->is_populated);\n}\n","/*****************************************************************************\n * Author: Numerical Recipies in C, Ludvig Sundström\n *\n * File Name: brent.c\n *\n * Description: \n * Given a function func, and given a bracketing triplet of abcissas ax, bx, cx\n * (such that bx is between ax and cx, and func(bx) is less than both f(ax) and\n * f(cx)), this routine isolates the minimum to a ffractional precition of\n * about tol using Brent's method. The abcissa of the minimum is returned as\n * xmin, and the minimum function value is returned as brent, the returned\n * function value.\n *\n * Creation Date : 25-06-2015\n *\n *****************************************************************************/\n\n#include <math.h>\n\n#include \"graph.h\"\n#include \"util.h\"\n#include \"constants.h\"\n\nfloat isolate_minimum(\n        GraphPointer graph, \n        float ax, \n        float bx, \n        float cx, \n        float (*func)(float, GraphPointer graph), \n        float tol, \n        float *xmin\n    )\n{\n    int iter;\n    float a,b,d,etemp,fu,fv,fw,fx,p,q,r,tol1,tol2,u,v,w,x,xm;\n    float e=0.0;\n    void rt_error(); \n\n    a=(ax < cx ? ax : cx);\n    b=(ax > cx ? ax : cx);\n    x = w = v = bx;\n    fw = fv = fx = (*func)(x, graph);\n    for (iter = 1;iter <= ITMAX; iter++) {\n        xm = 0.5 * (a + b);\n        tol2 = 2.0 * (tol1 = tol * fabs(x) + ZEPS);\n        if (fabs(x-xm) <= (tol2-0.5*(b-a))) {\n            *xmin=x;\n            return fx;\n        }\n        if (fabs(e) > tol1) {\n            r = (x - w) * (fx - fv);\n            q =(x - v) * (fx - fw);\n            p = (x - v) * q - (x - w) * r;\n            q = 2.0 * (q - r);\n            if (q > 0.0) p = -p;\n            q=fabs(q);\n            etemp=e;\n            e=d;\n            if (fabs(p) >= fabs(0.5*q*etemp) || p <= q*(a-x) || p >= q*(b-x))\n                d=CGOLD*(e=(x >= xm ? a-x : b-x));\n            else {\n                d=p/q;\n                u=x+d;\n                if (u-a < tol2 || b-u < tol2)\n                    d=SIGN(tol1,xm-x);\n            }\n        } else {\n            d=CGOLD*(e=(x >= xm ? a-x : b-x));\n        }\n        u=(fabs(d) >= tol1 ? x+d : x+SIGN(tol1,d));\n        fu = (*func)(u, graph);\n        if (fu <= fx) {\n            if (u >= x) a=x; else b=x;\n            SHFT(v,w,x,u)\n                SHFT(fv,fw,fx,fu)\n        } else {\n            if (u < x) a=u; else b=u;\n            if (fu <= fw || w == x) {\n                v=w;\n                w=u;\n                fv=fw;\n                fw=fu;\n            } else if (fu <= fv || v == x || v == w) {\n                v=u;\n                fv=fu;\n            }\n        }\n    }\n    rt_error(\"Too many iterations in brent\");\n    *xmin=x;\n    return fx;\n}\n\n","/* vim: set et ts=3 sw=3 sts=3 ft=c:\n *\n * Copyright (C) 2012, 2013, 2014 James McLaughlin et al.  All rights reserved.\n * https://github.com/udp/json-parser\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *   notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"json.h\"\n\n#ifdef _MSC_VER\n#ifndef _CRT_SECURE_NO_WARNINGS\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n#endif\n\nconst struct _json_value json_value_none;\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\ntypedef unsigned int json_uchar;\n\nstatic unsigned char hex_value (json_char c)\n{\n    if (isdigit(c))\n        return c - '0';\n\n    switch (c) {\n        case 'a': case 'A': return 0x0A;\n        case 'b': case 'B': return 0x0B;\n        case 'c': case 'C': return 0x0C;\n        case 'd': case 'D': return 0x0D;\n        case 'e': case 'E': return 0x0E;\n        case 'f': case 'F': return 0x0F;\n        default: return 0xFF;\n    }\n}\n\ntypedef struct\n{\n    unsigned long used_memory;\n\n    unsigned int uint_max;\n    unsigned long ulong_max;\n\n    json_settings settings;\n    int first_pass;\n\n    const json_char * ptr;\n    unsigned int cur_line, cur_col;\n\n} json_state;\n\nstatic void * default_alloc (size_t size, int zero, void * user_data)\n{\n    return zero ? calloc (1, size) : malloc (size);\n}\n\nstatic void default_free (void * ptr, void * user_data)\n{\n    free (ptr);\n}\n\nstatic void * json_alloc (json_state * state, unsigned long size, int zero)\n{\n    if ((state->ulong_max - state->used_memory) < size)\n        return 0;\n\n    if (state->settings.max_memory\n            && (state->used_memory += size) > state->settings.max_memory)\n    {\n        return 0;\n    }\n\n    return state->settings.mem_alloc (size, zero, state->settings.user_data);\n}\n\nstatic int new_value (json_state * state,\n        json_value ** top, json_value ** root, json_value ** alloc,\n        json_type type)\n{\n    json_value * value;\n    int values_size;\n\n    if (!state->first_pass)\n    {\n        value = *top = *alloc;\n        *alloc = (*alloc)->_reserved.next_alloc;\n\n        if (!*root)\n            *root = value;\n\n        switch (value->type)\n        {\n            case json_array:\n\n                if (value->u.array.length == 0)\n                    break;\n\n                if (! (value->u.array.values = (json_value **) json_alloc\n                            (state, value->u.array.length * sizeof (json_value *), 0)) )\n                {\n                    return 0;\n                }\n\n                value->u.array.length = 0;\n                break;\n\n            case json_object:\n\n                if (value->u.object.length == 0)\n                    break;\n\n                values_size = sizeof (*value->u.object.values) * value->u.object.length;\n\n                if (! (value->u.object.values = (json_object_entry *) json_alloc\n                            (state, values_size + ((unsigned long) value->u.object.values), 0)) )\n                {\n                    return 0;\n                }\n\n                value->_reserved.object_mem = (*(char **) &value->u.object.values) + values_size;\n\n                value->u.object.length = 0;\n                break;\n\n            case json_string:\n\n                if (! (value->u.string.ptr = (json_char *) json_alloc\n                            (state, (value->u.string.length + 1) * sizeof (json_char), 0)) )\n                {\n                    return 0;\n                }\n\n                value->u.string.length = 0;\n                break;\n\n            default:\n                break;\n        };\n\n        return 1;\n    }\n\n    if (! (value = (json_value *) json_alloc\n                (state, sizeof (json_value) + state->settings.value_extra, 1)))\n    {\n        return 0;\n    }\n\n    if (!*root)\n        *root = value;\n\n    value->type = type;\n    value->parent = *top;\n\n#ifdef JSON_TRACK_SOURCE\n    value->line = state->cur_line;\n    value->col = state->cur_col;\n#endif\n\n    if (*alloc)\n        (*alloc)->_reserved.next_alloc = value;\n\n    *alloc = *top = value;\n\n    return 1;\n}\n\n#define whitespace \\\n    case '\\n': ++ state.cur_line;  state.cur_col = 0; \\\ncase ' ': case '\\t': case '\\r'\n\n#define string_add(b)  \\\n    do { if (!state.first_pass) string [string_length] = b;  ++ string_length; } while (0);\n\n#define line_and_col \\\n    state.cur_line, state.cur_col\n\nstatic const long\nflag_next             = 1 << 0,\n                      flag_reproc           = 1 << 1,\n                      flag_need_comma       = 1 << 2,\n                      flag_seek_value       = 1 << 3, \n                      flag_escaped          = 1 << 4,\n                      flag_string           = 1 << 5,\n                      flag_need_colon       = 1 << 6,\n                      flag_done             = 1 << 7,\n                      flag_num_negative     = 1 << 8,\n                      flag_num_zero         = 1 << 9,\n                      flag_num_e            = 1 << 10,\n                      flag_num_e_got_sign   = 1 << 11,\n                      flag_num_e_negative   = 1 << 12,\n                      flag_line_comment     = 1 << 13,\n                      flag_block_comment    = 1 << 14;\n\njson_value * json_parse_ex (json_settings * settings,\n        const json_char * json,\n        size_t length,\n        char * error_buf)\n{\n    json_char error [json_error_max];\n    const json_char * end;\n    json_value * top, * root, * alloc = 0;\n    json_state state = { 0 };\n    long flags;\n    long num_digits = 0, num_e = 0;\n    json_int_t num_fraction = 0;\n\n    /* Skip UTF-8 BOM\n    */\n    if (length >= 3 && ((unsigned char) json [0]) == 0xEF\n            && ((unsigned char) json [1]) == 0xBB\n            && ((unsigned char) json [2]) == 0xBF)\n    {\n        json += 3;\n        length -= 3;\n    }\n\n    error[0] = '\\0';\n    end = (json + length);\n\n    memcpy (&state.settings, settings, sizeof (json_settings));\n\n    if (!state.settings.mem_alloc)\n        state.settings.mem_alloc = default_alloc;\n\n    if (!state.settings.mem_free)\n        state.settings.mem_free = default_free;\n\n    memset (&state.uint_max, 0xFF, sizeof (state.uint_max));\n    memset (&state.ulong_max, 0xFF, sizeof (state.ulong_max));\n\n    state.uint_max -= 8; /* limit of how much can be added before next check */\n    state.ulong_max -= 8;\n\n    for (state.first_pass = 1; state.first_pass >= 0; -- state.first_pass)\n    {\n        json_uchar uchar;\n        unsigned char uc_b1, uc_b2, uc_b3, uc_b4;\n        json_char * string = 0;\n        unsigned int string_length = 0;\n\n        top = root = 0;\n        flags = flag_seek_value;\n\n        state.cur_line = 1;\n\n        for (state.ptr = json ;; ++ state.ptr)\n        {\n            json_char b = (state.ptr == end ? 0 : *state.ptr);\n\n            if (flags & flag_string)\n            {\n                if (!b)\n                {  sprintf (error, \"Unexpected EOF in string (at %d:%d)\", line_and_col);\n                    goto e_failed;\n                }\n\n                if (string_length > state.uint_max)\n                    goto e_overflow;\n\n                if (flags & flag_escaped)\n                {\n                    flags &= ~ flag_escaped;\n\n                    switch (b)\n                    {\n                        case 'b':  string_add ('\\b');  break;\n                        case 'f':  string_add ('\\f');  break;\n                        case 'n':  string_add ('\\n');  break;\n                        case 'r':  string_add ('\\r');  break;\n                        case 't':  string_add ('\\t');  break;\n                        case 'u':\n\n                                   if (end - state.ptr < 4 || \n                                           (uc_b1 = hex_value (*++ state.ptr)) == 0xFF ||\n                                           (uc_b2 = hex_value (*++ state.ptr)) == 0xFF ||\n                                           (uc_b3 = hex_value (*++ state.ptr)) == 0xFF ||\n                                           (uc_b4 = hex_value (*++ state.ptr)) == 0xFF)\n                                   {\n                                       sprintf (error, \"Invalid character value `%c` (at %d:%d)\", b, line_and_col);\n                                       goto e_failed;\n                                   }\n\n                                   uc_b1 = (uc_b1 << 4) | uc_b2;\n                                   uc_b2 = (uc_b3 << 4) | uc_b4;\n                                   uchar = (uc_b1 << 8) | uc_b2;\n\n                                   if ((uchar & 0xF800) == 0xD800) {\n                                       json_uchar uchar2;\n\n                                       if (end - state.ptr < 6 || (*++ state.ptr) != '\\\\' || (*++ state.ptr) != 'u' ||\n                                               (uc_b1 = hex_value (*++ state.ptr)) == 0xFF ||\n                                               (uc_b2 = hex_value (*++ state.ptr)) == 0xFF ||\n                                               (uc_b3 = hex_value (*++ state.ptr)) == 0xFF ||\n                                               (uc_b4 = hex_value (*++ state.ptr)) == 0xFF)\n                                       {\n                                           sprintf (error, \"Invalid character value `%c` (at %d:%d)\", b, line_and_col);\n                                           goto e_failed;\n                                       }\n\n                                       uc_b1 = (uc_b1 << 4) | uc_b2;\n                                       uc_b2 = (uc_b3 << 4) | uc_b4;\n                                       uchar2 = (uc_b1 << 8) | uc_b2;\n\n                                       uchar = 0x010000 | ((uchar & 0x3FF) << 10) | (uchar2 & 0x3FF);\n                                   }\n\n                                   if (sizeof (json_char) >= sizeof (json_uchar) || (uchar <= 0x7F))\n                                   {\n                                       string_add ((json_char) uchar);\n                                       break;\n                                   }\n\n                                   if (uchar <= 0x7FF)\n                                   {\n                                       if (state.first_pass)\n                                           string_length += 2;\n                                       else\n                                       {  string [string_length ++] = 0xC0 | (uchar >> 6);\n                                           string [string_length ++] = 0x80 | (uchar & 0x3F);\n                                       }\n\n                                       break;\n                                   }\n\n                                   if (uchar <= 0xFFFF) {\n                                       if (state.first_pass)\n                                           string_length += 3;\n                                       else\n                                       {  string [string_length ++] = 0xE0 | (uchar >> 12);\n                                           string [string_length ++] = 0x80 | ((uchar >> 6) & 0x3F);\n                                           string [string_length ++] = 0x80 | (uchar & 0x3F);\n                                       }\n\n                                       break;\n                                   }\n\n                                   if (state.first_pass)\n                                       string_length += 4;\n                                   else\n                                   {  string [string_length ++] = 0xF0 | (uchar >> 18);\n                                       string [string_length ++] = 0x80 | ((uchar >> 12) & 0x3F);\n                                       string [string_length ++] = 0x80 | ((uchar >> 6) & 0x3F);\n                                       string [string_length ++] = 0x80 | (uchar & 0x3F);\n                                   }\n\n                                   break;\n\n                        default:\n                                   string_add (b);\n                    };\n\n                    continue;\n                }\n\n                if (b == '\\\\')\n                {\n                    flags |= flag_escaped;\n                    continue;\n                }\n\n                if (b == '\"')\n                {\n                    if (!state.first_pass)\n                        string [string_length] = 0;\n\n                    flags &= ~ flag_string;\n                    string = 0;\n\n                    switch (top->type)\n                    {\n                        case json_string:\n\n                            top->u.string.length = string_length;\n                            flags |= flag_next;\n\n                            break;\n\n                        case json_object:\n\n                            if (state.first_pass)\n                                (*(json_char **) &top->u.object.values) += string_length + 1;\n                            else\n                            {  \n                                top->u.object.values [top->u.object.length].name\n                                    = (json_char *) top->_reserved.object_mem;\n\n                                top->u.object.values [top->u.object.length].name_length\n                                    = string_length;\n\n                                (*(json_char **) &top->_reserved.object_mem) += string_length + 1;\n                            }\n\n                            flags |= flag_seek_value | flag_need_colon;\n                            continue;\n\n                        default:\n                            break;\n                    };\n                }\n                else\n                {\n                    string_add (b);\n                    continue;\n                }\n            }\n\n            if (state.settings.settings & json_enable_comments)\n            {\n                if (flags & (flag_line_comment | flag_block_comment))\n                {\n                    if (flags & flag_line_comment)\n                    {\n                        if (b == '\\r' || b == '\\n' || !b)\n                        {\n                            flags &= ~ flag_line_comment;\n                            -- state.ptr;  /* so null can be reproc'd */\n                        }\n\n                        continue;\n                    }\n\n                    if (flags & flag_block_comment)\n                    {\n                        if (!b)\n                        {  sprintf (error, \"%d:%d: Unexpected EOF in block comment\", line_and_col);\n                            goto e_failed;\n                        }\n\n                        if (b == '*' && state.ptr < (end - 1) && state.ptr [1] == '/')\n                        {\n                            flags &= ~ flag_block_comment;\n                            ++ state.ptr;  /* skip closing sequence */\n                        }\n\n                        continue;\n                    }\n                }\n                else if (b == '/')\n                {\n                    if (! (flags & (flag_seek_value | flag_done)) && top->type != json_object)\n                    {  sprintf (error, \"%d:%d: Comment not allowed here\", line_and_col);\n                        goto e_failed;\n                    }\n\n                    if (++ state.ptr == end)\n                    {  sprintf (error, \"%d:%d: EOF unexpected\", line_and_col);\n                        goto e_failed;\n                    }\n\n                    switch (b = *state.ptr)\n                    {\n                        case '/':\n                            flags |= flag_line_comment;\n                            continue;\n\n                        case '*':\n                            flags |= flag_block_comment;\n                            continue;\n\n                        default:\n                            sprintf (error, \"%d:%d: Unexpected `%c` in comment opening sequence\", line_and_col, b);\n                            goto e_failed;\n                    };\n                }\n            }\n\n            if (flags & flag_done)\n            {\n                if (!b)\n                    break;\n\n                switch (b)\n                {\nwhitespace:\n                    continue;\n\n                    default:\n\n                    sprintf (error, \"%d:%d: Trailing garbage: `%c`\",\n                            state.cur_line, state.cur_col, b);\n\n                    goto e_failed;\n                };\n            }\n\n            if (flags & flag_seek_value)\n            {\n                switch (b)\n                {\nwhitespace:\n                    continue;\n\n                    case ']':\n\n                    if (top && top->type == json_array)\n                        flags = (flags & ~ (flag_need_comma | flag_seek_value)) | flag_next;\n                    else\n                    {  sprintf (error, \"%d:%d: Unexpected ]\", line_and_col);\n                        goto e_failed;\n                    }\n\n                    break;\n\n                    default:\n\n                    if (flags & flag_need_comma)\n                    {\n                        if (b == ',')\n                        {  flags &= ~ flag_need_comma;\n                            continue;\n                        }\n                        else\n                        {\n                            sprintf (error, \"%d:%d: Expected , before %c\",\n                                    state.cur_line, state.cur_col, b);\n\n                            goto e_failed;\n                        }\n                    }\n\n                    if (flags & flag_need_colon)\n                    {\n                        if (b == ':')\n                        {  flags &= ~ flag_need_colon;\n                            continue;\n                        }\n                        else\n                        { \n                            sprintf (error, \"%d:%d: Expected : before %c\",\n                                    state.cur_line, state.cur_col, b);\n\n                            goto e_failed;\n                        }\n                    }\n\n                    flags &= ~ flag_seek_value;\n\n                    switch (b)\n                    {\n                        case '{':\n\n                            if (!new_value (&state, &top, &root, &alloc, json_object))\n                                goto e_alloc_failure;\n\n                            continue;\n\n                        case '[':\n\n                            if (!new_value (&state, &top, &root, &alloc, json_array))\n                                goto e_alloc_failure;\n\n                            flags |= flag_seek_value;\n                            continue;\n\n                        case '\"':\n\n                            if (!new_value (&state, &top, &root, &alloc, json_string))\n                                goto e_alloc_failure;\n\n                            flags |= flag_string;\n\n                            string = top->u.string.ptr;\n                            string_length = 0;\n\n                            continue;\n\n                        case 't':\n\n                            if ((end - state.ptr) < 3 || *(++ state.ptr) != 'r' ||\n                                    *(++ state.ptr) != 'u' || *(++ state.ptr) != 'e')\n                            {\n                                goto e_unknown_value;\n                            }\n\n                            if (!new_value (&state, &top, &root, &alloc, json_boolean))\n                                goto e_alloc_failure;\n\n                            top->u.boolean = 1;\n\n                            flags |= flag_next;\n                            break;\n\n                        case 'f':\n\n                            if ((end - state.ptr) < 4 || *(++ state.ptr) != 'a' ||\n                                    *(++ state.ptr) != 'l' || *(++ state.ptr) != 's' ||\n                                    *(++ state.ptr) != 'e')\n                            {\n                                goto e_unknown_value;\n                            }\n\n                            if (!new_value (&state, &top, &root, &alloc, json_boolean))\n                                goto e_alloc_failure;\n\n                            flags |= flag_next;\n                            break;\n\n                        case 'n':\n\n                            if ((end - state.ptr) < 3 || *(++ state.ptr) != 'u' ||\n                                    *(++ state.ptr) != 'l' || *(++ state.ptr) != 'l')\n                            {\n                                goto e_unknown_value;\n                            }\n\n                            if (!new_value (&state, &top, &root, &alloc, json_null))\n                                goto e_alloc_failure;\n\n                            flags |= flag_next;\n                            break;\n\n                        default:\n\n                            if (isdigit (b) || b == '-')\n                            {\n                                if (!new_value (&state, &top, &root, &alloc, json_integer))\n                                    goto e_alloc_failure;\n\n                                if (!state.first_pass)\n                                {\n                                    while (isdigit (b) || b == '+' || b == '-'\n                                            || b == 'e' || b == 'E' || b == '.')\n                                    {\n                                        if ( (++ state.ptr) == end)\n                                        {\n                                            b = 0;\n                                            break;\n                                        }\n\n                                        b = *state.ptr;\n                                    }\n\n                                    flags |= flag_next | flag_reproc;\n                                    break;\n                                }\n\n                                flags &= ~ (flag_num_negative | flag_num_e |\n                                        flag_num_e_got_sign | flag_num_e_negative |\n                                        flag_num_zero);\n\n                                num_digits = 0;\n                                num_fraction = 0;\n                                num_e = 0;\n\n                                if (b != '-')\n                                {\n                                    flags |= flag_reproc;\n                                    break;\n                                }\n\n                                flags |= flag_num_negative;\n                                continue;\n                            }\n                            else\n                            {  sprintf (error, \"%d:%d: Unexpected %c when seeking value\", line_and_col, b);\n                                goto e_failed;\n                            }\n                    };\n                };\n            }\n            else\n            {\n                switch (top->type)\n                {\n                    case json_object:\n\n                        switch (b)\n                        {\nwhitespace:\n                            continue;\n\n                            case '\"':\n\n                            if (flags & flag_need_comma)\n                            {  sprintf (error, \"%d:%d: Expected , before \\\"\", line_and_col);\n                                goto e_failed;\n                            }\n\n                            flags |= flag_string;\n\n                            string = (json_char *) top->_reserved.object_mem;\n                            string_length = 0;\n\n                            break;\n\n                            case '}':\n\n                            flags = (flags & ~ flag_need_comma) | flag_next;\n                            break;\n\n                            case ',':\n\n                            if (flags & flag_need_comma)\n                            {\n                                flags &= ~ flag_need_comma;\n                                break;\n                            }\n\n                            default:\n                            sprintf (error, \"%d:%d: Unexpected `%c` in object\", line_and_col, b);\n                            goto e_failed;\n                        };\n\n                        break;\n\n                    case json_integer:\n                    case json_double:\n\n                        if (isdigit (b))\n                        {\n                            ++ num_digits;\n\n                            if (top->type == json_integer || flags & flag_num_e)\n                            {\n                                if (! (flags & flag_num_e))\n                                {\n                                    if (flags & flag_num_zero)\n                                    {  sprintf (error, \"%d:%d: Unexpected `0` before `%c`\", line_and_col, b);\n                                        goto e_failed;\n                                    }\n\n                                    if (num_digits == 1 && b == '0')\n                                        flags |= flag_num_zero;\n                                }\n                                else\n                                {\n                                    flags |= flag_num_e_got_sign;\n                                    num_e = (num_e * 10) + (b - '0');\n                                    continue;\n                                }\n\n                                top->u.integer = (top->u.integer * 10) + (b - '0');\n                                continue;\n                            }\n\n                            num_fraction = (num_fraction * 10) + (b - '0');\n                            continue;\n                        }\n\n                        if (b == '+' || b == '-')\n                        {\n                            if ( (flags & flag_num_e) && !(flags & flag_num_e_got_sign))\n                            {\n                                flags |= flag_num_e_got_sign;\n\n                                if (b == '-')\n                                    flags |= flag_num_e_negative;\n\n                                continue;\n                            }\n                        }\n                        else if (b == '.' && top->type == json_integer)\n                        {\n                            if (!num_digits)\n                            {  sprintf (error, \"%d:%d: Expected digit before `.`\", line_and_col);\n                                goto e_failed;\n                            }\n\n                            top->type = json_double;\n                            top->u.dbl = (double) top->u.integer;\n\n                            num_digits = 0;\n                            continue;\n                        }\n\n                        if (! (flags & flag_num_e))\n                        {\n                            if (top->type == json_double)\n                            {\n                                if (!num_digits)\n                                {  sprintf (error, \"%d:%d: Expected digit after `.`\", line_and_col);\n                                    goto e_failed;\n                                }\n\n                                top->u.dbl += ((double) num_fraction) / (pow (10.0, (double) num_digits));\n                            }\n\n                            if (b == 'e' || b == 'E')\n                            {\n                                flags |= flag_num_e;\n\n                                if (top->type == json_integer)\n                                {\n                                    top->type = json_double;\n                                    top->u.dbl = (double) top->u.integer;\n                                }\n\n                                num_digits = 0;\n                                flags &= ~ flag_num_zero;\n\n                                continue;\n                            }\n                        }\n                        else\n                        {\n                            if (!num_digits)\n                            {  sprintf (error, \"%d:%d: Expected digit after `e`\", line_and_col);\n                                goto e_failed;\n                            }\n\n                            top->u.dbl *= pow (10.0, (double)\n                                    (flags & flag_num_e_negative ? - num_e : num_e));\n                        }\n\n                        if (flags & flag_num_negative)\n                        {\n                            if (top->type == json_integer)\n                                top->u.integer = - top->u.integer;\n                            else\n                                top->u.dbl = - top->u.dbl;\n                        }\n\n                        flags |= flag_next | flag_reproc;\n                        break;\n\n                    default:\n                        break;\n                };\n            }\n\n            if (flags & flag_reproc)\n            {\n                flags &= ~ flag_reproc;\n                -- state.ptr;\n            }\n\n            if (flags & flag_next)\n            {\n                flags = (flags & ~ flag_next) | flag_need_comma;\n\n                if (!top->parent)\n                {\n                    /* root value done */\n\n                    flags |= flag_done;\n                    continue;\n                }\n\n                if (top->parent->type == json_array)\n                    flags |= flag_seek_value;\n\n                if (!state.first_pass)\n                {\n                    json_value * parent = top->parent;\n\n                    switch (parent->type)\n                    {\n                        case json_object:\n\n                            parent->u.object.values\n                                [parent->u.object.length].value = top;\n\n                            break;\n\n                        case json_array:\n\n                            parent->u.array.values\n                                [parent->u.array.length] = top;\n\n                            break;\n\n                        default:\n                            break;\n                    };\n                }\n\n                if ( (++ top->parent->u.array.length) > state.uint_max)\n                    goto e_overflow;\n\n                top = top->parent;\n\n                continue;\n            }\n        }\n\n        alloc = root;\n    }\n\n    return root;\n\ne_unknown_value:\n\n    sprintf (error, \"%d:%d: Unknown value\", line_and_col);\n    goto e_failed;\n\ne_alloc_failure:\n\n    strcpy (error, \"Memory allocation failure\");\n    goto e_failed;\n\ne_overflow:\n\n    sprintf (error, \"%d:%d: Too long (caught overflow)\", line_and_col);\n    goto e_failed;\n\ne_failed:\n\n    if (error_buf)\n    {\n        if (*error)\n            strcpy (error_buf, error);\n        else\n            strcpy (error_buf, \"Unknown error\");\n    }\n\n    if (state.first_pass)\n        alloc = root;\n\n    while (alloc)\n    {\n        top = alloc->_reserved.next_alloc;\n        state.settings.mem_free (alloc, state.settings.user_data);\n        alloc = top;\n    }\n\n    if (!state.first_pass)\n        json_value_free_ex (&state.settings, root);\n\n    return 0;\n}\n\njson_value * json_parse (const json_char * json, size_t length)\n{\n    json_settings settings = { 0 };\n    return json_parse_ex (&settings, json, length, 0);\n}\n\nvoid json_value_free_ex (json_settings * settings, json_value * value)\n{\n    json_value * cur_value;\n\n    if (!value)\n        return;\n\n    value->parent = 0;\n\n    while (value)\n    {\n        switch (value->type)\n        {\n            case json_array:\n\n                if (!value->u.array.length)\n                {\n                    settings->mem_free (value->u.array.values, settings->user_data);\n                    break;\n                }\n\n                value = value->u.array.values [-- value->u.array.length];\n                continue;\n\n            case json_object:\n\n                if (!value->u.object.length)\n                {\n                    settings->mem_free (value->u.object.values, settings->user_data);\n                    break;\n                }\n\n                value = value->u.object.values [-- value->u.object.length].value;\n                continue;\n\n            case json_string:\n\n                settings->mem_free (value->u.string.ptr, settings->user_data);\n                break;\n\n            default:\n                break;\n        };\n\n        cur_value = value;\n        value = value->parent;\n        settings->mem_free (cur_value, settings->user_data);\n    }\n}\n\nvoid json_value_free (json_value * value)\n{\n    json_settings settings = { 0 };\n    settings.mem_free = default_free;\n    json_value_free_ex (&settings, value);\n}\n\n","/*****************************************************************************\n\n * Author: Numerical recepies in C, modified by Ludvig Sundström\n\n * File Name: linmin.c\n\n * Description: \n * GraphPointeriven an n-dimensional point p[1..n] and an n-dimensional direction\n * xi[1..n], moves and resets p to where the function func(p) takes on a\n * minimum along the direction xi from p, and replaces xi by the actual vector\n * displacement that p was moved. Also returns as fret the value of func at the\n * returned location p. This is actually all accomplished by calling the\n * routines mnbrak and brent.  \n\n * Creation Date: 25-06-2015\n\n *****************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"constants.h\"\n#include \"graph.h\"\n#include \"vertex.h\"\n#include \"util.h\"\n#include \"isolate_minimum.h\"\n#include \"bracket_minimum.h\"\n\nfloat step(float x, GraphPointer gp)   \n{   \n    VertexSet_move(gp->vs, gp->vs.n, x);\n\n    Graph_reset_dynamics(gp);\n    (*gp->calc_e)(gp);\n\n    float f;\n    f = gp->e;\n\n    return f;\n}\n\nvoid linmin(GraphPointer gp, float *fret)   \n{   \n    int nv;\n    nv = gp->vs.n;\n\n    VertexSet vs;\n    vs = gp->vs;\n\n    VertexSet_set_statics(vs, nv);    \n\n    float ax, xx;\n    ax = 0.0; \n    xx = 1.0;   \n    \n    float bx, fa, fx, fb;\n    bracket_minimum(gp, &ax, &xx, &bx, &fa, &fx, &fb, step);   \n\n    float xmin;\n    *fret = isolate_minimum(gp, ax, xx, bx, step, TOL, &xmin);   \n    \n    VertexSet_apply_forces_scalar(gp->vs, gp->vs.n, xmin);\n}   \n\n","/***************************************************************************** \n * Author: Ludvig Sundström\n\n * File Name: minimizer.c\n \n * Description: Defines an object able to 'minimize' the energy of the graph\n * G(V, B) created by the set of Vertices V and Bonds B defined in JSON format.\n \n * Creation Date: 24-06-2015\n\n *****************************************************************************/\n/*****************************************************************************\n\n * Author : Numerical recepies in C, modiefied by Ludvig Sundström\n\n * File Name : conjugate_gradient.c\n\n * Purpose : Performs Fletcher-Reeves-Polak-Ribiere minimization\n * GraphPointeriven a Set of vertices vs and a set of bonds bs, performs\n * minimization on a\n * function func using its gradient calculated by dfunc. The convergence\n * tolerance of func is ftol.  Returned quatities are p - the location of the\n * minimum, iter - the number of iterations performed and fret - the minimum\n * value of value.  Calls routine linmin to perform line minimizations.\n\n * Creation Date : 25-06-2015\n\n *****************************************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"util.h\"\n#include \"constants.h\"\n#include \"graph.h\"\n#include \"process_input.h\"\n#include \"linmin.h\"\n#include \"energy.h\"\n#include \"gradient.h\"\n\n#include \"emscripten.h\"\n\n#ifndef EMSCRIPT\n#define EMSCRIPT 0\n#endif\n\n#define FREE_ALL free(varr); free(barr); free(zarr);\n\nstatic void initialize_arrays(float **varr, int **barr, int **zarr, \n        int nv, int nb, int nz)\n{\n    *varr = (float *) Util_allocate(nv * 2, sizeof(float));\n    *barr = (int *) Util_allocate(nb * 2, sizeof(int));\n    *zarr = (int *) Util_allocate(nz * 3, sizeof(int));\n}\n\n/**\n * 1. Projects the positions of the vertices vs of length nv on to the array\n * vsarr of length nv * 2\n * 2. Projects the id's of the connecting vertices of the bonds bs of length bn\n * to the array bsarr of length nb * 2\n */\nstatic void graph_toarrays(GraphPointer gp, float *vsarr, int *bsarr, int *zarr)\n{\n    int i;\n    for (i = 0; i < gp->vs.n; i++) {\n        *(vsarr + i * 2) = (*(gp->vs.set + i))->pos.x;\n        *(vsarr + i * 2 + 1) = (*(gp->vs.set + i))->pos.y;\n    }\n    for (i = 0; i < gp->bs.n; i++) {\n        *(bsarr + i * 2) = (*(gp->bs.set + i))->fst->id;\n        *(bsarr + i * 2 + 1) = (*(gp->bs.set + i))->snd->id;\n    }\n    for (i = 0; i < gp->grd->nz; i++) {\n        ZP z = *(gp->grd->zps + i);\n        *(zarr + i * 3) = z->minx;\n        *(zarr + i * 3 + 1) = z->miny;\n        *(zarr + i * 3 + 2) = z->width;\n    }\n}\n\nstatic void js_interact(float *varr, int *barr, int *zarr, GraphPointer gp)\n{\n    if (EMSCRIPT) {\n        graph_toarrays(gp, varr, barr, zarr);\n        EM_ASM_({\n            window.EXPORTS.processCdata($0, $1, $2, $3, $4, $5);\n        }, varr, barr, zarr, gp->vs.n * 2, gp->bs.n * 2, gp->grd->nz * 3);\n    }\n}\n\nstatic int close_to_target(float fret, float e, float ftol)\n{\n    return 2.0 * fabs(fret - e) <= ftol * (fabs(fret) + fabs(e) + EPS);\n}\n\nstatic void conjugate_gradient(GraphPointer gp, float ftol)\n{\n\n    float *varr;\n    int *barr, *zarr;\n    initialize_arrays(&varr, &barr, &zarr, gp->vs.n, gp->bs.n, gp->grd->nz);\n    \n    Graph_run_objective(gp);\n\n    VertexSet_apply_forces(gp->vs, gp->vs.n, 1, INITIALIZE);\n\n    float e;\n    e = gp->e;\n    \n   int i; \n    for (i = 0; i < ITMAX; i++) {\n        \n        float fret = 0.0;\n        linmin(gp, &fret);\n\n        if (close_to_target(fret, e, ftol)) break;\n\n        Graph_run_objective(gp);\n\n        e = gp->e;\n\n        float gg, dgg;\n        dgg = gg = 0.0;\n        VertexSet_calculate_score(gp->vs, gp->vs.n, &gg, &dgg); \n\n        if (fabs(gg) < EPS) break;\n        \n        float gam;\n        gam = dgg / gg;\n        VertexSet_apply_forces(gp->vs, gp->vs.n, gam, UPDATE);\n    }\n    js_interact(varr, barr, zarr, gp);\n    FREE_ALL;\n    return;\n}\n\nint Minimizer_run(const char *fname) \n{\n\n    GraphPointer gp;\n    gp = Graph_create(fname, Energy_local, Gradient_local);\n\n    conjugate_gradient(gp, FTOL);\n\n    printf(\"Done, local optimization\\n\");\n    \n    Graph_free(gp);\n\n    return 0;\n}\n\n\n","/*****************************************************************************\n\n* File Name: Pair.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 30-07-2015\n\n*****************************************************************************/\n\n#include <stdlib.h>\n#include \"util.h\"\n#include \"pair.h\"\n\nPair Pair_initialize(void *fst, void *snd) \n{\n    Pair rtn;\n    rtn.fst = fst;\n    rtn.snd = snd;\n    return rtn;\n}\n\nPairPointer Pair_create(void *fst, void *snd) \n{\n    PairPointer rtn = (PairPointer) Util_allocate(1, sizeof(Pair));\n    *rtn = Pair_initialize(fst, snd);\n    return rtn;\n}\n\n","/*****************************************************************************\n\n* File Name: placement.c\n\n* Author: Ludvig Sundström\n\n* Description: Assign positions (x, y) to a set of vertices\n\n* Creation Date: 13-07-2015\n\n*****************************************************************************/\n\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"vertex.h\"\n#include \"vertex_set.h\"\n#include \"constants.h\"\n#include \"util.h\"\n\n/* Private *******************************************************************/\n\nstatic int comp_by_mass(const void *elem1, const void *elem2) \n{\n    VertexPointer *fst = (VertexPointer *) elem1;\n    VertexPointer *snd = (VertexPointer *) elem2;\n    if ((*fst)->mass < (*snd)->mass) return 1;\n    if ((*fst)->mass > (*snd)->mass) return -1;\n    return 0;\n}\n\nstatic int comp_by_id(const void *elem1, const void *elem2) \n{\n    VertexPointer *fst = (VertexPointer *) elem1;\n    VertexPointer *snd = (VertexPointer *) elem2;\n    if ((*fst)->id > (*snd)->id) return 1;\n    if ((*fst)->id < (*snd)->id) return -1;\n    return 0;\n}\n\n/* Public ********************************************************************/\n\n/**\n * Assigns the positions of vertices vs as a spiral starting from the middle of\n * the panel whose dimension are specified by PANEL_X and PANEL_Y, starting\n * with the vertex with the most connections, the vertex with the second most\n * connections etc.\n */\nvoid Placement_set_spiral(VertexSet vs, const int nv)\n{\n    qsort(vs.set, nv, sizeof(void *), comp_by_mass);\n    int n, gapx, gapy, dimx, dimy, i, x, y, \n        placex, placey, dx, dy, t, max_iter, count;\n    n = nv;\n    while (fabs(sqrt(n) - (int) sqrt(n)) > EPS) {\n        n++;\n    }\n    dimx = dimy = sqrt(n);\n    count = 0;\n    gapx = PANEL_X / dimx;\n    gapy = PANEL_Y / dimy;\n    i = x = y = 0;\n    dx = 0;\n    dy = -1;\n    t = fmax(dimx, dimy);\n    max_iter = t * t;\n    for (i = 0; i < max_iter; i++) {\n        if (count < nv && !(*(vs.set + count))->pos.given_coords) {\n            if ((-dimx / 2 <= x && x <= dimx / 2) && \n                (-dimy / 2 <= y && y <= dimy / 2))\n            {\n                placex = x * gapx + PANEL_X / 2;\n                placey = y * gapy + PANEL_Y / 2;\n                (*(vs.set + count))->pos.x = placex; \n                (*(vs.set + count))->pos.y = placey; \n                count++;\n            }\n        } else {\n            count++;\n        }\n        if ((x == y) || (x < 0 && x == -y) || (x > 0 && x == 1 - y)) {\n            t = dx;\n            dx = -dy;\n            dy = t;\n        }\n        x += dx;\n        y += dy; \n    }\n    qsort(vs.set, nv, sizeof(void *), comp_by_id);\n}\n\n/**\n * Assigns the positions of vertices vs.set as a grid in the panel whose dimension\n * are specified by PANEL_X and PANEL_Y, starting in the upper-left corner with\n * the vertex with the lowest id. \n */\nvoid Placement_set_grid(VertexSet vs, const int nv) \n{\n    int i, n, vdim, rows, cols;\n    float gapx, gapy, offsetx, offsety, x, y;\n    n = nv; \n    while (fabs(sqrt(n) - (int) sqrt(n)) > EPS) {\n        n++;\n    }\n    vdim = sqrt(n);\n    gapx = PANEL_X / vdim;\n    gapy = PANEL_Y / vdim;\n    offsetx = gapx / 2;\n    offsety = gapy / 2;\n    rows = 0;\n    cols = -1;\n    for (i = 0; i < nv; i++) {\n        if (i % vdim == 0) {\n            rows++;\n            cols = 0; \n        }\n        x = cols * gapx + offsetx;\n        y = rows * gapy + offsety; \n        (*(vs.set + i))->pos = Vector_initialize(x, y);\n        cols++;\n    }\n}\n","\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <math.h>\n\n#include \"constants.h\"\n#include \"util.h\"\n#include \"json.h\"\n#include \"graph.h\"\n#include \"vertex_set.h\"\n#include \"vertex_set.h\"\n\nPair process_json(const char *filename, int *nvp, int *nbp)\n{\n    FILE *fp;\n    struct stat filestatus;\n    int file_size;\n    char* file_contents;\n    json_char* json;\n    json_value* value;\n\n    if ( stat(filename, &filestatus) != 0) {\n        char  buf[256];\n        strcpy(buf, \"process_json(): File not found: \");\n        strcat(buf, filename);\n        rt_error(buf);\n    }\n    file_size = filestatus.st_size;\n    file_contents = (char *) malloc(filestatus.st_size);\n    if ( file_contents == NULL) {\n        rt_error(\"process_json(): Unable to allocate memory\");\n    }\n\n    fp = fopen(filename, \"rt\");\n\n    if (fp == NULL) {\n        fclose(fp);\n        free(file_contents);\n        rt_error(\"process_json(): Unable to open file\");\n    }\n    if ( fread(file_contents, file_size, 1, fp) != 1 ) {\n        fclose(fp);\n        free(file_contents);\n        rt_error(\"process_json(): Unable to read file\");\n    }\n\n    fclose(fp);\n\n    json = (json_char*)file_contents;\n\n    value = json_parse(json,file_size);\n\n    if (value == NULL) {\n        free(file_contents);\n        json_value_free(value);\n        rt_error(\"process_json(): Unable to parse data\");\n    }\n    if (value->u.object.length != 2) {\n        free(file_contents);\n        json_value_free(value);\n        rt_error(\"process_json(): Wrong number of keys\");\n    }\n    if (strcmp(value->u.object.values[0].name, \"vertices\") != 0) {\n        free(file_contents);\n        json_value_free(value);\n        rt_error(\"process_json(): First key is not vertices\");\n    }\n    if (strcmp(value->u.object.values[1].name, \"bonds\") != 0) {\n        free(file_contents);\n        json_value_free(value);\n        rt_error(\"process_json(): Second key is not 'bonds'\");\n    }\n\n    VertexSetPointer vs; BondSetPointer bs;\n    vs = VertexSet_create(value, nvp);\n    bs = BondSet_create(vs->set, value, nbp);\n\n    json_value_free(value);\n    free(file_contents);\n\n    return Pair_initialize(vs, bs);\n}\n\n","/*****************************************************************************\n* Author : Ludvig Sundström\n* File Name : util.c\n\n * Purpose : \n\n * Creation Date : 26-06-2015\n\n * Last Modified : \n\n *****************************************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <limits.h>\n\n#include \"util.h\"\n#include \"constants.h\"\n\n#define ANSI_COLOR_RED \"\\x1b[31m\"\n#define ANSI_COLOR_RESET \"\\x1b[0m\"\n    \nint equal(const float tar, const float x) {\n    return fabs(x - tar) < COMP_EPS;\n}\n\nint about(const float tar, const float x) {\n    if (equal(tar, x)) return 1;\n    float err;\n    err = fabs(x * MIN_DIST);\n    return fabs(x - tar) <= err;\n}\n\nint in_range(const float lower, const float upper, const float x)\n{\n    int lowcond = x > lower;\n    int upcond = x < upper;\n    return lowcond && upcond;\n}\n\nvoid *Util_allocate(int nmemb, int size) {\n    void *rtn = malloc(nmemb * size);\n    if (rtn == NULL)\n    {\n        rt_error(\"Error when allocating memory\");\n    }\n    return rtn;\n}\n\nvoid *Util_allocate_initialize(int nmemb, int size) {\n    void *rtn = calloc(nmemb, size);\n    if (rtn == NULL)\n    {\n        rt_error(\"Error when allocating memory\");\n    }\n    return rtn;\n}\n\nvoid rt_error(char error_text[])\n{\n    fprintf(stderr,ANSI_COLOR_RED \"Runtime-error:%s\\n\" ANSI_COLOR_RESET,\n            error_text);\n    exit(1);\n}\n\n","/*****************************************************************************\n\n* File Name: math2D.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 06-07-2015\n\n*****************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#include \"vector.h\"\n#include \"util.h\"\n\nVector Vector_initialize(float x, float y)\n{\n    Vector rtn;\n    rtn.x = x;\n    rtn.y = y;\n    rtn.given_coords = 0;\n    rtn.len = sqrtf(x * x + y * y);\n    return rtn;\n}\n\nVectorPointer Vector_create(float x, float y)\n{\n    VectorPointer rtn = (VectorPointer) malloc(sizeof(Vector));\n    *rtn = Vector_initialize(x, y);\n    return rtn;\n}\n\nVector Vector_zero()\n{\n    return Vector_initialize(0.0f, 0.0f);\n}\n\nVector Vector_add(Vector vec1, Vector vec2) \n{\n    return Vector_initialize(vec1.x + vec2.x, vec1.y + vec2.y);\n}\n\nVector Vector_sub(Vector vec1, Vector vec2) \n{\n    return Vector_initialize(vec1.x - vec2.x, vec1.y - vec2.y);\n}\n\nVector Vector_negate(Vector vec) \n{\n    return Vector_initialize(-vec.x, -vec.y);\n}\n\nVector Vector_scalar_mult(Vector vec, float c)\n{\n    return Vector_initialize(c * vec.x, c * vec.y);\n}\n\nfloat Vector_dot(Vector v1, Vector v2)\n{   \n    return v1.x * v2.x + v1.y * v2.y;\n}\n\nfloat Vector_norm(Vector v) \n{\n    return sqrt(Vector_dot(v, v));\n}\n\nfloat Vector_angle(Vector v1, Vector v2)\n{\n    float scalp, lenp, div;\n    scalp = Vector_dot(v1, v2);\n    lenp = (v1.len * v2.len);\n    if (equal(lenp, 0)) rt_error(\"Division by zero\");\n    if (scalp != scalp) rt_error(\"angle: Nan scalp\");\n    if (equal(scalp, lenp) || equal(scalp, -lenp) || equal(-scalp, lenp))\n        return 0.0;\n    div = scalp / lenp;\n    if (equal(div, 1.0) || equal(div, -1.0)) \n        return 0.0;\n    if (!in_range(-1.0, 1.0, div)) {\n        rt_error(\"Outside acos range\"); \n    }\n    return acosf(div);\n}\n\nint Vector_parallel(Vector v1, Vector v2)\n{\n    return equal(Vector_angle(v1, v2), 0);\n}\n\nint Vector_equal(Vector v1, Vector v2)\n{\n    return equal(v1.x, v2.x) && equal(v1.y, v2.y);\n}\n\n/**\n * Magnitude of the vector that would result from a regular 3D space. \n */\n\nfloat Vector_cross(Vector vec1, Vector vec2)\n{\n    return (vec1.x * vec2.y) - (vec2.x * vec1.y);\n}\n\n","/*****************************************************************************\n\n* File Name: vertex.c\n\n* Author: Ludvpig Sundström\n\n* Description: \n\n* Creation Date: 28-07-2015\n\n*****************************************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n\n#include \"util.h\"\n#include \"vertex.h\"\n#include \"constants.h\"\n\n/* Private ******************************************************************/\n\nstatic Vector center_distance(const VertexPointer vp) \n{\n    int cx, cy;\n    cx = PANEL_X / 2; cy = PANEL_Y / 2;\n    Vector rtn;\n    rtn = Vector_initialize((float) cx - vp->pos.x, (float) cy - vp->pos.y);\n    return rtn;\n}\n\nstatic float potential_weight(const VertexPointer vp) \n{\n    return WPOT;\n}\n\n\n/* Public  ******************************************************************/\n\nvoid Vertex_reset_dynamics(VertexPointer v) \n{\n    v->next = NULL;\n}\n\nVertexPointer Vertex_create(\n       const int id, \n       const Vector pos, \n       const Vector grad, \n       const Vector g, \n       const Vector h, \n       const float wdth, \n       const float hght, \n       const char type, \n       const int nv) \n{\n    VertexPointer rtn;\n    rtn = Util_allocate_initialize(1, sizeof(Vertex));\n    rtn->id = id;\n    rtn->mass = 1;\n    rtn->pos = pos;\n    rtn->tl = Vector_sub(pos, Vector_initialize((PADDING + wdth) / 2, \n                (PADDING + hght) / 2));\n    rtn->br = Vector_add(pos, Vector_initialize((PADDING + wdth) / 2, \n                (PADDING + hght) / 2));\n    rtn->grad = grad;\n    rtn->g = g;\n    rtn->h = h;\n    rtn->type = type;\n    rtn->crs_bof = (int *) calloc(nv, sizeof(int));\n    Vertex_reset_dynamics(rtn);\n    return rtn;\n}\n\nvoid Vertex_move(const VertexPointer vp, const Vector s) \n{\n    vp->pos.x = s.x;\n    vp->pos.y = s.y;\n\n    vp->tl.x = s.x - (PADDING / 2);\n    vp->tl.y = s.y - (PADDING / 2);\n\n    vp->br.x = s.x + (PADDING / 2);\n    vp->br.y = s.y + (PADDING / 2);\n}\n\nfloat Vertex_potential_energy(const VertexPointer vp) \n{\n    Vector cdist;\n    cdist = center_distance(vp);\n\n    float w;\n    w = potential_weight(vp);\n    \n    return w * powf(Vector_norm(cdist), 2);\n}\n\nVector Vertex_potential_gradient(const VertexPointer vp)\n{\n    Vector cdist;\n    cdist = center_distance(vp);\n\n    float w;\n    w = potential_weight(vp);\n\n    return Vector_scalar_mult(cdist, 2 * w);\n}\n\nvoid Vertex_free(VertexPointer vp)\n{\n    free(vp->crs_bof);\n    free(vp);\n}\n\n","/*****************************************************************************\n\n* File Name: vertex_pair.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 31-07-2015\n\n*****************************************************************************/\n\n#include \"math.h\"\n#include \"constants.h\"\n#include \"vertex.h\"\n#include \"pair.h\"\n\n/* Private ******************************************************************/\n\nstatic float repulsion_weight(const Pair pr) \n{\n    return 2 * WREP;\n}\n\n/* Public *******************************************************************/\n\nfloat VertexPair_repulsion_energy(const Pair pr) \n{\n    float w;\n    w = repulsion_weight(pr);\n\n    VertexPointer vp0, vp1;\n    vp0 = (VertexPointer) pr.fst;\n    vp1 = (VertexPointer) pr.snd;\n\n    int cb;\n    /*cb = *(vp0->crs_bof + vp1->id);*/\n    cb = 0;\n    if (cb) {\n        w *= REPULSION_REDUCE;\n    }\n\n    float x_o, y_o, a_o;\n    x_o = fmax(0.0, fmin(vp0->br.x, vp1->br.x) - fmax(vp0->tl.x, vp1->tl.x));\n    y_o = fmax(0.0, fmin(vp0->br.y, vp1->br.y) - fmax(vp0->tl.y, vp1->tl.y));\n    a_o = x_o * y_o;\n\n    return w * a_o;\n}\n\nVector VertexPair_repulsion_gradient(const Pair pr)\n{\n    \n    float w;\n    w = repulsion_weight(pr);\n\n    VertexPointer vp0, vp1;\n    vp0 = (VertexPointer) pr.fst;\n    vp1 = (VertexPointer) pr.snd;\n\n    int cb;\n    cb = *(vp0->crs_bof + vp1->id);\n    if (cb) {\n        w *= 0.5;\n    }\n\n    Vector frc;\n    if (vp1->pos.x < vp0->pos.x + PADDING && vp0->pos.x < vp1->pos.x) {\n        frc.x = -(fmax(0.0, fmin(vp0->br.y, vp1->br.y) - \n                fmax(vp0->tl.y, vp1->tl.y)));\n    } else if (vp1->pos.x < vp0->pos.x && vp0->pos.x < vp1->pos.x + PADDING) {\n        frc.x = (fmax(0.0, fmin(vp0->br.y, vp1->br.y) - \n                fmax(vp0->tl.y, vp1->tl.y)));\n    } else {\n        frc.x = 0.0;\n    }\n    if (vp1->pos.y < vp0->pos.y + PADDING && vp0->pos.y < vp1->pos.y) {\n        frc.y = -(fmax(0.0, fmin(vp0->br.x, vp1->br.x) - \n                fmax(vp0->tl.x, vp1->tl.x)));\n    } else if (vp1->pos.y < vp0->pos.y && vp0->pos.y < vp1->pos.y + PADDING) {\n        frc.y = (fmax(0.0, fmin(vp0->br.x, vp1->br.x) - \n                fmax(vp0->tl.x, vp1->tl.x)));\n    } else {\n        frc.y = 0.0;\n    }\n\n    return Vector_scalar_mult(frc, w);\n}\n\n","/*****************************************************************************\n\n* File Name: vertex_set.c\n\n* Author: Ludvig Sundström\n\n* Description: Represents a set of vertices\n\n* Creation Date: 31-07-2015\n\n*****************************************************************************/\n\n#include <stdlib.h>\n\n#include \"util.h\"\n#include \"constants.h\"\n#include \"vertex_set.h\"\n\nVertexSet VertexSet_initialize(json_value *contents, int *nvp)\n{\n    json_value *vsarr = contents->u.object.values[0].value;\n    *nvp = vsarr->u.array.length;\n\n    int nv;\n    nv = *nvp;\n\n    VertexSet rtn;\n    rtn.set = (VertexPointer *) Util_allocate(nv, sizeof(VertexPointer));\n    rtn.n = nv;\n\n    if (nv < 1) {\n        rt_error(\"No vertices\");\n    }\n\n    int i;\n    for (i = 0; i < nv; i++) {\n        \n        json_value *vertex;  \n        vertex = vsarr->u.array.values[i];\n\n        json_value *ident;\n        int id;\n        id = -99;\n        ident = vertex->u.object.values[0].value;\n        if (ident->type == json_integer) {\n            id = ident->u.integer;\n        } else {\n            rt_error(\"Bad JSON data: ident\");\n        }\n\n        Vector pos, zv;\n        zv = Vector_zero();\n        pos = zv;    \n        json_value *position;\n        position = vertex->u.object.values[1].value;\n        if (position->type == json_array) {\n            int length;\n            float x, y;\n            x = y = 0;\n            length = position->u.array.length;\n            if (length != 2) {\n                rt_error(\"Bad JSON data, position dimension not 2\");\n            }\n            json_value *j_x = position->u.array.values[0];\n            json_value *j_y = position->u.array.values[1];\n            if (j_x->type == json_integer) {\n                x = (float) j_x->u.integer;\n            } else if (j_x->type == json_double) {\n                x = (float) j_x->u.dbl;\n            } else {\n                rt_error(\"Bad JSON data: position: x\");\n            }\n            if (j_y->type == json_integer) {\n                y = (float) j_y->u.integer;\n            } else if (j_x->type == json_double) {\n                y = (float) j_y->u.dbl;\n            } else {\n                rt_error(\"Bad JSON data: position: y\");\n            }\n            pos = Vector_initialize(x, y);\n            pos.given_coords = 1;\n        } \n        else {\n            if (position->type != json_null) {\n                rt_error(\"Bad JSON data: position\");\n            }\n        }\n\n        char t;\n        t = 0;\n        json_value *vertex_type;\n        vertex_type = vertex->u.object.values[3].value;\n        if (vertex_type->type == json_string) {\n            t = vertex_type ->u.string.ptr[0];\n        } else {\n            rt_error(\"Bad JSON data: type\");\n        }\n\n        *(rtn.set + i) = Vertex_create(id, pos, zv, zv, zv, \n                VERTEX_BASE_WIDTH, VERTEX_BASE_HEIGHT, t, nv);\n    }\n    return rtn;\n}\n\nVertexSetPointer VertexSet_create(json_value *contents, int *nvp)\n{\n    VertexSetPointer rtn;\n    rtn = (VertexSetPointer) malloc(sizeof(VertexSet));\n    *rtn = VertexSet_initialize(contents, nvp);\n    return rtn;\n}\n\nvoid VertexSet_sort(VertexPointer *vquad, Vector cross) \n{\n    int i;\n    for (i = 0; i < 3; i++) {\n        int j;\n        for (j = i + 1; j < 4; j++) {\n            VertexPointer vpi = *(vquad + i);\n            VertexPointer vpj = *(vquad + j);\n            if (vpj->mass < vpi->mass) {\n                VertexPointer tmp = vquad[i];\n                vquad[i] = vquad[j];\n                vquad[j] = tmp;\n            } else if (vpj->mass == vpi->mass) {\n                float di, dj;\n                di = Vector_norm(Vector_sub(cross, vpi->pos));\n                dj = Vector_norm(Vector_sub(cross, vpj->pos));\n                if (dj < di) {\n                    VertexPointer tmp = vquad[i];\n                    vquad[i] = vquad[j];\n                    vquad[j] = tmp;\n                }\n            }\n        }\n    }\n}\n\nvoid VertexSet_move(const VertexSet vs, const int nv, float x) \n{\n    int i;   \n    for (i = 0; i < nv; i++) {\n\n        struct vertex *v = *(vs.set + i);\n\n        Vector ds, s;\n        ds = Vector_scalar_mult(v->grad0, x);\n        s = Vector_add(v->pos0, ds);\n\n        Vertex_move(v, s);\n    }\n}\n\nvoid VertexSet_apply_forces(\n        const VertexSet vs, \n        const int nv, \n        const float gam, \n        const Strategy strat\n    )\n{\n    int i;\n    for (i = 0; i < nv; i++) {\n        VertexPointer vp = *(vs.set + i);\n        vp->g.x = -vp->grad.x;\n        vp->g.y = -vp->grad.y;\n        if (strat == INITIALIZE) {\n            vp->grad.x = vp->h.x = vp->g.x;\n            vp->grad.y = vp->h.y = vp->g.y;\n        } else {\n            vp->grad.x = vp->h.x = vp->g.x + gam * vp->h.x;\n            vp->grad.y = vp->h.y = vp->g.y + gam * vp->h.y;\n        }\n    }\n}\n\nvoid VertexSet_apply_forces_scalar(const VertexSet vs, const int nv, float x)\n{\n    int i;\n    for (i = 0; i < nv; i++) { \n        VertexPointer vp = *(vs.set + i);\n        vp->grad.x *= x;\n        vp->grad.y *= x;\n    }   \n}\n\n\nvoid VertexSet_calculate_score(\n        const VertexSet vs, \n        const int nv, \n        float *gg, \n        float *dgg)\n{\n    int i;\n    for (i = 0; i < nv; i++) {\n        VertexPointer vp = *(vs.set + i);\n        *gg += vp->g.x * vp->g.x;\n        *gg += vp->g.y * vp->g.y;\n        *dgg += (vp->grad.x + vp->g.x) * vp->grad.x;\n        *dgg += (vp->grad.y + vp->g.y) * vp->grad.y;\n    }\n}\n\nvoid VertexSet_set_statics(const VertexSet vs, const int nv)\n{\n    int i;\n    for (i = 0; i < nv; i++) {\n        VertexPointer vp;\n        vp = *(vs.set + i);\n        vp->pos0 = vp->pos;\n        vp->grad0 = vp->grad;\n    }\n}\n\nvoid VertexSet_free(VertexSet vs) \n{\n    int i;\n    for (i = 0; i < vs.n; i++) {\n        Vertex_free(*(vs.set + i));\n    }\n    free(vs.set);\n}\n\n\n","/*****************************************************************************\n\n* File Name: zone2d.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 24-07-2015\n\n*****************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"zone.h\"\n\nZP Zone_create(const int id, const int i, const int j, const int minx, \n        const int miny, const int width, const int height) \n{\n    ZP rtn = malloc(sizeof(Z));\n    rtn->id = id;\n    rtn->i = i;\n    rtn->j = j;\n    rtn->minx = minx; rtn->miny = miny;\n    rtn->width = width; rtn->height = height;\n    return rtn;\n}\n\n\nvoid Zones_free(ZP *zs, int nz) \n{\n    int i;\n    for (i = 0; i < nz; i++) {\n        free(*(zs + i));\n    }\n    zs = NULL;\n}\n\n","/*****************************************************************************\n\n* File Name: zone_pair.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 31-07-2015\n\n*****************************************************************************/\n\n#include <stdlib.h>\n\n#include \"pair.h\"\n#include \"zone_pair.h\"\n\nZ2P ZonePair_create(Pair pr, Z2P next)\n{\n    Z2P rtn = (Z2P) malloc(sizeof(Z2));\n    rtn->fst = (ZP) pr.fst;\n    rtn->snd = (ZP) pr.snd;\n    rtn->next = next;\n    return rtn;\n}\n\nvoid ZonePairs_free(Z2P z2p)\n{\n    Z2P cur = z2p;\n    while(cur != NULL) {\n        Z2P tmp = cur;\n        cur = cur->next;\n        free(tmp);\n    }\n}\n\n"]}