{"version":3,"file":"lib/c_assets.js","sources":["lib/c/brent.c","lib/c/mnbrak.c","lib/c/gradient.c","lib/c/objective.c","lib/c/graph.c","lib/c/util.c","lib/c/minimizer.c","lib/c/frprmn.c","lib/c/math2D.c","lib/c/linmin.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;AAAA;AACA;AAAA;AAEA;AAGA;;;AADA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAIA;AAAA;;;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;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","sourcesContent":["/*****************************************************************************\n * Author : Ludvig Sundström\n *\n * File Name : brent.c\n *\n * Purpose : \n *\n * Creation Date : 25-06-2015\n *\n *****************************************************************************/\n\n#include <math.h>\n#include \"util.h\"\n\n#define ITMAX 100\n#define CGOLD 0.3819660\n#define ZEPS 1.0e-10\n\nfloat brent(float ax, float bx, float cx, float (*f)(float), float tol,\n        float *xmin)\n{\n    int iter;\n    float a,b,d,etemp,fu,fv,fw,fx,p,q,r,tol1,tol2,u,v,w,x,xm;\n    float e=0.0;\n    void rt_error(); \n\n    a=(ax < cx ? ax : cx);\n    b=(ax > cx ? ax : cx);\n    x = w = v = bx;\n    fw=fv=fx=(*f)(x);\n    for (iter = 1;iter <= ITMAX; iter++) {\n        xm = 0.5 * (a + b);\n        tol2 = 2.0 * (tol1 = tol * fabs(x) + ZEPS);\n        if (fabs(x-xm) <= (tol2-0.5*(b-a))) {\n            *xmin=x;\n            return fx;\n        }\n        if (fabs(e) > tol1) {\n            r = (x - w) * (fx - fv);\n            q =(x - v) * (fx - fw);\n            p = (x - v) * q - (x - w) * r;\n            q = 2.0 * (q - r);\n            if (q > 0.0) p = -p;\n            q=fabs(q);\n            etemp=e;\n            e=d;\n            if (fabs(p) >= fabs(0.5*q*etemp) || p <= q*(a-x) || p >= q*(b-x))\n                d=CGOLD*(e=(x >= xm ? a-x : b-x));\n            else {\n                d=p/q;\n                u=x+d;\n                if (u-a < tol2 || b-u < tol2)\n                    d=SIGN(tol1,xm-x);\n            }\n        } else {\n            d=CGOLD*(e=(x >= xm ? a-x : b-x));\n        }\n        u=(fabs(d) >= tol1 ? x+d : x+SIGN(tol1,d));\n        fu=(*f)(u);\n        if (fu <= fx) {\n            if (u >= x) a=x; else b=x;\n            SHFT(v,w,x,u)\n                SHFT(fv,fw,fx,fu)\n        } else {\n            if (u < x) a=u; else b=u;\n            if (fu <= fw || w == x) {\n                v=w;\n                w=u;\n                fv=fw;\n                fw=fu;\n            } else if (fu <= fv || v == x || v == w) {\n                v=u;\n                fv=fu;\n            }\n        }\n    }\n    rt_error(\"Too many iterations in brent\");\n    *xmin=x;\n    return fx;\n}\n\n#undef ITMAX\n#undef CGOLD\n#undef ZEPS\n#undef SHFT\n","\n#include <math.h>\n#include \"util.h\"\n\n#define GOLD 1.618034\n#define GLIMIT 100.0\n#define TINY 1.0e-20\n\nvoid mnbrak(float *ax, float *bx, float *cx, float *fa, float *fb, \n        float *fc, float (*func)())\n{\n    float ulim,u,r,q,fu,dum;\n\n    *fa=(*func)(*ax);\n    *fb=(*func)(*bx);\n    if (*fb > *fa) {\n        SHFT(dum,*ax,*bx,dum)\n            SHFT(dum,*fb,*fa,dum)\n    }\n    *cx=(*bx)+GOLD*(*bx-*ax);\n    *fc=(*func)(*cx);\n    while (*fb > *fc) {\n        r=(*bx-*ax)*(*fb-*fc);\n        q=(*bx-*cx)*(*fb-*fa);\n        u=(*bx)-((*bx-*cx)*q-(*bx-*ax)*r)/ (2.0*SIGN(MAX(fabs(q-r),TINY),q-r));\n        ulim=(*bx)+GLIMIT*(*cx-*bx);\n        if ((*bx-u)*(u-*cx) > 0.0) {\n            fu=(*func)(u);\n            if (fu < *fc) {\n                *ax=(*bx);\n                *bx=u;\n                *fa=(*fb);\n                *fb=fu;\n                return;\n            } else if (fu > *fb) {\n                *cx=u;\n                *fc=fu;\n                return;\n            }\n            u=(*cx)+GOLD*(*cx-*bx);\n            fu=(*func)(u);\n        } else if ((*cx-u)*(u-ulim) > 0.0) {\n            fu=(*func)(u);\n            if (fu < *fc) {\n                SHFT(*bx,*cx,u,*cx+GOLD*(*cx-*bx))\n                    SHFT(*fb,*fc,fu,(*func)(u))\n            }\n        } else if ((u-ulim)*(ulim-*cx) >= 0.0) {\n            u=ulim;\n            fu=(*func)(u);\n        } else {\n            u=(*cx)+GOLD*(*cx-*bx);\n            fu=(*func)(u);\n        }\n        SHFT(*ax,*bx,*cx,u)\n        SHFT(*fa,*fb,*fc,fu)\n    }\n}\n\n#undef GOLD\n#undef GLIMIT\n#undef TINY\n#undef MAX\n#undef SIGN\n#undef SHFT\n","/*****************************************************************************\n\n* File Name: gradient.c\n\n* Author: Ludvig Sundström\n\n* Description: The gradient of the objective function.\n\n* Creation Date: 06-07-2015\n\n*****************************************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#include \"minimizer.h\"\n#include \"graph.h\"\n#include \"constants.h\"\n#include \"util.h\"\n\nstruct vertex **vs;\nstruct bond *bs;\nint dim, nv, elen, sx, sy, nb;\n\nstatic void addForce(struct point f, int i, float df[])\n{\n    df[i * 2] += f.x;\n    df[i * 2 + 1] += f.y;\n}\n\nstatic void df1(float df[])\n{\n    int i, cx, cy;\n    float dx, dy;\n    struct vertex *vi;\n    struct point frc;\n    cx = sx / 2;\n    cy = sy / 2;\n    for (i = 0; i < nv; i++) {\n        vi = *(vs + i);\n        dx = vi->pos->x - (float) cx;    \n        dy = vi->pos->y - (float) cy;\n        frc.x = -2 * WG * dx;\n        frc.y = -2 * WG * dy;\n        addForce(frc, i, df);\n    }\n}\n\nstatic void df2rep(float df[])\n{\n    int i, j;\n    float dij, dx, dy, critlen;\n    struct point frci;\n    struct vertex *vi, *vj;\n    for (i = 0; i < nv - 1; i++) {\n        for (j = i + 1; j < nv; j++) {\n            vi = *(vs + i);\n            vj = *(vs + j);\n            dx = vi->pos->x - vj->pos->x;\n            dy = vi->pos->y - vj->pos->y; \n            dij = sqrtf(dx * dx + dy * dy);\n            if (fabs(dij) < MIN_DIST) {\n                dij = MIN_DIST;\n            } \n            critlen = vi->radius + vj->radius + PADDING;\n            if (critlen > dij) {\n                frci.x = 2 * WR * dx * (dij - critlen) / dij;\n                frci.y = 2 * WR * dy * (dij - critlen) / dij;\n            } else {\n                frci.x = 0;\n                frci.y = 0;\n            }\n            addForce(frci, i, df);\n            addForce(negate(frci), j, df);\n        }\n    }\n}\n\nstatic void df2attr(float df[])\n{\n    int i;\n    float d0i, dx, dy, di, wi;\n    struct bond bi;\n    struct point frci;\n    for (i = 0; i < nb; i++) {\n        bi = *(bs + i);  \n        wi = bi.fst->mass * bi.snd->mass * DEFAULT_STIFFNESS;\n        d0i = bi.dist0 * elen;\n        dx = bi.fst->pos->x - bi.snd->pos->x;\n        dy = bi.fst->pos->y - bi.snd->pos->y; \n        di = sqrtf(dx * dx + dy * dy);\n        if (fabs(di) <  0.01) {\n            di = 0.01;\n        } \n        frci.x = -2 * wi * dx * (di - d0i) / di;\n        frci.y = -2 * wi * dy * (di - d0i) / di;\n        addForce(frci, bi.fst->id, df);\n        addForce(negate(frci), bi.snd->id, df);\n    }\n}\n\nstatic void df2(float df[]) \n{\n    df2attr(df);\n    df2rep(df);\n}\n\n\nvoid df3(struct point *ps, float df[])\n{\n    //TBI TODO\n}\n\nvoid df(float arr[], float df[]) \n{\n    int i;\n    for (i = 0; i < nv * 2; i += 2) {\n        struct vertex *vptr = *(vs + i / 2);\n        vptr->pos->x = arr[i];\n        vptr->pos->y = arr[i + 1];\n    }\n    df1(df);\n    df2(df);\n    /*df3(ps, df);*/\n}\n\n","/*****************************************************************************\n\n* File Name: objective.c \n* Author: Ludvig Sundström\n\n* Description: The objective function F = F1 + F2 + F3 + F4 where FN considers\n* N nodes. \n\n* Creation Date: 05-07-2015\n\n*****************************************************************************/\n\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"minimizer.h\"\n#include \"graph.h\"\n#include \"gradient.h\"\n#include \"constants.h\"\n#include \"util.h\"\n\nstruct vertex **vs;\nstruct bond *bs;\nint dim, nv, elen, sx, sy, nb;\n\nstatic float f1() {\n    // Should we add repulsion from walls here? TODO\n    int i, cx, cy;\n    float dxc, dyc, rtn;\n    struct vertex *vi;\n    cx = sx / 2;\n    cy = sy / 2;\n    rtn = 0;\n    for (i = 0; i < nv; i++) {\n        vi = *(vs + i);\n        dxc =  (vi->pos)->x - (float) cx;    \n        dyc =  (vi->pos)->y - (float) cy;\n        rtn += WG * (powf(dxc, 2) + powf(dyc, 2));\n    }\n    return rtn;\n}\n\nstatic float f2attr() \n{\n    int i;\n    float rtn, d0i, di, wi, dx, dy;\n    struct bond bi;\n    rtn = 0;\n    for (i = 0; i < nb; i++) {\n        bi = *(bs + i);\n        d0i = bi.dist0 * elen;\n        wi = bi.fst->mass * bi.snd->mass * DEFAULT_STIFFNESS;\n        dx = bi.fst->pos->x - bi.snd->pos->x;\n        dy = bi.fst->pos->y - bi.snd->pos->y;\n        di = sqrtf(dx * dx + dy * dy);\n        /*printf(\"%f %f %f\\n\", di, d0i, bi.dist0);*/\n        if (fabs(di) <  MIN_DIST) {\n            di = MIN_DIST;\n        } \n        rtn += wi * powf(di - d0i, 2);\n    }\n    return rtn;\n}\n\nstatic float f2rep() \n{\n    int i, j;\n    float rtn, ri, rj, dx, dy, dij, critlen;\n    struct vertex *vi, *vj;\n    rtn = 0;\n    for (i = 0; i < nv - 1; i++) {\n        for (j = i + 1; j < nv; j++) {\n            vi = *(vs + i);\n            vj = *(vs + j);\n            ri = vi->radius;\n            rj = vj->radius;\n            dx = vi->pos->x - vj->pos->x;\n            dy = vi->pos->y - vj->pos->y;\n            dij = sqrtf(dx * dx + dy * dy);\n            if (fabs(dij) <  MIN_DIST) {\n                dij = MIN_DIST;\n            } \n            critlen = ri + rj + PADDING;\n            if (critlen > dij) {\n                rtn += WR * powf(dij - critlen, 2);\n            }\n        }\n    }\n    return rtn;\n}\n\nstatic float f2() \n{\n    return f2attr() + f2rep();\n}\n\nstatic float f3(struct point *ps) \n{\n    int i, j, k; \n    float rtn, s, costheta, theta;\n    struct point pi, pj, pk;\n    struct vector2D vji, vjk;\n    rtn = 0; \n    for (i = 0; i < nv - 2; i++) {\n        for (j = i + 2; j < nv - 1; j++) {\n            for (k = j + 2; k < nv; k++) {\n                pi = *(ps + i);  \n                pj = *(ps + j);  \n                pk = *(ps + k);\n                vji = mk_vector(pi, pj);\n                vjk = mk_vector(pi, pk);\n                s = dot(vji, vjk);\n                costheta = s / (vji.len * vjk.len);\n                theta = fabs(acosf(costheta) - (M_PI / 2));\n                rtn += (1 / powf(theta, 2));\n            }\n        }\n    }\n    //TODO\n    /*return rtn;*/\n    return 0.0;\n}\n\nstatic float f4() \n{\n    // Edge crossings TODO\n    return 0.0;\n}\n\n\nfloat f(float arr[]) \n{\n    int i;\n    for (i = 0; i < nv * 2; i += 2) {\n        struct vertex *vptr = *(vs + i / 2);\n        vptr->pos->x = arr[i];\n        vptr->pos->y = arr[i + 1];\n    }\n    /*float rtn = f1(ps) + f2(ps) + f3(ps) + f4();*/\n    float rtn = f1() + f2();\n    return rtn;\n}\n\n\n","/*****************************************************************************\n\n* File Name: graph.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 07-07-2015\n\n*****************************************************************************/\n\n#include <stdlib.h>\n#include <math.h>\n\n#include \"graph.h\"\n\nstruct vertex *mk_vertex(int id, struct point *pos, float mass, float radius, \n        char type) \n{\n    struct vertex *rtn = malloc(sizeof(struct vertex));\n    rtn->id = id;\n    rtn->pos = pos;\n    rtn->mass = mass;\n    rtn->radius = radius;\n    rtn->type = type;\n    return rtn;\n}\n\nstruct bond mk_bond(struct vertex *fst, struct vertex *snd, float dist0, \n        float k)\n{\n    struct bond rtn;\n    rtn.fst = fst;\n    rtn.snd = snd;\n    rtn.dist0 = dist0;\n    rtn.k = k;\n    return rtn;\n}\n\n","/*****************************************************************************\n\n * Author : Ludvig Sundström\n\n * File Name : util.c\n\n * Purpose : \n\n * Creation Date : 26-06-2015\n\n * Last Modified : \n\n *****************************************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n\n#include \"math2D.h\"\n\nvoid rt_error(char error_text[])\n{\n    fprintf(stderr,\"Run-time error...\\n\");\n    fprintf(stderr,\"%s\\n\",error_text);\n    fprintf(stderr,\"...now exiting to system...\\n\");\n    exit(1);\n}\n\nfloat *vector(long n) \n{\n    float *v;\n    v = (float *) malloc((size_t) (n * sizeof(float)));\n    if (v == NULL) {\n        rt_error(\"error while allocating memory\");\n    }\n    return v;\n}\n\nstruct point *arrtop(float arr[], int n) \n{   \n    int i;\n    struct point *ps = malloc(sizeof(struct point) * n);\n    if (ps == NULL) {\n        rt_error(\"Error while allocating memory\");\n    }\n    for (i = 0; i < n * 2; i += 2) {\n        struct point p;\n        p.x = arr[i]; \n        p.y = arr[i + 1];\n        *(ps + (i / 2)) = p;\n    }\n    return ps;\n}\n\n","/***************************************************************************** \n * Author: Ludvig Sundström\n\n * File Name: minimizer.c\n\n * Description: Defines an energy function and its derivatives aswell as\n * working as minimize() which is the exported function by emscripten.\n\n * Creation Date: 24-06-2015\n\n *****************************************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n\n#include \"graph.h\"\n#include \"util.h\"\n#include \"frprmn.h\"\n#include \"constants.h\"\n#include \"objective.h\"\n#include \"gradient.h\"\n#include \"get_clustersizes.h\"\n\n#include \"minimizer.h\"\n\nint pox, poy;\nfloat *fdm;\n\nstatic void initDMT(const char *fname) \n{\n    FILE *fp;\n    char *pend, *p, *buf;\n    int i, j, ij;\n\n    const long rowMaxLen = (PRECISION_DIGITS + 3) * nv;\n\n    buf = malloc(sizeof(char) * rowMaxLen);\n    fp = fopen(fname, \"r\"); \n\n    if (buf == NULL) {\n        rt_error(\"error in getDMT while allocating memory\");\n    }\n    if (fp == NULL) {\n        printf(\"Error while opening file: %s for reading\", fname);\n        rt_error(\"Error...\");\n    }\n\n    for (i = 0; i < nv; i++) {\n        fgets(buf, rowMaxLen, fp);\n        p = buf;\n        for (j = 0; j < nv; j++) {\n            ij = j + (i * nv);\n            fdm[ij] = strtof(p, &pend);\n            if (fabs(fdm[ij]) < MIN_DIST) {\n                fdm[ij] = MIN_DIST;\n            }\n            p = pend + 1;\n        }\n    }\n\n    fclose(fp);\n    free(buf);\n}\n\nstatic void create_vertices(int customSizes) \n{\n    int i, n, vdim;\n    float gapx, gapy, offsetx, offsety;\n    n = nv; \n    while (fabs(sqrt(n) - (int) sqrt(n)) > 0.01) {\n        n++;\n    }\n    vdim = sqrt(n);\n    gapx = sx / vdim;\n    gapy = sy / vdim;\n    offsetx = gapx / 2;\n    offsety = gapy / 2;\n    int rows = 0;\n    int cols = -1;\n    float x, y;\n    struct vertex *vi;\n    struct point *pi;\n    for (i = 0; i < nv; i++) {\n        if (i % vdim == 0) {\n            rows++;\n            cols = 0;\n        }\n        x = cols * gapx + offsetx + pox;\n        y = rows * gapy + offsety + poy; \n        pi = mk_point(x, y);\n        vi = mk_vertex(i, pi, DEFAULT_RADIUS, DEFAULT_MASS, DEFAULT_TYPE);\n        *(vs + i) = vi;\n        cols++;\n    }\n}\n\nstatic void create_bonds() \n{\n    int i, j, ij;\n\n    struct vertex *vi, *vj;\n    struct bond bij;\n    float d0ij;\n    for (i = 0; i < nv - 1; i++) {\n        for (j = i + 1; j < nv; j++) {\n            vi = *(vs + i);\n            vj = *(vs + j);\n            ij = i * nv + j;\n            d0ij = fdm[ij];\n            if (d0ij > MIN_DIST && d0ij < DISTANCE_DELIMITER) {\n                bij = mk_bond(vi, vj, d0ij, DEFAULT_STIFFNESS);\n                *(bs + nb) = bij;\n                nb++;\n            }\n        }\n    }\n}\n\nstatic void set_positions(float *ps) {\n    int i;\n    for (i = 0; i < nv; i++) {\n        *(ps + i * 2) = (*(vs + i))->pos->x ; \n        *(ps + i * 2 + 1) = (*(vs + i))->pos->y ; \n    }\n}\n\nstatic void btonumarr(int *bsarr) {\n    int i;\n    *bsarr = nb;\n    for (i = 2; i < nb + 2; i++) {\n        *(bsarr + i * 2) = (bs + i)->fst->id;\n        *(bsarr + i * 2 + 1) = (bs + i)->snd->id;\n    }\n}\n\n\nint minimize (const char *dmtFilename, const char *ssFilename, float *flatpos,\n        int *bsarr, const int len, const int panelx, const int panely,\n        const int panelOffsetX, const int panelOffsetY, const float fact) {\n    int i, customSizes;\n    int *iter;\n    float *fret;\n\n    float (*func)(float []);\n    void (*dfunc)(float [], float []);\n\n    func = f;\n    dfunc = df;\n\n    customSizes = strcmp(ssFilename, \"noCustomSizes\") != 0;\n\n    pox = panelOffsetX;\n    poy = panelOffsetY;\n    sx = panelx * fact;\n    sy = panely * fact;\n    elen = SPRING_LENGTH * fact;\n\n    dim = len;\n    nv = len / 2;\n    nb = 0;\n\n    vs = malloc(sizeof(struct vertex) * nv);\n    bs = malloc(sizeof(struct bond) * nv * nv);\n    fdm = malloc(sizeof(float) * (nv * nv));\n\n    iter = malloc(sizeof(int));\n    fret = malloc(sizeof(float));\n\n    if (iter == NULL || fret == NULL || fdm == NULL) {\n        rt_error(\"Error in minimize when allocating memory\");\n    }\n    \n    initDMT(dmtFilename);\n\n    create_vertices(customSizes);    \n    create_bonds();\n    set_positions(flatpos); \n\n    frprmn(flatpos, dim, FTOL, iter, fret, func, dfunc);\n        \n    btonumarr(bsarr);\n\n    free(fret);\n    free(iter);\n    free(fdm);\n    for (i = 0; i < nv; i++) {\n        free((*(vs + i))->pos);\n        free(*(vs + i));\n    }\n    free(vs);\n    free(bs);\n\n    return 0;\n}\n\n","/*****************************************************************************\n\n * Author : Numerical recepies in C, modiefied by Ludvig Sundström\n\n * File Name : frprmn.c\n\n * Purpose : Performs Fletcher-Reeves-Polak-Ribiere minimization\n\n * Creation Date : 25-06-2015\n\n *****************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#include \"util.h\"\n#include \"linmin.h\"\n\n#define ITMAX 200\n#define EPS 1.0e-10\n#define FREEALL free(xi);free(h);free(g);\n\n/** \n * Given a starting point p, performs minimization on a function func using its\n * gradient calculated by dfunc. The convergence tolerance of func is ftol.\n * Returned quatities are p - the location of the minimum, iter - the number of\n * iterations performed and fret - the minimum value of value. \n * Calls routine linmin to perform line minimizations.\n */\nvoid frprmn(float p[], int n, float ftol, int *iter, float *fret, \n        float (*func)(), void (*dfunc)(float [], float []))\n{\n    int j, its;\n    float gg, gam, fp, dgg;\n    float *g, *h, *xi;\n\n    g = vector(n);\n    h = vector(n);\n    xi = vector(n);\n    fp = (*func)(p);\n    (*dfunc)(p, xi);\n    for (j = 0; j < n; j++) {\n        g[j] = -xi[j];\n        xi[j] = h[j] = g[j];\n    }\n    for (its = 0; its < ITMAX; its++) {\n        *iter = its;\n        linmin(p, xi, n, fret, func);\n        if (2.0 * fabs(*fret - fp) <= ftol * (fabs(*fret) + fabs(fp) + EPS)) {\n            FREEALL\n                return;\n        }\n        fp = (*func)(p);\n        (*dfunc)(p, xi);\n        dgg = gg = 0.0;\n        for (j = 0; j < n; j++) {\n            gg += g[j] * g[j];\n            dgg += (xi[j] + g[j]) * xi[j];\n        }\n        if (fabs(gg) < EPS) {\n            FREEALL\n                return;\n        }\n        gam = dgg / gg;\n        for (j = 0; j < n; j++) {\n            g[j] = -xi[j];\n            xi[j] = h[j] = g[j] + gam * h[j];\n        }\n    }\n    FREEALL\n    rt_error(\"Too many iterations in frprmn()\");\n}\n\n#undef ITMAX\n#undef EPS\n#undef FREEALL\n\n","/*****************************************************************************\n\n* File Name: math2D.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 06-07-2015\n\n*****************************************************************************/\n\n#include <stdlib.h>\n#include <math.h>\n#include \"math2D.h\"\n\nstruct point *mk_point(float x, float y) \n{\n    struct point *rtn = malloc(sizeof(struct point));\n    rtn->x = x;\n    rtn->y = y;\n    return rtn;\n}\n\nstruct vector2D mk_vector(struct point src, struct point tar)\n{\n    struct vector2D rtn;\n    rtn.src = src;\n    rtn.tar = tar;\n    rtn.x = src.x - tar.x;\n    rtn.y = src.y - tar.y;\n    rtn.len = sqrtf(rtn.x * rtn.x + rtn.y * rtn.y);\n    return rtn;\n}\n\nstruct point negate(struct point p) \n{\n    struct point rtn;\n    rtn.x = -p.x;\n    rtn.y = -p.y;\n    return rtn;\n}\n\nstruct point add(struct point p1, struct point p2) \n{\n    struct point rtn;\n    rtn.x = p1.x + p2.x;\n    rtn.y = p1.y + p2.y;\n    return rtn;\n}\n\nfloat dot(struct vector2D v1, struct vector2D v2)\n{   \n    return v1.x * v2.x + v1.y * v1.y;\n}\n\n","/*****************************************************************************\n\n * Author: Numerical recepies in C, modified by Ludvig Sundström\n\n * File Name: linmin.c\n\n * Description: Performs line minimization.\n\n * Creation Date: 25-06-2015\n\n *****************************************************************************/\n\n#include <stdlib.h>\n\n#define TOL 2.0e-4 \n\nint ncom; \nfloat *pcom, *xicom, (*nrfunc)(float []);   \n\n/*  Given an n-dimensional point p[1..n] and an n-dimensional direction\n    xi[1..n], moves and resets p to where the function func(p) takes on a\n    minimum along the direction xi from p, and replaces xi by the actual\n    vector displacement that p was moved. Also returns as fret the value\n    of func at the returned location p. This is actually all accomplished\n    by calling the routines mnbrak and brent.  \n    */   \nvoid linmin(float p[], float xi[], int n, float *fret, float (*func)())   \n{   \n    float brent(float ax, float bx, float cx,   \n            float (*f)(float), float tol, float *xmin);   \n    float f1dim(float x);   \n    void mnbrak(float *ax, float *bx, float *cx, float *fa, float *fb,   \n            float *fc, float (*func)(float));   \n    int i;   \n    float *vector();\n    float xx, xmin, fx, fb, fa, bx, ax;   \n    ncom = n; \n    pcom = vector(n);   \n    xicom = vector(n);   \n    nrfunc = func;   \n    for (i = 0; i < n; i++) {   \n        pcom[i] = p[i];   \n        xicom[i] = xi[i];   \n    }   \n    ax = 0.0; \n    xx = 1.0;   \n    mnbrak(&ax, &xx, &bx, &fa, &fx, &fb, f1dim);   \n    *fret = brent(ax, xx, bx, f1dim, TOL, &xmin);   \n    for (i=0; i<n; i++) { \n        xi[i] *= xmin;   \n        p[i] += xi[i];   \n    }   \n    free(xicom);\n    free(pcom);\n}   \n\nfloat f1dim(float x)   \n{   \n    float *vector();\n    int i;   \n    float f, *xt;   \n    xt = vector(ncom);   \n    for (i = 0; i <ncom; i++) {\n        xt[i] = pcom[i] + x * xicom[i];   \n    }\n    f = (*nrfunc)(xt);   \n    free(xt);\n    return f;   \n}  \n\n"]}