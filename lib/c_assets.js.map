{"version":3,"file":"lib/c_assets.js","sources":["lib/minimizer/bond.c","lib/minimizer/bond_cross.c","lib/minimizer/bond_pair.c","lib/minimizer/bond_set.c","lib/minimizer/energy.c","lib/minimizer/gradient.c","lib/minimizer/graph.c","lib/minimizer/grid.c","lib/minimizer/json.c","lib/minimizer/linmin.c","lib/minimizer/minimizer.c","lib/minimizer/pair.c","lib/minimizer/placement.c","lib/minimizer/process_input.c","lib/minimizer/util.c","lib/minimizer/vector.c","lib/minimizer/vertex.c","lib/minimizer/vertex_pair.c","lib/minimizer/vertex_set.c","lib/minimizer/zone.c","lib/minimizer/zone_pair.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;AAWA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAMA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;A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","sourcesContent":["/*****************************************************************************\n\n* File Name: Bond.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 28-07-2015\n\n*****************************************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n\n#include \"util.h\"\n#include \"constants.h\"\n#include \"bond.h\"\n\nBondPointer Bond_create(\n        const VertexPointer fst, \n        const VertexPointer snd, \n        const double dist0\n    )\n{\n    fst->mass++;\n    snd->mass++;\n\n    BondPointer rtn = malloc(sizeof(Bond));\n    rtn->fst = fst;\n    rtn->snd = snd;\n    rtn->dist0 = dist0;\n    return rtn;\n}\n\nstatic double Bond_attraction_weight(const BondPointer bp)\n{\n    return WATR;\n}\n\ndouble Bond_attraction_energy(const BondPointer bp)\n{\n    double d0, d;\n    d0 = bp->dist0 * SPRING_LENGTH;\n    d = Vector_norm(Vector_sub(bp->snd->pos, bp->fst->pos)); \n\n    double w;\n    w = Bond_attraction_weight(bp);\n    return w * pow(d - d0, 2);\n}\n\nVector Bond_attraction_gradient(const BondPointer bp)\n{\n    double d0;\n    d0 = bp->dist0 * SPRING_LENGTH;\n    Vector vecb;\n    vecb = Vector_sub(bp->snd->pos, bp->fst->pos);\n\n    double d;\n    d = Vector_norm(vecb); \n    if (fabs(d) <  MIN_DIST) {\n        d = MIN_DIST;\n    } \n    \n    double w;\n    w = Bond_attraction_weight(bp);\n\n    return Vector_scalar_mult(vecb, 2 * w * (1 - (d0 / d)));\n}\n\nvoid Bond_free(BondPointer bp)\n{\n    free(bp);\n}\n\n","/*****************************************************************************\n\n* File Name: bond_crossing.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 03-08-2015\n\n*****************************************************************************/\n#include <stdlib.h>\n#include <math.h>\n\n#include \"bond_cross.h\"\n#include \"util.h\"\n#include \"constants.h\"\n\nstatic double crossing_weight(const BondCrossPointer bcrs)\n{\n    return WCRS;\n}\n\n\nBondCross BondCross_initialize(const BondPair bpr, const Vector cross)\n{\n    BondCross rtn;\n\n    rtn.bpr = bpr;\n    rtn.cross = cross;\n    rtn.next = NULL;\n\n    BondPointer b0, b1;\n    b0 = bpr.fst; b1 = bpr.snd;\n\n    VertexPointer v0, v1, v2, v3;\n    v0 = b0->fst; v1 = b0->snd; \n    v2 = b1->fst; v3 = b1->snd;\n    \n    *(v0->crs_bof + v2->id) = 1;\n    *(v0->crs_bof + v3->id) = 1;\n\n    *(v1->crs_bof + v2->id) = 1;\n    *(v1->crs_bof + v3->id) = 1;\n\n    *(v2->crs_bof + v0->id) = 1;\n    *(v2->crs_bof + v1->id) = 1;\n\n    *(v3->crs_bof + v0->id) = 1;\n    *(v3->crs_bof + v1->id) = 1;\n\n    rtn.cross = cross;\n\n    return rtn;\n}\n\nBondCrossPointer BondCross_create(\n        const BondPair bcrs, \n        const Vector cross\n    )\n{\n    BondCrossPointer rtn = Util_allocate(1, sizeof(BondCross));\n    *rtn = BondCross_initialize(bcrs, cross);\n    return rtn;\n}\n\ndouble BondCross_crossing_energy(const BondCrossPointer bcrs)\n{\n    VertexPointer v0, v1, v2, v3;\n    v0 = bcrs->bpr.fst->fst; v1 = bcrs->bpr.snd->fst; \n    v2 = bcrs->bpr.snd->snd; v3 = bcrs->bpr.fst->snd;\n    \n    double d0, d1, d2, d3;\n    d0 = Vector_norm(Vector_sub(bcrs->cross, v0->pos));\n    d1 = Vector_norm(Vector_sub(bcrs->cross, v1->pos));\n    d2 = Vector_norm(Vector_sub(bcrs->cross, v2->pos));\n    d3 = Vector_norm(Vector_sub(bcrs->cross, v3->pos));\n\n    double dsums[4];\n    dsums[0] = d0 + d1;\n    dsums[1] = d0 + d2;\n    dsums[2] = d1 + d3;\n    dsums[3] = d2 + d3;\n\n    double mind, wi;\n    mind = Util_collection_min(dsums, 4);\n    wi = crossing_weight(bcrs);\n    \n    return wi  / (v0->mass + v1->mass + v2->mass + v3->mass) * pow(mind, 2);\n}\n\nVectorPointer BondCross_crossing_gradient(const BondCrossPointer bcrs)\n{\n\n    VertexPointer v0, v1, v2, v3;\n    v0 = bcrs->bpr.fst->fst; v1 = bcrs->bpr.snd->fst; \n    v2 = bcrs->bpr.snd->snd; v3 = bcrs->bpr.fst->snd;\n    \n    Vector vec0, vec1, vec2, vec3; \n    vec0 = Vector_sub(bcrs->cross, v0->pos);\n    vec1 = Vector_sub(bcrs->cross, v1->pos);\n    vec2 = Vector_sub(bcrs->cross, v2->pos);\n    vec3 = Vector_sub(bcrs->cross, v3->pos);\n\n    double d0, d1, d2, d3;\n    d0 = fmax(Vector_norm(vec0), MIN_DIST);\n    d1 = fmax(Vector_norm(vec1), MIN_DIST);\n    d2 = fmax(Vector_norm(vec2), MIN_DIST);\n    d3 = fmax(Vector_norm(vec3), MIN_DIST);\n\n    double dsums[4];\n    dsums[0] = d0 + d1;\n    dsums[1] = d0 + d2;\n    dsums[2] = d1 + d3;\n    dsums[3] = d2 + d3;\n    \n    int i, min, minind;\n    min = dsums[0];\n    minind = 0;\n    for (i = 1; i < 4; i++) {\n        if (dsums[i] < min) {\n            min = dsums[i];\n            minind = i;\n        }\n    }\n    \n    double v0_gradx, v0_grady, \n          v1_gradx, v1_grady, \n          v2_gradx, v2_grady, \n          v3_gradx, v3_grady;\n    switch (minind) {\n        case 0:\n            v0_gradx = 2 * vec0.x * dsums[0] / d0;\n            v0_grady = 2 * vec0.y * dsums[0] / d0;\n            v1_gradx = 2 * vec1.x * dsums[0] / d1; \n            v1_grady = 2 * vec1.y * dsums[0] / d1; \n            v2_gradx = 0; \n            v2_grady = 0; \n            v3_gradx = 0; \n            v3_grady = 0; \n            break;\n        case 1:\n            v0_gradx = 2 * vec0.x * dsums[1] / d0;\n            v0_grady = 2 * vec0.y * dsums[1] / d0;\n            v1_gradx = 0; \n            v1_grady = 0; \n            v2_gradx = 2 * vec2.x * dsums[1] / d2; \n            v2_grady = 2 * vec2.y * dsums[1] / d2; \n            v3_gradx = 0; \n            v3_grady = 0; \n            break;\n        case 2:\n            v0_gradx = 0;\n            v0_grady = 0;\n            v1_gradx = 2 * vec1.x * dsums[2] / d1; \n            v1_grady = 2 * vec1.y * dsums[2] / d1; \n            v2_gradx = 0; \n            v2_grady = 0; \n            v3_gradx = 2 * vec3.x * dsums[2] / d3; \n            v3_grady = 2 * vec3.y * dsums[2] / d3; \n            break;\n        case 3:\n            v0_gradx = 0;\n            v0_grady = 0;\n            v1_gradx = 0; \n            v1_grady = 0; \n            v2_gradx = 2 * vec2.x * dsums[3] / d2; \n            v2_grady = 2 * vec2.y * dsums[3] / d2; \n            v3_gradx = 2 * vec3.x * dsums[3] / d3; \n            v3_grady = 2 * vec3.y * dsums[3] / d3; \n            break;\n    }\n\n    double wi;\n    wi = crossing_weight(bcrs);\n    \n    VectorPointer rtn = Util_allocate(4, sizeof(Vector));\n\n    Vector v0_grad, v1_grad, v2_grad, v3_grad;\n    v0_grad = Vector_initialize(v0_gradx, v0_grady);\n    v1_grad = Vector_initialize(v1_gradx, v1_grady);\n    v2_grad = Vector_initialize(v2_gradx, v2_grady);\n    v3_grad = Vector_initialize(v3_gradx, v3_grady);\n\n    rtn[0] = Vector_scalar_mult(v0_grad, wi / v0->mass);\n    rtn[1] = Vector_scalar_mult(v1_grad, wi / v1->mass);\n    rtn[2] = Vector_scalar_mult(v2_grad, wi / v2->mass);\n    rtn[3] = Vector_scalar_mult(v3_grad, wi / v3->mass);\n\n    return rtn;\n}\n\n\nvoid BondCrosses_free(BondCrossPointer bcrss)\n{\n    BondCrossPointer bcrs = bcrss;\n    while(bcrs != NULL) {\n\n        BondPointer b0, b1;\n        b0 = bcrs->bpr.fst; b1 = bcrs->bpr.snd;\n\n        VertexPointer v0, v1, v2, v3;\n        v0 = b0->fst; v1 = b0->snd; \n        v2 = b1->fst; v3 = b1->snd;\n        \n        *(v0->crs_bof + v2->id) = 0;\n        *(v0->crs_bof + v3->id) = 0;\n\n        *(v1->crs_bof + v2->id) = 0;\n        *(v1->crs_bof + v3->id) = 0;\n\n        *(v2->crs_bof + v0->id) = 0;\n        *(v2->crs_bof + v1->id) = 0;\n\n        *(v3->crs_bof + v0->id) = 0;\n        *(v3->crs_bof + v1->id) = 0;\n\n        BondCrossPointer tmp = bcrs;\n        bcrs = bcrs->next;\n        free(tmp);\n        tmp = NULL;\n    }\n}\n\n","/*****************************************************************************\n\n* File Name: bondPair.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 30-07-2015\n\n*****************************************************************************/\n\n#include <stdlib.h>\n#include <math.h>\n\n#include \"util.h\"\n#include \"constants.h\"\n#include \"bond_pair.h\"\n#include \"bond_set.h\"\n\n/* Private ******************************************************************/\n\nstatic double angular_weight(const BondPairPointer bpr)\n{\n   return WANG / (bpr->other1->mass * bpr->other2->mass);\n}\n\n/* Public *******************************************************************/\n\nBondPair BondPair_initialize(Pair pr)\n{\n    BondPair rtn;\n    rtn.fst = (BondPointer) pr.fst;\n    rtn.snd = (BondPointer) pr.snd;\n    rtn.next = NULL;\n\n    VertexPointer v0, v1, v2, v3;\n    v0 = rtn.fst->fst;\n    v1 = rtn.fst->snd;\n    v2 = rtn.snd->fst;\n    v3 = rtn.snd->snd;\n\n    if (v0->id == v2->id) {\n        rtn.common = v0;\n        rtn.other1 = v1;\n        rtn.other2 = v3;\n    } else if (v0->id == v3->id) {\n        rtn.common = v0;\n        rtn.other1 = v1;\n        rtn.other2 = v2;\n    } else if (v1->id == v2->id) {\n        rtn.common = v1;\n        rtn.other1 = v0;\n        rtn.other2 = v3;\n    } else {\n        rtn.common = v1;\n        rtn.other1 = v0;\n        rtn.other2 = v2;\n    }\n    return rtn;\n}\n\nBondPairPointer BondPair_create(Pair pr)\n{\n    BondPairPointer rtn = calloc(1, sizeof(BondPair));\n    *rtn = BondPair_initialize(pr);\n\n    return rtn;\n}\n\n/**\n * Returns 1 if the lines intersect, otherwise 0. In Vector_addition, if the\n * lines intersect the intersection point may be stored in the const doubles i_x\n * and i_y.  \n * Credit: http://stackoverflow.com/users/78216/gavin\n */\nint BondPair_intersect(const BondPair bpr, VectorPointer v) \n{\n    assert(v);\n\n    BondPointer b0, b1;\n    b0 = bpr.fst; b1 = bpr.snd;\n\n    VertexPointer v0, v1, v2, v3;\n    v0 = b0->fst; v1 = b0->snd; \n    v2 = b1->fst; v3 = b1->snd;\n\n    double p0_x, p0_y, p1_x, p1_y, p2_x, p2_y, p3_x, p3_y;\n    p0_x = v0->pos.x; p0_y = v0->pos.y;\n    p1_x = v1->pos.x; p1_y = v1->pos.y;\n    p2_x = v2->pos.x; p2_y = v2->pos.y;\n    p3_x = v3->pos.x; p3_y = v3->pos.y;\n\n    double s1_x, s1_y, s2_x, s2_y;\n    s1_x = p1_x - p0_x;     \n    s1_y = p1_y - p0_y;\n    s2_x = p3_x - p2_x;     \n    s2_y = p3_y - p2_y;\n\n    double s, t;\n    s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / \n        (-s2_x * s1_y + s1_x * s2_y);\n    t = ( s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / \n        (-s2_x * s1_y + s1_x * s2_y);\n\n    if (s >= MIN_DIST && s <= 1 - MIN_DIST && \n        t >= MIN_DIST && t <= 1 - MIN_DIST)\n    {\n        double i_x, i_y;\n        i_x = p0_x + (t * s1_x);\n        i_y = p0_y + (t * s1_y);\n        *v = Vector_initialize(i_x, i_y);\n        return 1;\n    }\n    return 0; \n}\n\ndouble BondPair_angular_energy(const BondPairPointer bpr)\n{\n    VertexPointer vi, vj, vk;\n    vi = bpr->other1; \n    vj = bpr->common;\n    vk = bpr->other2; \n\n    double xji, yji, xjk, yjk;\n    xji = vi->pos.x - vj->pos.x; yji = vi->pos.y - vj->pos.y;\n    xjk = vk->pos.x - vj->pos.x; yjk = vk->pos.y - vj->pos.y;\n\n    Vector vecji, vecjk;\n    vecji = Vector_initialize(xji, yji);\n    vecjk = Vector_initialize(xjk, yjk);\n    \n    double theta; \n    theta = Vector_angle(vecji, vecjk);\n    \n    double wij, theta0;\n    wij = angular_weight(bpr);\n    theta0 = (2 * M_PI) / (vj->mass - 1);\n\n    return wij * pow(theta - theta0, 2);\n}\n\nPair BondPair_angular_gradient(const BondPairPointer bpr)\n{\n    VertexPointer vi, vj, vk;\n    vi = bpr->other1; \n    vj = bpr->common;\n    vk = bpr->other2; \n    \n    double xji, yji, xjk, yjk; \n    xji = vi->pos.x - vj->pos.x;\n    yji = vi->pos.y - vj->pos.y;\n    xjk = vk->pos.x - vj->pos.x;\n    yjk = vk->pos.y - vj->pos.y;\n\n    if (Util_about(xji, xjk)) {\n        xji += MIN_DIST;\n        xjk -= MIN_DIST;\n    }\n    if (Util_about(yji, yjk)) {\n        yji += MIN_DIST;\n        yjk -= MIN_DIST;\n    }\n\n    Vector vecji, vecjk;\n    vecji = Vector_initialize(xji, yji);\n    vecjk = Vector_initialize(xjk, yjk);\n    \n    double theta0;\n    theta0 = (2 * M_PI) / (vj->mass - 1);\n    \n    double a1, a2; \n    a1 = (xjk * yji - yjk * xji);\n    a2 = (yjk * xji - xjk * yji);\n    \n    double b;\n    b = theta0 - Vector_angle(vecji, vecjk);\n    \n    double c1, c2;\n    c1 = vecjk.len * pow((pow(xji, 2) + pow(yji, 2)), (3/2));\n    c2 = vecji.len * pow((pow(xjk, 2) + pow(yjk, 2)), (3/2));\n    \n    double dn, dd, dsq, d;\n    dn = pow(a2, 2);\n    dd = (pow(xji, 2) + pow(yji, 2)) * (pow(xjk, 2) + pow(yjk, 2));\n    if (dd < MIN_DIST) {\n        dd = MIN_DIST;\n    }\n    dsq = dn / dd;\n    if (dsq < 0) {\n        Util_runtime_error(\"Negative square root argument\");\n    }\n    d = sqrt(dn / dd);\n\n    double aver[4];\n    aver[0] = 2 * yji * a1;\n    aver[1] = 2 * xji * a2;\n    aver[2] = 2 * yjk * a2;\n    aver[3] = 2 * xjk * a1;\n    \n    double c1d, c2d;\n    c1d = fmax(c1 * d, MIN_DIST); \n    c2d = fmax(c2 * d, MIN_DIST);\n\n    double dxji, dyji, dxjk, dyjk;\n    dxji = -(aver[0] * b) / c1d;\n    dyji = -(aver[1] * b) / c1d;\n    dxjk = -(aver[2] * b) / c2d;\n    dyjk = -(aver[3] * b) / c2d;\n\n    double wji, wjk;\n\n    wji = angular_weight(bpr);\n    wjk = angular_weight(bpr);\n\n    VectorPointer frcji, frcjk;\n    \n    frcji = Vector_create(dxji, dyji);\n    frcjk = Vector_create(dxjk, dyjk);\n\n    *frcji = Vector_scalar_mult(*frcji, wji);  \n    *frcjk = Vector_scalar_mult(*frcjk, wjk);  \n    \n    return Pair_initialize(frcji, frcjk);\n}\n\nint has_common_vertex(BondPair bpr) \n{\n    BondPointer bp1, bp2;\n    bp1 = bpr.fst; bp2 = bpr.snd;\n    return  bp1->fst->id == bp2->fst->id ||\n            bp1->fst->id == bp2->snd->id || \n            bp1->snd->id == bp2->fst->id ||\n            bp1->snd->id == bp2->snd->id;\n}\n\nvoid BondPairs_free(BondPairPointer bprs)\n{\n    BondPairPointer bpr = bprs;\n    while(bpr != NULL) {\n        BondPairPointer tmp = bpr;\n        bpr = bpr->next;\n        free(tmp);\n        tmp = NULL;\n    }\n}\n\n","/*****************************************************************************\n\n* File Name: Bond_set.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 31-07-2015\n\n*****************************************************************************/\n\n#include \"util.h\"\n#include \"vertex_set.h\"\n#include \"bond_set.h\"\n\nBondSet BondSet_initialize(VertexPointer *vs, json_value *contents, int *nbp)\n{\n    int i, fstid, sndid;\n    double len;\n    VertexPointer fst, snd;\n\n    json_value *bsarr = contents->u.object.values[1].value;\n    *nbp = bsarr->u.array.length;\n    int nb;\n    nb = *nbp;\n\n    BondSet rtn;\n    rtn.set = (BondPointer *) Util_allocate(nb, sizeof(BondPointer));\n    rtn.n = nb;\n\n    for (i = 0; i < nb; i++) {\n        \n        json_value *Bond = bsarr->u.array.values[i];\n        \n        json_value *first = Bond->u.object.values[0].value;\n        json_value *second = Bond->u.object.values[1].value;\n        json_value *length = Bond->u.object.values[2].value;\n\n        if (first->type == json_integer && second->type == json_integer) {\n            fstid = first->u.integer;\n            sndid = second->u.integer;\n        } else {\n            Util_runtime_error(\"Bad JSON data\");\n        }\n\n        if (length->type == json_integer) {\n            len = (double) length->u.integer;\n        } else if (length->type == json_double) {\n            len = (double) length->u.dbl;\n        } else {\n            Util_runtime_error(\"Bad JSON data\\n\");\n        }\n\n        fst = *(vs + fstid);\n        snd = *(vs + sndid);\n\n        BondPointer bp;\n        bp = Bond_create(fst, snd, len);\n        *(rtn.set + i) = bp;\n    }\n\n    return rtn;\n}\n\nBondPointer BondSet_get_bond(const BondSet bs, const int i) \n{\n    return *(bs.set + i);  \n}\n\nBondSetPointer BondSet_create(\n        VertexPointer *vs, \n        json_value *contents, \n        int *nbp\n    )\n{\n    BondSetPointer rtn;\n    rtn = (BondSetPointer) malloc(sizeof(BondSet));\n    *rtn = BondSet_initialize(vs, contents, nbp);\n    return rtn;\n}\n\nint *Bondset_to_array(BondSet bs)\n{\n    int *rtn = (int *) Util_allocate(bs.n * 2, sizeof(int));\n    int i;\n    for (i = 0; i < bs.n; i++) {\n        *(rtn + i * 2) = (*(bs.set + i))->fst->id;\n        *(rtn + i * 2 + 1) = (*(bs.set + i))->snd->id;\n    }\n    return rtn;\n}\n\nvoid BondSet_free(BondSet bs) \n{\n    int i;\n    for (i = 0; i < bs.n; i++) {\n        Bond_free(*(bs.set + i));\n    }\n    free(bs.set);\n}\n\n","/*****************************************************************************\n\n* File Name: objective.c \n* Author: Ludvp0g Sundström\n\n* Description: The objective function F = F1 + F2 + F3 + F4 where FN considers\n* N vertices. \n\n* Creation Date: 05-07-2015\n\n*****************************************************************************/\n\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"constants.h\"\n#include \"graph.h\"\n#include \"util.h\"\n\n/* Private ******************************************************************/\n\nstatic double first_order(const VertexSet vs) {\n\n    double rtn;\n    rtn = 0;\n    int i;\n    for (i = 0; i < vs.n; i++) {\n        VertexPointer v = *(vs.set + i);\n        rtn += Vertex_potential_energy(v);\n    }\n    return rtn;\n}\n\nstatic double second_order_attraction(const BondSet bs) \n{\n    double rtn;\n    rtn = 0; \n\n    int i;\n    for (i = 0; i < bs.n; i++) {\n        BondPointer bp;\n        bp = *(bs.set + i);\n        rtn += Bond_attraction_energy(bp);\n    }\n\n    return rtn;\n}\n\nstatic double second_order_repulsion(const GridPointer grid) \n{\n    double rtn;\n    rtn = 0.0;\n    \n    int i;\n    for (i = 0; i < grid->npz; i++) {\n        ZonePointer zp = *(grid->pzps + i);\n        VertexPointer vp0 = zp->members;\n        while (vp0->next) {\n            VertexPointer vp1;\n            vp1 = vp0->next; \n            while (vp1) {\n                Pair pr;\n                if (vp0->id > vp1->id) {\n                    pr = Pair_initialize(vp1, vp0);\n                } else {\n                    pr = Pair_initialize(vp1, vp0);\n                }\n                rtn += VertexPair_repulsion_energy(pr);\n                vp1 = vp1->next;\n            }\n            vp0 = vp0->next;\n        }\n    }\n    ZonePairPointer z2p = grid->azps;\n    while (z2p) {\n        VertexPointer vp0;\n        vp0 = z2p->fst->members;\n        while (vp0) {\n            VertexPointer vp1;\n            vp1 = z2p->snd->members;\n            while (vp1) {\n                Pair pr;\n                if (vp0->id > vp1->id) {\n                    pr = Pair_initialize(vp1, vp0);\n                } else {\n                    pr = Pair_initialize(vp0, vp1);\n                }\n                rtn += VertexPair_repulsion_energy(pr);\n                vp1 = vp1->next;          \n            }\n            vp0 = vp0->next;\n        }\n        z2p = z2p->next;\n    }\n    return rtn;\n}\n\nstatic double second_order(const GraphPointer graph)\n{\n    double e2a, e2r;\n    e2a = second_order_attraction(graph->bs);\n    e2r = second_order_repulsion(graph->grid);\n\n    return e2a + e2r; \n}\n\nstatic double third_order(const BondPairPointer con)\n{\n    double rtn;\n    rtn = 0; \n\n    BondPairPointer bpr;\n    bpr = con;\n\n    while (bpr) {\n        rtn += BondPair_angular_energy(bpr);\n        bpr = bpr->next;\n    }\n\n    return rtn;\n}\n\nstatic double fourth_order(const BondCrossPointer crs)\n{\n    double rtn;\n    rtn = 0;\n\n    BondCrossPointer bcrs;\n    bcrs = crs;\n    while (bcrs) {\n        rtn += BondCross_crossing_energy(bcrs);\n        bcrs = bcrs->next;\n    }\n    return rtn;\n}\n\n/* Public *******************************************************************/\n\ndouble Energy_calculate(const GraphPointer graph) \n{\n    double e1, e2, e3, e4;\n    e1 = first_order(graph->vs);\n    e2 = second_order(graph);\n    e3 = third_order(graph->con);\n    e4 = fourth_order(graph->crs);\n\n    return e1 + e2 + e3 + e4;\n}\n\n/* Testing facade ***********************************************************/\n\ndouble (*test_first_order_energy)(const VertexSet vs) = first_order;\ndouble (*test_second_order_energy)(const GraphPointer graph) = second_order;\ndouble (*test_second_order_attraction_energy)(const BondSet bs) = \n        second_order_attraction;\ndouble (*test_second_order_repulsion_energy)(const GridPointer grid) = \n        second_order_repulsion;\ndouble (*test_third_order_energy)(const BondPairPointer con) = third_order;\ndouble (*test_fourth_order_energy)(const BondCrossPointer crs) = fourth_order;\n\n","/***************************************************************************** \n \n* File Name: gradient.c\n\n* Author: Ludvig Sundström\n\n* Description: The gradient of the objective function.\n\n* Creation Date: 06-07-2015\n\n*****************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#include \"pair.h\"\n#include \"util.h\"\n#include \"constants.h\"\n#include \"graph.h\"\n#include \"vertex_set.h\"\n\n/* Private ******************************************************************/\n\nstatic void apply_repulsion(\n        const VertexPointer vi, \n        const VertexPointer vj,\n        const VectorPointer gradient\n    ) \n{\n    Vector rpls_grad;\n    Pair pr = Pair_initialize(vi, vj);\n    rpls_grad = VertexPair_repulsion_gradient(pr);\n\n    gradient[vi->id] = Vector_add(gradient[vi->id], rpls_grad);\n    gradient[vj->id] = Vector_add(gradient[vj->id], Vector_negate(rpls_grad));\n}\n\nstatic void first_order(const VertexSet vs, const VectorPointer gradient)\n{\n    int i;\n    for (i = 0; i < vs.n; i++) {\n        VertexPointer v;\n        v = *(vs.set + i);\n        gradient[i] = Vector_add(gradient[i], Vertex_potential_gradient(v));\n    }\n}\n\nstatic void second_order_repulsion(\n        const GridPointer grid, \n        const VectorPointer gradient\n    )\n{\n    int i;\n    for (i = 0; i < grid->npz; i++) {\n        ZonePointer z = *(grid->pzps + i);\n        VertexPointer vi = z->members;\n        while (vi->next) {\n            VertexPointer vj;\n            vj = vi->next; \n            while (vj) {\n                if (vi->id > vj->id) {\n                    apply_repulsion(vj, vi, gradient);\n                } else {\n                    apply_repulsion(vi, vj, gradient);\n                }\n                vj = vj->next;\n            }\n            vi = vi->next;\n        }\n    }\n    ZonePairPointer z2p = grid->azps;\n    while (z2p) {\n        VertexPointer vi;\n        vi = z2p->fst->members;\n        while (vi) {\n            VertexPointer vj;\n            vj = z2p->snd->members;\n            while (vj) {\n                if (vi->id > vj->id) {\n                    apply_repulsion(vj, vi, gradient);\n                } else {\n                    apply_repulsion(vi, vj, gradient);\n                }\n                vj = vj->next;          \n            }\n            vi = vi->next;\n        }\n        z2p = z2p->next;\n    }\n}\n\nstatic void second_order_attraction(\n        const BondSet bs, \n        const VectorPointer gradient\n    )\n{\n    int i;\n    for (i = 0; i < bs.n; i++) {\n        BondPointer b;\n        b = *(bs.set + i);\n        Vector grad, neg_grad;\n        grad = Bond_attraction_gradient(b);\n        neg_grad = Vector_negate(grad);\n        gradient[b->fst->id] = Vector_add(gradient[b->fst->id], grad);\n        gradient[b->snd->id] = Vector_add(gradient[b->snd->id], neg_grad);\n    }\n}\n\nstatic void second_order(\n        const GraphPointer graph, \n        const VectorPointer gradient\n    )\n{\n    second_order_repulsion(graph->grid, gradient);\n    second_order_attraction(graph->bs, gradient);\n}\n\nstatic void third_order(\n        const BondPairPointer con, \n        const VectorPointer gradient\n    )\n{\n    BondPairPointer bpr = con;\n    while (bpr) {\n        \n        Pair pr = BondPair_angular_gradient(bpr);\n        VertexPointer vi, vk;\n        vi = bpr->other1; \n        vk = bpr->other2; \n        Vector gradi, gradk;\n        gradi = *((VectorPointer) pr.fst);\n        gradk = *((VectorPointer) pr.snd);\n        gradient[vi->id] = Vector_add(gradient[vi->id], gradi);\n        gradient[vk->id] = Vector_add(gradient[vk->id], gradk);\n        \n        free(pr.fst);\n        free(pr.snd);\n\n        bpr = bpr->next;\n    }\n}\n\nstatic void fourth_order(\n        const BondCrossPointer crs, \n        const VectorPointer gradient\n    )\n{\n    BondCrossPointer bcrs;\n    bcrs = crs;\n    while (bcrs) {\n\n        VectorPointer grad = BondCross_crossing_gradient(bcrs);\n\n        VertexPointer v0, v1, v2, v3;\n        v0 = bcrs->bpr.fst->fst; v1 = bcrs->bpr.snd->fst; \n        v2 = bcrs->bpr.snd->snd; v3 = bcrs->bpr.fst->snd;\n\n        gradient[v0->id] = Vector_add(gradient[v0->id], grad[0]);\n        gradient[v1->id] = Vector_add(gradient[v1->id], grad[1]);\n        gradient[v2->id] = Vector_add(gradient[v2->id], grad[2]);\n        gradient[v3->id] = Vector_add(gradient[v3->id], grad[3]);\n        \n        free(grad); \n                \n        bcrs = bcrs->next;\n    }\n}\n\n/* Public *******************************************************************/\n\nvoid Gradient_calculate(const GraphPointer graph, const VectorPointer gradient)\n{\n    first_order(graph->vs, gradient);\n    second_order(graph, gradient);\n    third_order(graph->con, gradient);\n    fourth_order(graph->crs, gradient);\n}\n\n/* Test facade *************************************************************/\n\nvoid (*test_first_order_gradient)(\n        const VertexSet vs, \n        const VectorPointer gradient\n    ) = first_order;\nvoid (*test_second_order_gradient)(\n        const GraphPointer graph, \n        const VectorPointer gradient) = second_order;\nvoid (*test_second_order_attraction_gradient)(\n        const BondSet bs, \n        const VectorPointer gradient\n    ) = second_order_attraction;\nvoid (*test_second_order_repulsion_gradient)(\n        const GridPointer grid, \n        const VectorPointer gradient\n    ) = second_order_repulsion;\nvoid (*test_third_order_gradient)(\n        const BondPairPointer con, \n        const VectorPointer gradient\n    ) = third_order;\nvoid (*test_fourth_order_gradient)(\n        const BondCrossPointer crs, \n        const VectorPointer gradient\n    ) = fourth_order;\n\n","/*****************************************************************************\n\n* File Name: graph.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 07-07-2015\n\n*****************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n\n#include \"constants.h\"\n#include \"graph.h\"\n#include \"placement.h\"\n\n#include \"process_input.h\"\n\n/* Private ******************************************************************/\n\nGraphPointer create(VertexSet vs, BondSet bs) \n{\n    assert(vs.set && bs.set);\n    assert(vs.n > 0);\n\n    GraphPointer rtn; \n    rtn = (GraphPointer) calloc(1, sizeof(Graph));\n    \n    rtn->grid = Grid_create(); \n    rtn->con = NULL; rtn->crs = NULL;\n\n    rtn->vs = vs; rtn->bs = bs;\n\n    Graph_detect_connected(rtn);\n    \n    assert(rtn); \n    return rtn;\n}\n\n/** \n * Given a vertex in a graph, assign it a zone.\n */\n\nstatic void assign_vertex_to_zone(\n        const GridPointer grid, \n        const VertexPointer v\n    )\n{\n    assert(grid && v);\n    assert(grid->nz > 0 && grid->is_populated);\n    assert(grid->zps && grid->pzps);\n    \n    int i, j; \n    i = Vertex_zone_idx(v);\n    j = Vertex_zone_idy(v);\n\n    Grid_append_member(grid, v, Grid_get_zone(grid, i, j));\n}\n\nstatic void link_bondpair(const GraphPointer graph, const Pair pr) \n{\n    BondPairPointer newpr;\n    newpr = BondPair_create(pr);\n    newpr->next = graph->con;\n    graph->con = newpr;\n}\n\nstatic void link_bondcross(\n        const GraphPointer graph, \n        const BondPair bpr, \n        const Vector cross\n    )\n{\n    BondCrossPointer bcrs;\n    bcrs = BondCross_create(bpr, cross);\n    bcrs->next = graph->crs;\n    graph->crs = bcrs;\n} \n\n/* Public ******************************************************************/\n\nGraphPointer Graph_create(const char *fname) \n{\n    int nv, nb;\n    Pair pr;\n    pr = process_json(fname, &nv, &nb);\n    \n    assert(nb < (double) nv * log((double) nv));\n    assert(pr.fst && pr.snd);\n\n    VertexSetPointer vs;\n    vs = (VertexSetPointer) pr.fst; \n\n    BondSetPointer bs;\n    bs = (BondSetPointer) pr.snd; \n\n    GraphPointer rtn;\n    rtn = create(*vs, *bs);\n\n    free(vs);\n    free(bs);\n\n    Placement_set_spiral(rtn->vs, nv); \n    Graph_reset_dynamics(rtn);\n    \n    assert(rtn->max_vw >= 0 && rtn->max_vh >= 0);\n    assert(rtn->grid && rtn->vs.set && rtn->bs.set);\n    assert(rtn->vs.n > 0 && rtn->vs.n <= MAX_NV);\n    assert(rtn->bs.n >= 0);\n\n    return rtn;\n}\n\nvoid Graph_reset_dynamics(const GraphPointer graph)\n{\n    assert(graph && graph->grid && graph->vs.n > 0 && graph->vs.set);\n\n    Grid_reset_dynamics(graph->grid);\n\n    if (graph->crs) BondCrosses_free(graph->crs);\n    graph->crs = NULL;\n\n    int i;\n    for (i = 0; i < graph->vs.n; i++) {\n        VertexPointer v = *(graph->vs.set + i);\n        Vertex_reset_dynamics(v);\n        assign_vertex_to_zone(graph->grid, v);\n    }\n\n    Grid_check_adjacent(graph->grid);\n    Graph_detect_crosses(graph);\n}\n\nvoid Graph_detect_crosses(const GraphPointer graph)\n{\n    assert(graph && graph->bs.set && graph->bs.n >= 0);\n    assert(!graph->crs);\n\n    BondSet bs;\n    bs = graph->bs;\n\n    int i;\n    for (i = 0; i < bs.n - 1; i++) {\n        int j;\n        for (j = i + 1; j < bs.n; j++) {\n            BondPointer fst, snd;\n            fst = BondSet_get_bond(bs, i);\n            snd = BondSet_get_bond(bs, j);\n\n            BondPair bpr;\n            bpr = BondPair_initialize(Pair_initialize(fst, snd));\n\n            int crossing;\n            Vector cross;\n            crossing = BondPair_intersect(bpr, &cross);\n            if (crossing) {\n                link_bondcross(graph, bpr, cross);\n            } \n        }\n    }\n}\n\nvoid Graph_detect_connected(const GraphPointer graph)\n{\n    assert(!graph->con);\n    int i;\n    for (i = 0; i < graph->bs.n - 1; i++) {\n        int j;\n        for (j = i + 1; j < graph->bs.n; j++) {\n            BondPointer fst, snd;\n            fst = BondSet_get_bond(graph->bs, i);\n            snd = BondSet_get_bond(graph->bs, j);\n            Pair pr = Pair_initialize(fst, snd);\n            int common;\n            common = has_common_vertex(BondPair_initialize(pr));\n            if (common) {\n                link_bondpair(graph, Pair_initialize(fst, snd));\n            }\n        }\n    }\n}\n\nvoid Graph_free(const GraphPointer graph)\n{\n    if (graph->con) BondPairs_free(graph->con);\n    if (graph->crs) BondCrosses_free(graph->crs);\n    VertexSet_free(graph->vs);\n    BondSet_free(graph->bs);\n    Grid_free(graph->grid);\n    free(graph->grid);\n    free(graph);\n}\n\n","/*****************************************************************************\n\n* File Name: grid.c\n\n* Author: Ludvig Sundström\n\n* Description: A collection of adjacent zones \n\n* Creation Date: 31-07-2015\n\n*****************************************************************************/\n\n#include <stdlib.h>\n\n#include \"util.h\"\n#include \"pair.h\"\n#include \"constants.h\"\n#include \"grid.h\"\n\n/* Private ******************************************************************/\n\n/* Public *******************************************************************/\n\nGridPointer Grid_create()\n{\n    GridPointer rtn;\n    rtn = (GridPointer) malloc(sizeof(Grid));\n\n    rtn->nz = 0;\n    rtn->zps = (ZonePointer *) malloc(sizeof(Zone) * GRID_DIM_X * GRID_DIM_Y);\n    int i, j, id;\n    for (j = 0; j < GRID_DIM_Y; j++) {\n        for (i = 0; i < GRID_DIM_X; i++) {\n            id = (j * GRID_DIM_Y) + i;\n            ZonePointer z;\n            z= Zone_create(id, i, j, \n                    (double) i * PADDING, (double) j * PADDING, \n                    (double) PADDING, (double) PADDING);\n            *(rtn->zps + id) = z;\n            rtn->nz++;\n        }\n    }\n    rtn->is_populated = (int *) malloc(sizeof(int) * rtn->nz);\n    rtn->pzps = (ZonePointer *) malloc(sizeof(void *) * rtn->nz);\n    rtn->azps = NULL;\n    rtn->npz = 0;\n    \n    return rtn;\n}\n\nZonePointer Grid_get_zone(const GridPointer grid, const int x, const int y)\n{\n    assert(x < GRID_DIM_X && x >= 0);\n    assert(y < GRID_DIM_Y && y >= 0);\n\n    return *(grid->zps + (y * GRID_DIM_X) + x);\n}\n\nvoid Grid_append_member(\n        const GridPointer grid, \n        const VertexPointer v, \n        const ZonePointer z\n    )\n{\n    v->next = z->members;\n    z->members = v;\n    if (!*(grid->is_populated + z->id)) {\n        *(grid->pzps + grid->npz) = z;\n        grid->npz++;\n    }\n    *(grid->is_populated + z->id) = 1;\n}\n\nvoid Grid_check_adjacent(const GridPointer grid) \n{\n    int i, j;\n    for (i = 0; i < grid->npz - 1; i++) {\n        for (j = i + 1; j < grid->npz; j++) {\n            ZonePointer zi = *(grid->pzps + i);\n            ZonePointer zj = *(grid->pzps + j);\n            int diff;\n            diff = zi->id - zj->id;\n            \n           int adj; \n            adj = \n                diff == 1 || \n                diff == -1 || \n                diff == GRID_DIM_X || \n                diff == -GRID_DIM_X ||\n                diff == GRID_DIM_X - 1 ||\n                diff == GRID_DIM_X + 1 ||\n                diff == -GRID_DIM_X - 1 ||\n                diff == -GRID_DIM_X + 1;\n            if (adj) {\n                Pair pr = Pair_initialize(zi, zj);\n                ZonePairPointer newz2p = ZonePair_create(pr, grid->azps);\n                grid->azps = newz2p;\n            }\n        }\n    }\n}\n\nvoid Grid_reset_dynamics(const GridPointer grid)\n{\n    if (grid->azps) ZonePairs_free(grid->azps);\n    grid->azps = NULL;\n    grid->npz = 0;\n    int i;\n    for (i = 0; i < grid->nz; i++) {\n        *(grid->is_populated + i) = 0;\n        ZonePointer z = *(grid->zps + i);\n        z->members = NULL;\n    }\n}\n\nint *Grid_to_array(const GridPointer grid)\n{\n    int *rtn;\n    rtn = (int *) Util_allocate(grid->nz * 3, sizeof(int));\n    int i;\n    for (i = 0; i < grid->nz; i++) {\n        ZonePointer z = *(grid->zps + i);\n        *(rtn + i * 3) = z->minx;\n        *(rtn + i * 3 + 1) = z->miny;\n        *(rtn + i * 3 + 2) = z->width;\n    }\n    return rtn;\n}\n\nvoid Grid_free(const GridPointer grid)\n{\n    ZonePairs_free(grid->azps);\n    Zones_free(grid->zps, grid->nz);\n    free(grid->pzps);\n    free(grid->zps);\n    free(grid->is_populated);\n}\n","/* vim: set et ts=3 sw=3 sts=3 ft=c:\n *\n * Copyright (C) 2012, 2013, 2014 James McLaughlin et al.  All rights reserved.\n * https://github.com/udp/json-parser\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *   notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"json.h\"\n\n#ifdef _MSC_VER\n   #ifndef _CRT_SECURE_NO_WARNINGS\n      #define _CRT_SECURE_NO_WARNINGS\n   #endif\n#endif\n\nconst struct _json_value json_value_none;\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\ntypedef unsigned int json_uchar;\n\nstatic unsigned char hex_value (json_char c)\n{\n   if (isdigit(c))\n      return c - '0';\n\n   switch (c) {\n      case 'a': case 'A': return 0x0A;\n      case 'b': case 'B': return 0x0B;\n      case 'c': case 'C': return 0x0C;\n      case 'd': case 'D': return 0x0D;\n      case 'e': case 'E': return 0x0E;\n      case 'f': case 'F': return 0x0F;\n      default: return 0xFF;\n   }\n}\n\ntypedef struct\n{\n   unsigned long used_memory;\n\n   unsigned int uint_max;\n   unsigned long ulong_max;\n\n   json_settings settings;\n   int first_pass;\n\n   const json_char * ptr;\n   unsigned int cur_line, cur_col;\n\n} json_state;\n\nstatic void * default_alloc (size_t size, int zero, void * user_data)\n{\n   return zero ? calloc (1, size) : malloc (size);\n}\n\nstatic void default_free (void * ptr, void * user_data)\n{\n   free (ptr);\n}\n\nstatic void * json_alloc (json_state * state, unsigned long size, int zero)\n{\n   if ((state->ulong_max - state->used_memory) < size)\n      return 0;\n\n   if (state->settings.max_memory\n         && (state->used_memory += size) > state->settings.max_memory)\n   {\n      return 0;\n   }\n\n   return state->settings.mem_alloc (size, zero, state->settings.user_data);\n}\n\nstatic int new_value (json_state * state,\n                      json_value ** top, json_value ** root, json_value ** alloc,\n                      json_type type)\n{\n   json_value * value;\n   int values_size;\n\n   if (!state->first_pass)\n   {\n      value = *top = *alloc;\n      *alloc = (*alloc)->_reserved.next_alloc;\n\n      if (!*root)\n         *root = value;\n\n      switch (value->type)\n      {\n         case json_array:\n\n            if (value->u.array.length == 0)\n               break;\n\n            if (! (value->u.array.values = (json_value **) json_alloc\n               (state, value->u.array.length * sizeof (json_value *), 0)) )\n            {\n               return 0;\n            }\n\n            value->u.array.length = 0;\n            break;\n\n         case json_object:\n\n            if (value->u.object.length == 0)\n               break;\n\n            values_size = sizeof (*value->u.object.values) * value->u.object.length;\n\n            if (! (value->u.object.values = (json_object_entry *) json_alloc\n                  (state, values_size + ((unsigned long) value->u.object.values), 0)) )\n            {\n               return 0;\n            }\n\n            value->_reserved.object_mem = (*(char **) &value->u.object.values) + values_size;\n\n            value->u.object.length = 0;\n            break;\n\n         case json_string:\n\n            if (! (value->u.string.ptr = (json_char *) json_alloc\n               (state, (value->u.string.length + 1) * sizeof (json_char), 0)) )\n            {\n               return 0;\n            }\n\n            value->u.string.length = 0;\n            break;\n\n         default:\n            break;\n      };\n\n      return 1;\n   }\n\n   if (! (value = (json_value *) json_alloc\n         (state, sizeof (json_value) + state->settings.value_extra, 1)))\n   {\n      return 0;\n   }\n\n   if (!*root)\n      *root = value;\n\n   value->type = type;\n   value->parent = *top;\n\n   #ifdef JSON_TRACK_SOURCE\n      value->line = state->cur_line;\n      value->col = state->cur_col;\n   #endif\n\n   if (*alloc)\n      (*alloc)->_reserved.next_alloc = value;\n\n   *alloc = *top = value;\n\n   return 1;\n}\n\n#define whitespace \\\n   case '\\n': ++ state.cur_line;  state.cur_col = 0; \\\n   case ' ': case '\\t': case '\\r'\n\n#define string_add(b)  \\\n   do { if (!state.first_pass) string [string_length] = b;  ++ string_length; } while (0);\n\n#define line_and_col \\\n   state.cur_line, state.cur_col\n\nstatic const long\n   flag_next             = 1 << 0,\n   flag_reproc           = 1 << 1,\n   flag_need_comma       = 1 << 2,\n   flag_seek_value       = 1 << 3, \n   flag_escaped          = 1 << 4,\n   flag_string           = 1 << 5,\n   flag_need_colon       = 1 << 6,\n   flag_done             = 1 << 7,\n   flag_num_negative     = 1 << 8,\n   flag_num_zero         = 1 << 9,\n   flag_num_e            = 1 << 10,\n   flag_num_e_got_sign   = 1 << 11,\n   flag_num_e_negative   = 1 << 12,\n   flag_line_comment     = 1 << 13,\n   flag_block_comment    = 1 << 14;\n\njson_value * json_parse_ex (json_settings * settings,\n                            const json_char * json,\n                            size_t length,\n                            char * error_buf)\n{\n   json_char error [json_error_max];\n   const json_char * end;\n   json_value * top, * root, * alloc = 0;\n   json_state state = { 0 };\n   long flags;\n   long num_digits = 0, num_e = 0;\n   json_int_t num_fraction = 0;\n\n   /* Skip UTF-8 BOM\n    */\n   if (length >= 3 && ((unsigned char) json [0]) == 0xEF\n                   && ((unsigned char) json [1]) == 0xBB\n                   && ((unsigned char) json [2]) == 0xBF)\n   {\n      json += 3;\n      length -= 3;\n   }\n\n   error[0] = '\\0';\n   end = (json + length);\n\n   memcpy (&state.settings, settings, sizeof (json_settings));\n\n   if (!state.settings.mem_alloc)\n      state.settings.mem_alloc = default_alloc;\n\n   if (!state.settings.mem_free)\n      state.settings.mem_free = default_free;\n\n   memset (&state.uint_max, 0xFF, sizeof (state.uint_max));\n   memset (&state.ulong_max, 0xFF, sizeof (state.ulong_max));\n\n   state.uint_max -= 8; /* limit of how much can be added before next check */\n   state.ulong_max -= 8;\n\n   for (state.first_pass = 1; state.first_pass >= 0; -- state.first_pass)\n   {\n      json_uchar uchar;\n      unsigned char uc_b1, uc_b2, uc_b3, uc_b4;\n      json_char * string = 0;\n      unsigned int string_length = 0;\n\n      top = root = 0;\n      flags = flag_seek_value;\n\n      state.cur_line = 1;\n\n      for (state.ptr = json ;; ++ state.ptr)\n      {\n         json_char b = (state.ptr == end ? 0 : *state.ptr);\n         \n         if (flags & flag_string)\n         {\n            if (!b)\n            {  sprintf (error, \"Unexpected EOF in string (at %d:%d)\", line_and_col);\n               goto e_failed;\n            }\n\n            if (string_length > state.uint_max)\n               goto e_overflow;\n\n            if (flags & flag_escaped)\n            {\n               flags &= ~ flag_escaped;\n\n               switch (b)\n               {\n                  case 'b':  string_add ('\\b');  break;\n                  case 'f':  string_add ('\\f');  break;\n                  case 'n':  string_add ('\\n');  break;\n                  case 'r':  string_add ('\\r');  break;\n                  case 't':  string_add ('\\t');  break;\n                  case 'u':\n\n                    if (end - state.ptr < 4 || \n                        (uc_b1 = hex_value (*++ state.ptr)) == 0xFF ||\n                        (uc_b2 = hex_value (*++ state.ptr)) == 0xFF ||\n                        (uc_b3 = hex_value (*++ state.ptr)) == 0xFF ||\n                        (uc_b4 = hex_value (*++ state.ptr)) == 0xFF)\n                    {\n                        sprintf (error, \"Invalid character value `%c` (at %d:%d)\", b, line_and_col);\n                        goto e_failed;\n                    }\n\n                    uc_b1 = (uc_b1 << 4) | uc_b2;\n                    uc_b2 = (uc_b3 << 4) | uc_b4;\n                    uchar = (uc_b1 << 8) | uc_b2;\n\n                    if ((uchar & 0xF800) == 0xD800) {\n                        json_uchar uchar2;\n                        \n                        if (end - state.ptr < 6 || (*++ state.ptr) != '\\\\' || (*++ state.ptr) != 'u' ||\n                            (uc_b1 = hex_value (*++ state.ptr)) == 0xFF ||\n                            (uc_b2 = hex_value (*++ state.ptr)) == 0xFF ||\n                            (uc_b3 = hex_value (*++ state.ptr)) == 0xFF ||\n                            (uc_b4 = hex_value (*++ state.ptr)) == 0xFF)\n                        {\n                            sprintf (error, \"Invalid character value `%c` (at %d:%d)\", b, line_and_col);\n                            goto e_failed;\n                        }\n\n                        uc_b1 = (uc_b1 << 4) | uc_b2;\n                        uc_b2 = (uc_b3 << 4) | uc_b4;\n                        uchar2 = (uc_b1 << 8) | uc_b2;\n                        \n                        uchar = 0x010000 | ((uchar & 0x3FF) << 10) | (uchar2 & 0x3FF);\n                    }\n\n                    if (sizeof (json_char) >= sizeof (json_uchar) || (uchar <= 0x7F))\n                    {\n                       string_add ((json_char) uchar);\n                       break;\n                    }\n\n                    if (uchar <= 0x7FF)\n                    {\n                        if (state.first_pass)\n                           string_length += 2;\n                        else\n                        {  string [string_length ++] = 0xC0 | (uchar >> 6);\n                           string [string_length ++] = 0x80 | (uchar & 0x3F);\n                        }\n\n                        break;\n                    }\n\n                    if (uchar <= 0xFFFF) {\n                        if (state.first_pass)\n                           string_length += 3;\n                        else\n                        {  string [string_length ++] = 0xE0 | (uchar >> 12);\n                           string [string_length ++] = 0x80 | ((uchar >> 6) & 0x3F);\n                           string [string_length ++] = 0x80 | (uchar & 0x3F);\n                        }\n                        \n                        break;\n                    }\n\n                    if (state.first_pass)\n                       string_length += 4;\n                    else\n                    {  string [string_length ++] = 0xF0 | (uchar >> 18);\n                       string [string_length ++] = 0x80 | ((uchar >> 12) & 0x3F);\n                       string [string_length ++] = 0x80 | ((uchar >> 6) & 0x3F);\n                       string [string_length ++] = 0x80 | (uchar & 0x3F);\n                    }\n\n                    break;\n\n                  default:\n                     string_add (b);\n               };\n\n               continue;\n            }\n\n            if (b == '\\\\')\n            {\n               flags |= flag_escaped;\n               continue;\n            }\n\n            if (b == '\"')\n            {\n               if (!state.first_pass)\n                  string [string_length] = 0;\n\n               flags &= ~ flag_string;\n               string = 0;\n\n               switch (top->type)\n               {\n                  case json_string:\n\n                     top->u.string.length = string_length;\n                     flags |= flag_next;\n\n                     break;\n\n                  case json_object:\n\n                     if (state.first_pass)\n                        (*(json_char **) &top->u.object.values) += string_length + 1;\n                     else\n                     {  \n                        top->u.object.values [top->u.object.length].name\n                           = (json_char *) top->_reserved.object_mem;\n\n                        top->u.object.values [top->u.object.length].name_length\n                           = string_length;\n\n                        (*(json_char **) &top->_reserved.object_mem) += string_length + 1;\n                     }\n\n                     flags |= flag_seek_value | flag_need_colon;\n                     continue;\n\n                  default:\n                     break;\n               };\n            }\n            else\n            {\n               string_add (b);\n               continue;\n            }\n         }\n\n         if (state.settings.settings & json_enable_comments)\n         {\n            if (flags & (flag_line_comment | flag_block_comment))\n            {\n               if (flags & flag_line_comment)\n               {\n                  if (b == '\\r' || b == '\\n' || !b)\n                  {\n                     flags &= ~ flag_line_comment;\n                     -- state.ptr;  /* so null can be reproc'd */\n                  }\n\n                  continue;\n               }\n\n               if (flags & flag_block_comment)\n               {\n                  if (!b)\n                  {  sprintf (error, \"%d:%d: Unexpected EOF in block comment\", line_and_col);\n                     goto e_failed;\n                  }\n\n                  if (b == '*' && state.ptr < (end - 1) && state.ptr [1] == '/')\n                  {\n                     flags &= ~ flag_block_comment;\n                     ++ state.ptr;  /* skip closing sequence */\n                  }\n\n                  continue;\n               }\n            }\n            else if (b == '/')\n            {\n               if (! (flags & (flag_seek_value | flag_done)) && top->type != json_object)\n               {  sprintf (error, \"%d:%d: Comment not allowed here\", line_and_col);\n                  goto e_failed;\n               }\n\n               if (++ state.ptr == end)\n               {  sprintf (error, \"%d:%d: EOF unexpected\", line_and_col);\n                  goto e_failed;\n               }\n\n               switch (b = *state.ptr)\n               {\n                  case '/':\n                     flags |= flag_line_comment;\n                     continue;\n\n                  case '*':\n                     flags |= flag_block_comment;\n                     continue;\n\n                  default:\n                     sprintf (error, \"%d:%d: Unexpected `%c` in comment opening sequence\", line_and_col, b);\n                     goto e_failed;\n               };\n            }\n         }\n\n         if (flags & flag_done)\n         {\n            if (!b)\n               break;\n\n            switch (b)\n            {\n               whitespace:\n                  continue;\n\n               default:\n\n                  sprintf (error, \"%d:%d: Trailing garbage: `%c`\",\n                           state.cur_line, state.cur_col, b);\n\n                  goto e_failed;\n            };\n         }\n\n         if (flags & flag_seek_value)\n         {\n            switch (b)\n            {\n               whitespace:\n                  continue;\n\n               case ']':\n\n                  if (top && top->type == json_array)\n                     flags = (flags & ~ (flag_need_comma | flag_seek_value)) | flag_next;\n                  else\n                  {  sprintf (error, \"%d:%d: Unexpected ]\", line_and_col);\n                     goto e_failed;\n                  }\n\n                  break;\n\n               default:\n\n                  if (flags & flag_need_comma)\n                  {\n                     if (b == ',')\n                     {  flags &= ~ flag_need_comma;\n                        continue;\n                     }\n                     else\n                     {\n                        sprintf (error, \"%d:%d: Expected , before %c\",\n                                 state.cur_line, state.cur_col, b);\n\n                        goto e_failed;\n                     }\n                  }\n\n                  if (flags & flag_need_colon)\n                  {\n                     if (b == ':')\n                     {  flags &= ~ flag_need_colon;\n                        continue;\n                     }\n                     else\n                     { \n                        sprintf (error, \"%d:%d: Expected : before %c\",\n                                 state.cur_line, state.cur_col, b);\n\n                        goto e_failed;\n                     }\n                  }\n\n                  flags &= ~ flag_seek_value;\n\n                  switch (b)\n                  {\n                     case '{':\n\n                        if (!new_value (&state, &top, &root, &alloc, json_object))\n                           goto e_alloc_failure;\n\n                        continue;\n\n                     case '[':\n\n                        if (!new_value (&state, &top, &root, &alloc, json_array))\n                           goto e_alloc_failure;\n\n                        flags |= flag_seek_value;\n                        continue;\n\n                     case '\"':\n\n                        if (!new_value (&state, &top, &root, &alloc, json_string))\n                           goto e_alloc_failure;\n\n                        flags |= flag_string;\n\n                        string = top->u.string.ptr;\n                        string_length = 0;\n\n                        continue;\n\n                     case 't':\n\n                        if ((end - state.ptr) < 3 || *(++ state.ptr) != 'r' ||\n                            *(++ state.ptr) != 'u' || *(++ state.ptr) != 'e')\n                        {\n                           goto e_unknown_value;\n                        }\n\n                        if (!new_value (&state, &top, &root, &alloc, json_boolean))\n                           goto e_alloc_failure;\n\n                        top->u.boolean = 1;\n\n                        flags |= flag_next;\n                        break;\n\n                     case 'f':\n\n                        if ((end - state.ptr) < 4 || *(++ state.ptr) != 'a' ||\n                            *(++ state.ptr) != 'l' || *(++ state.ptr) != 's' ||\n                            *(++ state.ptr) != 'e')\n                        {\n                           goto e_unknown_value;\n                        }\n\n                        if (!new_value (&state, &top, &root, &alloc, json_boolean))\n                           goto e_alloc_failure;\n\n                        flags |= flag_next;\n                        break;\n\n                     case 'n':\n\n                        if ((end - state.ptr) < 3 || *(++ state.ptr) != 'u' ||\n                            *(++ state.ptr) != 'l' || *(++ state.ptr) != 'l')\n                        {\n                           goto e_unknown_value;\n                        }\n\n                        if (!new_value (&state, &top, &root, &alloc, json_null))\n                           goto e_alloc_failure;\n\n                        flags |= flag_next;\n                        break;\n\n                     default:\n\n                        if (isdigit (b) || b == '-')\n                        {\n                           if (!new_value (&state, &top, &root, &alloc, json_integer))\n                              goto e_alloc_failure;\n\n                           if (!state.first_pass)\n                           {\n                              while (isdigit (b) || b == '+' || b == '-'\n                                        || b == 'e' || b == 'E' || b == '.')\n                              {\n                                 if ( (++ state.ptr) == end)\n                                 {\n                                    b = 0;\n                                    break;\n                                 }\n\n                                 b = *state.ptr;\n                              }\n\n                              flags |= flag_next | flag_reproc;\n                              break;\n                           }\n\n                           flags &= ~ (flag_num_negative | flag_num_e |\n                                        flag_num_e_got_sign | flag_num_e_negative |\n                                           flag_num_zero);\n\n                           num_digits = 0;\n                           num_fraction = 0;\n                           num_e = 0;\n\n                           if (b != '-')\n                           {\n                              flags |= flag_reproc;\n                              break;\n                           }\n\n                           flags |= flag_num_negative;\n                           continue;\n                        }\n                        else\n                        {  sprintf (error, \"%d:%d: Unexpected %c when seeking value\", line_and_col, b);\n                           goto e_failed;\n                        }\n                  };\n            };\n         }\n         else\n         {\n            switch (top->type)\n            {\n            case json_object:\n               \n               switch (b)\n               {\n                  whitespace:\n                     continue;\n\n                  case '\"':\n\n                     if (flags & flag_need_comma)\n                     {  sprintf (error, \"%d:%d: Expected , before \\\"\", line_and_col);\n                        goto e_failed;\n                     }\n\n                     flags |= flag_string;\n\n                     string = (json_char *) top->_reserved.object_mem;\n                     string_length = 0;\n\n                     break;\n                  \n                  case '}':\n\n                     flags = (flags & ~ flag_need_comma) | flag_next;\n                     break;\n\n                  case ',':\n\n                     if (flags & flag_need_comma)\n                     {\n                        flags &= ~ flag_need_comma;\n                        break;\n                     }\n\n                  default:\n                     sprintf (error, \"%d:%d: Unexpected `%c` in object\", line_and_col, b);\n                     goto e_failed;\n               };\n\n               break;\n\n            case json_integer:\n            case json_double:\n\n               if (isdigit (b))\n               {\n                  ++ num_digits;\n\n                  if (top->type == json_integer || flags & flag_num_e)\n                  {\n                     if (! (flags & flag_num_e))\n                     {\n                        if (flags & flag_num_zero)\n                        {  sprintf (error, \"%d:%d: Unexpected `0` before `%c`\", line_and_col, b);\n                           goto e_failed;\n                        }\n\n                        if (num_digits == 1 && b == '0')\n                           flags |= flag_num_zero;\n                     }\n                     else\n                     {\n                        flags |= flag_num_e_got_sign;\n                        num_e = (num_e * 10) + (b - '0');\n                        continue;\n                     }\n\n                     top->u.integer = (top->u.integer * 10) + (b - '0');\n                     continue;\n                  }\n\n                  num_fraction = (num_fraction * 10) + (b - '0');\n                  continue;\n               }\n\n               if (b == '+' || b == '-')\n               {\n                  if ( (flags & flag_num_e) && !(flags & flag_num_e_got_sign))\n                  {\n                     flags |= flag_num_e_got_sign;\n\n                     if (b == '-')\n                        flags |= flag_num_e_negative;\n\n                     continue;\n                  }\n               }\n               else if (b == '.' && top->type == json_integer)\n               {\n                  if (!num_digits)\n                  {  sprintf (error, \"%d:%d: Expected digit before `.`\", line_and_col);\n                     goto e_failed;\n                  }\n\n                  top->type = json_double;\n                  top->u.dbl = (double) top->u.integer;\n\n                  num_digits = 0;\n                  continue;\n               }\n\n               if (! (flags & flag_num_e))\n               {\n                  if (top->type == json_double)\n                  {\n                     if (!num_digits)\n                     {  sprintf (error, \"%d:%d: Expected digit after `.`\", line_and_col);\n                        goto e_failed;\n                     }\n\n                     top->u.dbl += ((double) num_fraction) / (pow (10.0, (double) num_digits));\n                  }\n\n                  if (b == 'e' || b == 'E')\n                  {\n                     flags |= flag_num_e;\n\n                     if (top->type == json_integer)\n                     {\n                        top->type = json_double;\n                        top->u.dbl = (double) top->u.integer;\n                     }\n\n                     num_digits = 0;\n                     flags &= ~ flag_num_zero;\n\n                     continue;\n                  }\n               }\n               else\n               {\n                  if (!num_digits)\n                  {  sprintf (error, \"%d:%d: Expected digit after `e`\", line_and_col);\n                     goto e_failed;\n                  }\n\n                  top->u.dbl *= pow (10.0, (double)\n                      (flags & flag_num_e_negative ? - num_e : num_e));\n               }\n\n               if (flags & flag_num_negative)\n               {\n                  if (top->type == json_integer)\n                     top->u.integer = - top->u.integer;\n                  else\n                     top->u.dbl = - top->u.dbl;\n               }\n\n               flags |= flag_next | flag_reproc;\n               break;\n\n            default:\n               break;\n            };\n         }\n\n         if (flags & flag_reproc)\n         {\n            flags &= ~ flag_reproc;\n            -- state.ptr;\n         }\n\n         if (flags & flag_next)\n         {\n            flags = (flags & ~ flag_next) | flag_need_comma;\n\n            if (!top->parent)\n            {\n               /* root value done */\n\n               flags |= flag_done;\n               continue;\n            }\n\n            if (top->parent->type == json_array)\n               flags |= flag_seek_value;\n               \n            if (!state.first_pass)\n            {\n               json_value * parent = top->parent;\n\n               switch (parent->type)\n               {\n                  case json_object:\n\n                     parent->u.object.values\n                        [parent->u.object.length].value = top;\n\n                     break;\n\n                  case json_array:\n\n                     parent->u.array.values\n                           [parent->u.array.length] = top;\n\n                     break;\n\n                  default:\n                     break;\n               };\n            }\n\n            if ( (++ top->parent->u.array.length) > state.uint_max)\n               goto e_overflow;\n\n            top = top->parent;\n\n            continue;\n         }\n      }\n\n      alloc = root;\n   }\n\n   return root;\n\ne_unknown_value:\n\n   sprintf (error, \"%d:%d: Unknown value\", line_and_col);\n   goto e_failed;\n\ne_alloc_failure:\n\n   strcpy (error, \"Memory allocation failure\");\n   goto e_failed;\n\ne_overflow:\n\n   sprintf (error, \"%d:%d: Too long (caught overflow)\", line_and_col);\n   goto e_failed;\n\ne_failed:\n\n   if (error_buf)\n   {\n      if (*error)\n         strcpy (error_buf, error);\n      else\n         strcpy (error_buf, \"Unknown error\");\n   }\n\n   if (state.first_pass)\n      alloc = root;\n\n   while (alloc)\n   {\n      top = alloc->_reserved.next_alloc;\n      state.settings.mem_free (alloc, state.settings.user_data);\n      alloc = top;\n   }\n\n   if (!state.first_pass)\n      json_value_free_ex (&state.settings, root);\n\n   return 0;\n}\n\njson_value * json_parse (const json_char * json, size_t length)\n{\n   json_settings settings = { 0 };\n   return json_parse_ex (&settings, json, length, 0);\n}\n\nvoid json_value_free_ex (json_settings * settings, json_value * value)\n{\n   json_value * cur_value;\n\n   if (!value)\n      return;\n\n   value->parent = 0;\n\n   while (value)\n   {\n      switch (value->type)\n      {\n         case json_array:\n\n            if (!value->u.array.length)\n            {\n               settings->mem_free (value->u.array.values, settings->user_data);\n               break;\n            }\n\n            value = value->u.array.values [-- value->u.array.length];\n            continue;\n\n         case json_object:\n\n            if (!value->u.object.length)\n            {\n               settings->mem_free (value->u.object.values, settings->user_data);\n               break;\n            }\n\n            value = value->u.object.values [-- value->u.object.length].value;\n            continue;\n\n         case json_string:\n\n            settings->mem_free (value->u.string.ptr, settings->user_data);\n            break;\n\n         default:\n            break;\n      };\n\n      cur_value = value;\n      value = value->parent;\n      settings->mem_free (cur_value, settings->user_data);\n   }\n}\n\nvoid json_value_free (json_value * value)\n{\n   json_settings settings = { 0 };\n   settings.mem_free = default_free;\n   json_value_free_ex (&settings, value);\n}\n\n","/*****************************************************************************\n\n * Author: Numerical recepies in C, modified by Ludvig Sundström\n\n * File Name: linmin.c\n\n * Description: \n * GraphPointeriven an n-dimensional point p[1..n] and an n-dimensional\n * direction xi[1..n], moves and resets p to where the function step(p) takes\n * on a minimum along the direction xi from p, and replaces xi by the actual\n * vector displacement that p was moved. Also returns as fret the value of func\n * at the returned location p. This is actually all accomplished by calling the\n * routines mnbrak and brent.  \n\n * Creation Date: 25-06-2015\n\n *****************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#include \"constants.h\"\n#include \"graph.h\"\n#include \"vertex.h\"\n#include \"util.h\"\n\n#define PARABOLIC_EXTRAPOLATION(ax, bx, cx, q, r) \\\n    ({ (*bx) - ((*bx - *cx) * q - (*bx - *ax) *r ) / \\\n     (2.0 * SIGN(MAX(fabs(q - r), TINY), q - r));})\n\nVectorPointer cached_gradient;\n\nstatic void move_vertices(VertexSet vs, double x)\n{\n    int i;   \n    for (i = 0; i < vs.n; i++) {\n        VertexPointer v = *(vs.set + i);\n        Vector ds;\n        ds = Vector_scalar_mult(cached_gradient[i], x);\n        Vertex_move(v, ds);\n    }\n}\n\nstatic double step(double x, GraphPointer graph, double (*e_fun)(GraphPointer))   \n{   \n    move_vertices(graph->vs, x);\n    Graph_reset_dynamics(graph);\n\n    double energy;\n    energy = e_fun(graph);\n\n    return energy;\n}\n\nstatic double isolate_minimum(\n        GraphPointer graph, \n        double ax, \n        double bx, \n        double cx, \n        double tol, \n        double *xmin,\n        double (*e_fun)(GraphPointer)\n    )\n{\n    int iter;\n    double a,b,d,etemp,fu,fv,fw,fx,p,q,r,tol1,tol2,u,v,w,x,xm;\n    double e=0.0;\n\n    a=(ax < cx ? ax : cx);\n    b=(ax > cx ? ax : cx);\n    x = w = v = bx;\n    fw = fv = fx = step(x, graph, e_fun);\n    for (iter = 1;iter <= ITMAX; iter++) {\n        xm = 0.5 * (a + b);\n        tol2 = 2.0 * (tol1 = tol * fabs(x) + ZEPS);\n        if (fabs(x-xm) <= (tol2-0.5*(b-a))) {\n            *xmin=x;\n            return fx;\n        }\n        if (fabs(e) > tol1) {\n            r = (x - w) * (fx - fv);\n            q =(x - v) * (fx - fw);\n            p = (x - v) * q - (x - w) * r;\n            q = 2.0 * (q - r);\n            if (q > 0.0) p = -p;\n            q=fabs(q);\n            etemp=e;\n            e=d;\n            if (fabs(p) >= fabs(0.5*q*etemp) || p <= q*(a-x) || p >= q*(b-x))\n                d=CGOLD*(e=(x >= xm ? a-x : b-x));\n            else {\n                d=p/q;\n                u=x+d;\n                if (u-a < tol2 || b-u < tol2)\n                    d=SIGN(tol1,xm-x);\n            }\n        } else {\n            d=CGOLD*(e=(x >= xm ? a-x : b-x));\n        }\n        u=(fabs(d) >= tol1 ? x+d : x+SIGN(tol1,d));\n        fu = step(u, graph, e_fun);\n        if (fu <= fx) {\n            if (u >= x) a=x; else b=x;\n            SHFT(v,w,x,u)\n                SHFT(fv,fw,fx,fu)\n        } else {\n            if (u < x) a=u; else b=u;\n            if (fu <= fw || w == x) {\n                v=w;\n                w=u;\n                fv=fw;\n                fw=fu;\n            } else if (fu <= fv || v == x || v == w) {\n                v=u;\n                fv=fu;\n            }\n        }\n    }\n    Util_runtime_error(\"Too many iterations in brent\");\n    *xmin=x;\n    return fx;\n}\n\nvoid bracket_minimum(\n        GraphPointer gp, \n        double *ax, \n        double *bx, \n        double *cx, \n        double *fa, \n        double *fb, \n        double *fc, \n        double (*e_fun)(GraphPointer)\n    )\n{\n    \n    *fa = step(*ax, gp, e_fun);\n    *fb = step(*bx, gp, e_fun);\n    \n    if (*fb > *fa) {\n        double dum;\n        SHFT(dum,*ax,*bx,dum);\n        SHFT(dum,*fb,*fa,dum);\n    }\n\n    *cx = *bx + GOLD * (*bx - *ax);\n    *fc = step(*cx, gp, e_fun);\n\n    while (*fb > *fc) {\n        \n        double r, q;\n        r = (*bx - *ax) * (*fb - *fc);\n        q = (*bx - *cx) * (*fb - *fa);\n        \n        double u, ulim;\n        u = PARABOLIC_EXTRAPOLATION(ax, bx, cx, q, r);\n        ulim = (*bx)+GLIMIT*(*cx-*bx);\n\n        double fu;\n        if ((*bx-u)*(u-*cx) > 0.0) {\n            fu=(*step)(u, gp, e_fun);\n            if (fu < *fc) {\n                *ax=(*bx);\n                *bx=u;\n                *fa=(*fb);\n                *fb=fu;\n                return;\n            } else if (fu > *fb) {\n                *cx=u;\n                *fc=fu;\n                return;\n            }\n            u=(*cx)+GOLD*(*cx-*bx);\n            fu=(*step)(u, gp, e_fun);\n        } else if ((*cx-u)*(u-ulim) > 0.0) {\n            fu=(*step)(u, gp, e_fun);\n            if (fu < *fc) {\n                SHFT(*bx,*cx,u,*cx+GOLD*(*cx-*bx));\n                SHFT(*fb,*fc,fu,(*step)(u, gp, e_fun));\n            }\n        } else if ((u-ulim)*(ulim-*cx) >= 0.0) {\n            u=ulim;\n            fu=(*step)(u, gp, e_fun);\n        } else {\n            u = (*cx)+GOLD*(*cx-*bx);\n            fu=(*step)(u, gp, e_fun);\n        }\n        SHFT(*ax,*bx,*cx,u)\n        SHFT(*fa,*fb,*fc,fu)\n    }\n}\n\nvoid linmin(\n        GraphPointer graph, \n        double (*e_fun)(GraphPointer), \n        double *fret, \n        VectorPointer gradient\n    )   \n{   \n    VertexSet vs;\n    vs = graph->vs;\n\n    cached_gradient = (VectorPointer) Util_allocate(vs.n, sizeof(Vector));\n\n    int i;\n    for (i = 0; i < vs.n; i++) {\n        VertexPointer vp;\n        vp = *(vs.set + i);\n        vp->pos0 = vp->pos;\n\n        cached_gradient[i] = gradient[i];\n        gradient[i] = Vector_zero();\n    }\n\n    double ax, xx;\n    ax = 0.0; \n    xx = 1.0;   \n    \n    double bx, fa, fx, fb;\n    bracket_minimum(graph, &ax, &xx, &bx, &fa, &fx, &fb, e_fun);   \n\n    double xmin;\n    *fret = isolate_minimum(graph, ax, xx, bx, TOL, &xmin, e_fun);   \n    \n    for (i = 0; i < vs.n; i++) { \n        Vector_scalar_mult(gradient[i], xmin);\n    }   \n    free(cached_gradient);\n}\n\n","/***************************************************************************** \n * Author: Ludvig Sundström\n\n * File Name: minimizer.c\n \n * Description: Defines an object able to 'minimize' the energy of the graph\n * G(V, B) created by the set of Vertices V and Bonds B defined in JSON format.\n \n * Creation Date: 24-06-2015\n\n *****************************************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"util.h\"\n#include \"constants.h\"\n#include \"graph.h\"\n#include \"process_input.h\"\n#include \"linmin.h\"\n#include \"energy.h\"\n#include \"gradient.h\"\n\n#include \"emscripten.h\"\n\n#ifndef EMSCRIPT\n#define EMSCRIPT 0\n#endif\n\n#define CLOSE_TO_TARGET(fret, e, ftol) \\\n    ({2.0 * fabs(fret - e) <= (ftol) * (fabs((fret)) + fabs((e)) + EPS);})\n\nstatic void js_interact(GraphPointer graph)\n{\n    assert(graph);\n    float *varr;\n    int *barr, *zarr;\n    varr = NULL;\n    barr = NULL; zarr = NULL;\n    if (EMSCRIPT) {\n        varr = VertexSet_to_array(graph->vs);\n        barr = Bondset_to_array(graph->bs);\n        zarr = Grid_to_array(graph->grid);\n        EM_ASM_({\n            window.EXPORTS.processCdata($0, $1, $2, $3, $4, $5);\n        }, varr, barr, zarr, \n                graph->vs.n * 2, graph->bs.n * 2, graph->grid->nz * 3);\n    }\n    free(varr); free(barr); free(zarr);\n    varr = NULL; barr = NULL; zarr = NULL;\n}\n\nvoid create_sequences(\n        const VectorPointer gradient,\n        const VectorPointer g,\n        const VectorPointer h,\n        const int n,\n        const double gam, \n        const Strategy strat\n    )\n{\n    \n    assert(gradient && g && h); \n    assert(n > 0 && n <= MAX_NV); \n    assert(strat == INITIALIZE || strat == UPDATE);\n    \n    int i;\n    for (i = 0; i < n; i++) {\n        g[i] = Vector_negate(gradient[i]);\n        if (strat == INITIALIZE) {\n            gradient[i] = h[i] = g[i];\n        } else {\n            Vector h_gam, g_h_gam;\n            h_gam = Vector_scalar_mult(h[i], gam);\n            g_h_gam = Vector_add(g[i], h_gam);\n            gradient[i] = h[i] = g_h_gam;\n        }\n    }\n}\n\nvoid calculate_score(\n       const VectorPointer gradient, \n       const VectorPointer g,\n       const int n,\n       double *gg, \n       double *dgg\n    )\n{\n    assert(gradient); assert(g);\n    assert(n > 0 && n <= MAX_NV);\n    assert(Util_is_zero(*gg) && Util_is_zero(*dgg));\n\n    int i;\n    for (i = 0; i < n; i++) {\n        *gg += Vector_dot(g[i], g[i]);\n        *dgg += Vector_dot(Vector_add(gradient[i], g[i]), gradient[i]);\n\n    }\n}\n\nstatic void conjugate_gradient(\n        GraphPointer graph, \n        double (*e_fun)(GraphPointer), \n        void (*g_fun)(GraphPointer, VectorPointer),\n        double ftol\n    )\n{\n    \n    assert(graph && e_fun && g_fun);\n    assert(graph->grid && graph->vs.set && graph->bs.set);\n    assert(ftol > 0 && ftol < 0.1);\n\n    int nv;\n    nv = graph->vs.n;\n\n    VectorPointer gradient, g, h;\n    g = Util_allocate_initialize(nv, sizeof(Vector));\n    h = Util_allocate_initialize(nv, sizeof(Vector));\n    gradient = Util_allocate_initialize(nv, sizeof(Vector));\n\n    assert(g && h && gradient);\n\n    g_fun(graph, gradient);\n\n    create_sequences(gradient, g, h, nv, 1, INITIALIZE);\n\n    double energy;\n    energy = e_fun(graph);\n\n    assert(energy >= 0);\n    \n    int i; \n    for (i = 0; i < ITMAX; i++) {\n        \n        double fret = 0.0;\n        linmin(graph, e_fun, &fret, gradient);\n\n        if (CLOSE_TO_TARGET(fret, energy, ftol)) break;\n\n        g_fun(graph, gradient);\n        energy = e_fun(graph);\n\n        double gg, dgg;\n        dgg = gg = 0.0;\n        calculate_score(gradient, g, nv, &gg, &dgg); \n\n        if (fabs(gg) < EPS) {\n            break;\n        }\n        \n        double gam;\n        gam = dgg / gg;\n        create_sequences(gradient, g, h, nv, gam, UPDATE);\n    }\n    free(gradient); free(g); free(h);\n    gradient = NULL; g = NULL; h = NULL;\n\n    assert(!g && !h && !gradient);\n\n    js_interact(graph);\n}\n\nint Minimizer_run(const char *fname) \n{\n    assert(fname);\n\n    if (access(fname, R_OK) != -1) {\n\n        GraphPointer graph;\n        graph = Graph_create(fname);\n\n        conjugate_gradient(graph, Energy_calculate, Gradient_calculate, FTOL);\n\n        Graph_free(graph);\n        graph = NULL;\n        \n        assert(!graph);\n\n        return 0;\n    } else {\n\n        fprintf(stderr, \"Error: Can't read file: %s\\n\", fname);\n        return -1;\n    }\n\n}\n\n\n","/*****************************************************************************\n\n* File Name: Pair.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 30-07-2015\n\n*****************************************************************************/\n\n#include <stdlib.h>\n#include \"util.h\"\n#include \"pair.h\"\n\nPair Pair_initialize(void *fst, void *snd) \n{\n    Pair rtn;\n    rtn.fst = fst;\n    rtn.snd = snd;\n    return rtn;\n}\n\nPairPointer Pair_create(void *fst, void *snd) \n{\n    PairPointer rtn = (PairPointer) Util_allocate(1, sizeof(Pair));\n    *rtn = Pair_initialize(fst, snd);\n    return rtn;\n}\n\n","/*****************************************************************************\n\n* File Name: placement.c\n\n* Author: Ludvig Sundström\n\n* Description: Assign positions (x, y) to a set of vertices\n\n* Creation Date: 13-07-2015\n\n*****************************************************************************/\n\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"vertex.h\"\n#include \"vertex_set.h\"\n#include \"constants.h\"\n#include \"util.h\"\n\n/* Private *******************************************************************/\n\nstatic int comp_by_mass(const void *elem1, const void *elem2) \n{\n    VertexPointer *fst = (VertexPointer *) elem1;\n    VertexPointer *snd = (VertexPointer *) elem2;\n    if ((*fst)->mass > (*snd)->mass) return 1;\n    if ((*fst)->mass < (*snd)->mass) return -1;\n    return 0;\n}\n\nstatic int comp_by_id(const void *elem1, const void *elem2) \n{\n    VertexPointer *fst = (VertexPointer *) elem1;\n    VertexPointer *snd = (VertexPointer *) elem2;\n    if ((*fst)->id > (*snd)->id) return 1;\n    if ((*fst)->id < (*snd)->id) return -1;\n    return 0;\n}\n\n/* Public ********************************************************************/\n\n/**\n * Assigns the positions of vertices vs as a spiral starting from the middle of\n * the panel whose dimension are specified by PANEL_X and PANEL_Y, starting\n * with the vertex with the most connections, the vertex with the second most\n * connections etc.\n */\nvoid Placement_set_spiral(VertexSet vs, const int nv)\n{\n    qsort((void *) vs.set, vs.n, sizeof(void *), comp_by_mass);\n\n    int n;\n    n = nv;\n    while (fabs(sqrt(n) - (int) sqrt(n)) > EPS) {\n        n++;\n    }\n    \n    int dimx, dimy;\n    dimx = (int) sqrt(n);\n    dimy = dimx;\n    \n    double gapx, gapy;\n    gapx = PANEL_X / dimx;\n    gapy = PANEL_Y / dimy;\n    \n    int x, y;\n    x = 0; \n    y = 0;\n    \n    int dx, dy;\n    dx = 0;\n    dy = -1;\n\n    int t;\n    t = fmax(dimx, dimy);\n\n    int i;\n    for (i = nv - 1; i >= 0; i--) {\n        if (!(*(vs.set + i))->pos.given_coords) {\n            if ((-dimx / 2 <= x && x <= dimx / 2) && \n                (-dimy / 2 <= y && y <= dimy / 2))\n            {\n                double placex, placey;\n                placex = (double) x * gapx;\n                placey = (double) y * gapy;\n                (*(vs.set + i))->pos = Vector_initialize(placex, placey);\n            }\n        }\n        if ((x == y) || ((x < 0) && (x == -y)) || ((x > 0) && (x == 1 - y))) {\n            t = dx;\n            dx = -dy;\n            dy = t;\n        }\n        x += dx;\n        y += dy; \n    }\n    qsort((void *) vs.set, vs.n, sizeof(void *), comp_by_id);\n}\n\n/**\n * Assigns the positions of vertices vs.set as a grid in the panel whose dimension\n * are specified by PANEL_X and PANEL_Y, starting in the upper-left corner with\n * the vertex with the lowest id. \n */\nvoid Placement_set_grid(VertexSet vs, const int nv) \n{\n    int i, n, vdim, rows, cols;\n    double gapx, gapy, offsetx, offsety, x, y;\n    n = nv; \n    while (fabs(sqrt(n) - (int) sqrt(n)) > EPS) {\n        n++;\n    }\n    vdim = sqrt(n);\n    gapx = PANEL_X / vdim;\n    gapy = PANEL_Y / vdim;\n    offsetx = gapx / 2;\n    offsety = gapy / 2;\n    rows = 0;\n    cols = -1;\n    for (i = 0; i < nv; i++) {\n        if (i % vdim == 0) {\n            rows++;\n            cols = 0; \n        }\n        x = cols * gapx + offsetx;\n        y = rows * gapy + offsety; \n        (*(vs.set + i))->pos = Vector_initialize(x, y);\n        cols++;\n    }\n}\n","\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <math.h>\n\n#include \"constants.h\"\n#include \"util.h\"\n#include \"json.h\"\n#include \"graph.h\"\n#include \"vertex_set.h\"\n#include \"vertex_set.h\"\n\nPair process_json(const char *filename, int *nvp, int *nbp)\n{\n    FILE *fp;\n    struct stat filestatus;\n    int file_size;\n    char* file_contents;\n    json_char* json;\n    json_value* value;\n\n    if ( stat(filename, &filestatus) != 0) {\n        char  buf[256];\n        strcpy(buf, \"process_json(): File not found: \");\n        strcat(buf, filename);\n        Util_runtime_error(buf);\n    }\n    file_size = filestatus.st_size;\n    file_contents = (char *) malloc(filestatus.st_size);\n    if ( file_contents == NULL) {\n        Util_runtime_error(\"process_json(): Unable to allocate memory\");\n    }\n\n    fp = fopen(filename, \"rt\");\n\n    if (fp == NULL) {\n        fclose(fp);\n        free(file_contents);\n        Util_runtime_error(\"process_json(): Unable to open file\");\n    }\n    if ( fread(file_contents, file_size, 1, fp) != 1 ) {\n        fclose(fp);\n        free(file_contents);\n        Util_runtime_error(\"process_json(): Unable to read file\");\n    }\n\n    fclose(fp);\n\n    json = (json_char*)file_contents;\n\n    value = json_parse(json,file_size);\n\n    if (value == NULL) {\n        free(file_contents);\n        json_value_free(value);\n        Util_runtime_error(\"process_json(): Unable to parse data\");\n    }\n    if (value->u.object.length != 2) {\n        free(file_contents);\n        json_value_free(value);\n        Util_runtime_error(\"process_json(): Wrong number of keys\");\n    }\n    if (strcmp(value->u.object.values[0].name, \"vertices\") != 0) {\n        free(file_contents);\n        json_value_free(value);\n        Util_runtime_error(\"process_json(): First key is not vertices\");\n    }\n    if (strcmp(value->u.object.values[1].name, \"bonds\") != 0) {\n        free(file_contents);\n        json_value_free(value);\n        Util_runtime_error(\"process_json(): Second key is not 'bonds'\");\n    }\n\n    VertexSetPointer vs; BondSetPointer bs;\n    vs = VertexSet_create(value, nvp);\n    bs = BondSet_create(vs->set, value, nbp);\n\n    json_value_free(value);\n    free(file_contents);\n\n    return Pair_initialize(vs, bs);\n}\n\n","/*****************************************************************************\n* Author : Ludvig Sundström\n* File Name : util.c\n\n * Purpose : \n\n * Creation Date : 26-06-2015\n\n * Last Modified : \n\n *****************************************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <limits.h>\n\n#include \"util.h\"\n#include \"constants.h\"\n\n#define ANSI_COLOR_RED \"\\x1b[31m\"\n#define ANSI_COLOR_RESET \"\\x1b[0m\"\n\ndouble Util_collection_min(const double *col, const int n)\n{\n    int i, min;\n    min = col[0];\n    for (i = 1; i < n; i++) {\n        if (col[i] < min) min = col[i];\n    }\n    return min;\n}\n\nint Util_is_zero(const double x)\n{\n    return Util_equal(x, 0.0);\n}\n\nint Util_equal(const double tar, const double x) {\n    return fabs(x - tar) < EPS;\n}\n\nint Util_about(const double tar, const double x) {\n    if (Util_equal(tar, x)) return 1;\n    double err;\n    err = fabs(x * 0.05);\n    return fabs(x - tar) <= err;\n}\n\nint Util_in_range(const double lower, const double upper, const double x)\n{\n    int lowcond = x > lower || Util_equal(x, lower);\n    int upcond = x < upper || Util_equal(x, upper);\n    return lowcond && upcond;\n}\n\nvoid *Util_allocate(int nmemb, int size) {\n    void *rtn = malloc(nmemb * size);\n    if (rtn == NULL)\n    {\n        Util_runtime_error(\"Error when allocating memory\");\n    }\n    return rtn;\n}\n\nvoid *Util_allocate_initialize(int nmemb, int size) {\n    void *rtn = calloc(nmemb, size);\n    if (rtn == NULL)\n    {\n        Util_runtime_error(\"Error when allocating memory\");\n    }\n    return rtn;\n}\n\nvoid Util_runtime_error(char error_text[])\n{\n    fprintf(stderr,ANSI_COLOR_RED \"Runtime-error: %s\\n\" ANSI_COLOR_RESET,\n            error_text);\n    exit(1);\n}\n\n","/*****************************************************************************\n\n* File Name: math2D.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 06-07-2015\n\n*****************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#include \"vector.h\"\n#include \"util.h\"\n\nVector Vector_initialize(const double x, const double y)\n{\n    Vector rtn;\n    rtn.x = x;\n    rtn.y = y;\n    rtn.given_coords = 0;\n    rtn.len = sqrt(x * x + y * y);\n    return rtn;\n}\n\nVectorPointer Vector_create(double x, double y)\n{\n    VectorPointer rtn = (VectorPointer) malloc(sizeof(Vector));\n    *rtn = Vector_initialize(x, y);\n    return rtn;\n}\n\nVector Vector_zero()\n{\n    return Vector_initialize(0.0, 0.0);\n}\n\nVector Vector_add(Vector vec1, Vector vec2) \n{\n    return Vector_initialize(vec1.x + vec2.x, vec1.y + vec2.y);\n}\n\nVector Vector_sub(Vector vec1, Vector vec2) \n{\n    return Vector_initialize(vec1.x - vec2.x, vec1.y - vec2.y);\n}\n\nVector Vector_mult(Vector vec1, Vector vec2) \n{\n    return Vector_initialize(vec1.x * vec2.x, vec1.y * vec2.y);\n}\n\nVector Vector_negate(Vector vec) \n{\n    return Vector_initialize(-vec.x, -vec.y);\n}\n\nVector Vector_scalar_mult(Vector vec, double c)\n{\n    return Vector_initialize(c * vec.x, c * vec.y);\n}\n\nVector Vector_scalar_add(Vector vec, double c)\n{\n    return Vector_initialize(c + vec.x, c + vec.y);\n}\n\ndouble Vector_dot(Vector v1, Vector v2)\n{   \n    return v1.x * v2.x + v1.y * v2.y;\n}\n\ndouble Vector_norm(Vector v) \n{\n    return sqrt(Vector_dot(v, v));\n}\n\ndouble Vector_angle(Vector v1, Vector v2)\n{\n\n    double scalp;\n    scalp = Vector_dot(v1, v2);\n    assert(!(scalp != scalp));\n    \n    double lenp;\n    lenp = (v1.len * v2.len);\n    assert(lenp >= 0);\n\n    if (Util_is_zero(lenp)) {\n        Util_runtime_error(\"Vector_angle: Division by zero\");\n    }\n    if (scalp != scalp) Util_runtime_error(\"angle: Nan scalp\");\n    if (\n            Util_equal(scalp, lenp) || \n            Util_equal(scalp, -lenp) || \n            Util_equal(-scalp, lenp)\n        )\n    {\n        return 0.0;\n    }\n\n    double div;\n    div = scalp / lenp;\n    if (Util_equal(div, 1.0) || Util_equal(div, -1.0)) \n        return 0.0;\n    if (!Util_in_range(-1.0, 1.0, div)) {\n        Util_runtime_error(\"Outside acos range\"); \n    }\n    return acos(div);\n}\n\nint Vector_parallel(Vector v1, Vector v2)\n{\n    return Util_equal(Vector_angle(v1, v2), 0);\n}\n\nint Vector_Util_equal(Vector v1, Vector v2)\n{\n    return Util_equal(v1.x, v2.x) && Util_equal(v1.y, v2.y);\n}\n\n/**\n * Magnitude of the vector that would result from a regular 3D space. \n */\n\ndouble Vector_cross(Vector vec1, Vector vec2)\n{\n    return (vec1.x * vec2.y) - (vec2.x * vec1.y);\n}\n\n","/*****************************************************************************\n\n* File Name: vertex.c\n\n* Author: Ludvpig Sundström\n\n* Description: \n\n* Creation Date: 28-07-2015\n\n*****************************************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n\n#include \"util.h\"\n#include \"vertex.h\"\n#include \"constants.h\"\n\n/* Private ******************************************************************/\n\nstatic Vector center_distance(const VertexPointer vp) \n{\n    int cx, cy;\n    cx = PANEL_X / 2; cy = PANEL_Y / 2;\n    Vector rtn;\n    rtn = Vector_initialize((double) cx - vp->pos.x, (double) cy - vp->pos.y);\n    return rtn;\n}\n\nstatic double potential_weight(const VertexPointer vp) \n{\n    return WPOT;\n}\n\n\n/* Public  ******************************************************************/\n\nint Vertex_zone_idx(const VertexPointer v)\n{\n    int rtn;\n    if (v->pos.x >= PANEL_X) {\n        rtn = PANEL_X / PADDING - 1;\n    } else if (v->pos.x <= 0) {\n        rtn = 0;\n    } else {\n        rtn = ((int) v->pos.x) / PADDING;\n    }\n    return rtn; \n}\n\nint Vertex_zone_idy(const VertexPointer v)\n{\n    int rtn;\n    if (v->pos.y >= PANEL_Y) {\n        rtn = PANEL_Y / PADDING - 1;\n    } else if (v->pos.y <= 0) {\n        rtn = 0;\n    } else {\n        rtn = ((int) v->pos.y) / PADDING;\n    }\n    return rtn;\n}\n\nvoid Vertex_reset_dynamics(const VertexPointer v) \n{\n    v->next = NULL;\n}\n\nVertexPointer Vertex_create(\n       const int id, \n       const Vector pos, const Vector grad, const Vector g, const Vector h,\n       const double wdth, \n       const double hght, \n       const char type, \n       const int nv) \n{\n    VertexPointer rtn;\n    rtn = Util_allocate_initialize(1, sizeof(Vertex));\n    rtn->id = id;\n    rtn->mass = 1;\n    rtn->pos = pos;\n    rtn->tl = Vector_sub(pos, Vector_initialize((PADDING + wdth) / 2, \n                (PADDING + hght) / 2));\n    rtn->br = Vector_add(pos, Vector_initialize((PADDING + wdth) / 2, \n                (PADDING + hght) / 2));\n    rtn->type = type;\n    rtn->crs_bof = (int *) calloc(nv, sizeof(int));\n    Vertex_reset_dynamics(rtn);\n    return rtn;\n}\n\nvoid Vertex_move(const VertexPointer v, const Vector ds) \n{\n    Vector new_pos;\n    new_pos = Vector_add(v->pos0, ds);\n\n    v->pos.x = new_pos.x;\n    v->pos.y = new_pos.y;\n\n    v->tl.x = new_pos.x - (PADDING / 2);\n    v->tl.y = new_pos.y - (PADDING / 2);\n\n    v->br.x = new_pos.x + (PADDING / 2);\n    v->br.y = new_pos.y + (PADDING / 2);\n}\n\ndouble Vertex_potential_energy(const VertexPointer vp) \n{\n    Vector cdist;\n    cdist = center_distance(vp);\n\n    double w;\n    w = potential_weight(vp);\n    \n    return w * pow(Vector_norm(cdist), 2);\n}\n\nVector Vertex_potential_gradient(const VertexPointer vp)\n{\n    Vector cdist;\n    cdist = center_distance(vp);\n\n    double w;\n    w = potential_weight(vp);\n\n    return Vector_scalar_mult(cdist, 2 * w);\n}\n\nvoid Vertex_free(VertexPointer vp)\n{\n    free(vp->crs_bof);\n    free(vp);\n}\n\n","/*****************************************************************************\n\n* File Name: vertex_pair.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 31-07-2015\n\n*****************************************************************************/\n\n#include \"math.h\"\n#include \"constants.h\"\n#include \"vertex.h\"\n#include \"pair.h\"\n\n/* Private ******************************************************************/\n\nstatic double repulsion_weight(const Pair pr) \n{\n    return 2 * WREP;\n}\n\n/* Public *******************************************************************/\n\ndouble VertexPair_repulsion_energy(const Pair pr) \n{\n    double w;\n    w = repulsion_weight(pr);\n\n    VertexPointer vp0, vp1;\n    vp0 = (VertexPointer) pr.fst;\n    vp1 = (VertexPointer) pr.snd;\n\n    int cb;\n    cb = *(vp0->crs_bof + vp1->id);\n    if (cb) {\n        w *= REPULSION_REDUCE;\n    }\n    \n    double i_tl_x, i_tl_y, i_br_x, i_br_y;\n    i_tl_x = fmax(vp0->tl.x, vp1->tl.x);\n    i_tl_y = fmax(vp0->tl.y, vp1->tl.y);\n    i_br_x = fmin(vp0->br.x, vp1->br.x);\n    i_br_y = fmin(vp0->br.y, vp1->br.y);\n\n    if (i_tl_x > i_br_x || i_tl_y > i_br_y) {\n        return 0;\n    } else {\n        double i_dx, i_dy;\n        i_dx = i_br_x - i_tl_x;\n        i_dy = i_br_y - i_tl_y;\n        return w * pow(i_dx * i_dy, 2);\n    }\n}\n\nVector VertexPair_repulsion_gradient(const Pair pr)\n{\n    double w;\n    w = repulsion_weight(pr);\n\n    VertexPointer vp0, vp1;\n    vp0 = (VertexPointer) pr.fst;\n    vp1 = (VertexPointer) pr.snd;\n\n    int cb;\n    cb = *(vp0->crs_bof + vp1->id);\n    if (cb) {\n        w *= REPULSION_REDUCE;\n    }\n\n    double i_tl_x, i_tl_y, i_br_x, i_br_y;\n    i_tl_x = fmax(vp0->tl.x, vp1->tl.x);\n    i_tl_y = fmax(vp0->tl.y, vp1->tl.y);\n    i_br_x = fmin(vp0->br.x, vp1->br.x);\n    i_br_y = fmin(vp0->br.y, vp1->br.y);\n\n    Vector frc;\n\n    if (i_tl_x > i_br_x || i_tl_y > i_br_y) {\n        return Vector_zero();\n    } else {\n        double i_dx, i_dy;\n        i_dx = i_br_x - i_tl_x;\n        i_dy = i_br_y - i_tl_y;\n        if (vp0->pos.x < vp1->pos.x) {\n            frc.x = -2 * i_dx * pow(i_dy, 2);\n        } else {\n            frc.x = 2 * i_dx * pow(i_dy, 2);\n        } \n        if (vp0->pos.y < vp1->pos.y) {\n            frc.y = -2 * i_dy * pow(i_dx, 2);\n        } else {\n            frc.y = 2 * i_dy * pow(i_dx, 2);\n        } \n    }\n\n    return Vector_scalar_mult(frc, w);\n}\n\n","/*****************************************************************************\n\n* File Name: vertex_set.c\n\n* Author: Ludvig Sundström\n\n* Description: Represents a set of vertices\n\n* Creation Date: 31-07-2015\n\n*****************************************************************************/\n\n#include <stdlib.h>\n\n#include \"util.h\"\n#include \"constants.h\"\n#include \"vertex_set.h\"\n\nVertexSet VertexSet_initialize(json_value *contents, int *nvp)\n{\n    json_value *vsarr = contents->u.object.values[0].value;\n    *nvp = vsarr->u.array.length;\n\n    int nv;\n    nv = *nvp;\n\n    VertexSet rtn;\n    rtn.set = (VertexPointer *) Util_allocate(nv, sizeof(VertexPointer));\n    rtn.n = nv;\n\n    if (nv < 1) {\n        Util_runtime_error(\"No vertices\");\n    }\n\n    int i;\n    for (i = 0; i < nv; i++) {\n        \n        json_value *vertex;  \n        vertex = vsarr->u.array.values[i];\n\n        json_value *ident;\n        int id;\n        id = -99;\n        ident = vertex->u.object.values[0].value;\n        if (ident->type == json_integer) {\n            id = ident->u.integer;\n        } else {\n            Util_runtime_error(\"Bad JSON data: ident\");\n        }\n\n        Vector pos, zv;\n        zv = Vector_zero();\n        pos = zv;    \n        json_value *position;\n        position = vertex->u.object.values[1].value;\n        if (position->type == json_array) {\n            int length;\n            double x, y;\n            x = y = 0;\n            length = position->u.array.length;\n            if (length != 2) {\n                Util_runtime_error(\"Bad JSON data, position dimension not 2\");\n            }\n            json_value *j_x = position->u.array.values[0];\n            json_value *j_y = position->u.array.values[1];\n            if (j_x->type == json_integer) {\n                x = (double) j_x->u.integer;\n            } else if (j_x->type == json_double) {\n                x = (double) j_x->u.dbl;\n            } else {\n                Util_runtime_error(\"Bad JSON data: position: x\");\n            }\n            if (j_y->type == json_integer) {\n                y = (double) j_y->u.integer;\n            } else if (j_x->type == json_double) {\n                y = (double) j_y->u.dbl;\n            } else {\n                Util_runtime_error(\"Bad JSON data: position: y\");\n            }\n            pos = Vector_initialize(x, y);\n            pos.given_coords = 1;\n        } \n        else {\n            if (position->type != json_null) {\n                Util_runtime_error(\"Bad JSON data: position\");\n            }\n        }\n\n        char t;\n        t = 0;\n        json_value *vertex_type;\n        vertex_type = vertex->u.object.values[3].value;\n        if (vertex_type->type == json_string) {\n            t = vertex_type ->u.string.ptr[0];\n        } else {\n            Util_runtime_error(\"Bad JSON data: type\");\n        }\n\n        *(rtn.set + i) = Vertex_create(id, pos, zv, zv, zv,\n                VERTEX_BASE_WIDTH, VERTEX_BASE_HEIGHT, t, nv);\n    }\n    return rtn;\n}\n\nVertexSetPointer VertexSet_create(json_value *contents, int *nvp)\n{\n    VertexSetPointer rtn;\n    rtn = (VertexSetPointer) malloc(sizeof(VertexSet));\n    *rtn = VertexSet_initialize(contents, nvp);\n    return rtn;\n}\n\nvoid VertexSet_sort(VertexPointer *vquad, Vector cross) \n{\n    int i;\n    for (i = 0; i < 3; i++) {\n        int j;\n        for (j = i + 1; j < 4; j++) {\n            VertexPointer vpi = *(vquad + i);\n            VertexPointer vpj = *(vquad + j);\n            if (vpj->mass < vpi->mass) {\n                VertexPointer tmp = vquad[i];\n                vquad[i] = vquad[j];\n                vquad[j] = tmp;\n            } else if (vpj->mass == vpi->mass) {\n                double di, dj;\n                di = Vector_norm(Vector_sub(cross, vpi->pos));\n                dj = Vector_norm(Vector_sub(cross, vpj->pos));\n                if (dj < di) {\n                    VertexPointer tmp = vquad[i];\n                    vquad[i] = vquad[j];\n                    vquad[j] = tmp;\n                }\n            }\n        }\n    }\n}\n\nvoid VertexSet_move(const VertexSet vs, const VectorPointer gradient, double x)\n{\n    int i;   \n    for (i = 0; i < vs.n; i++) {\n        VertexPointer v = *(vs.set + i);\n        Vector ds;\n        ds = Vector_scalar_mult(gradient[i], x);\n        Vertex_move(v, ds);\n    }\n}\n\nfloat *VertexSet_to_array(const VertexSet vs)\n{\n    float *rtn = (float *) Util_allocate(vs.n * 2, sizeof(double));\n    int i;\n    for (i = 0; i < vs.n; i++) {\n        *(rtn + i * 2) = (float) (*(vs.set + i))->pos.x;\n        *(rtn + i * 2 + 1) = (float) (*(vs.set + i))->pos.y;\n    }\n    return rtn;\n\n}\n\nvoid VertexSet_free(VertexSet vs) \n{\n    int i;\n    for (i = 0; i < vs.n; i++) {\n        Vertex_free(*(vs.set + i));\n    }\n    free(vs.set);\n}\n\n\n","/*****************************************************************************\n\n* File Name: zone2d.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 24-07-2015\n\n*****************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"zone.h\"\n\nZonePointer Zone_create(\n        const int id, \n        const int i, \n        const int j, \n        const double minx,\n        const double miny, \n        const double width, \n        const double height\n    )\n{\n    ZonePointer rtn = malloc(sizeof(Zone));\n    rtn->id = id;\n    rtn->i = i;\n    rtn->j = j;\n    rtn->minx = minx; rtn->miny = miny;\n    rtn->width = width; rtn->height = height;\n    return rtn;\n}\n\n\nvoid Zones_free(ZonePointer *zs, int nz) \n{\n    int i;\n    for (i = 0; i < nz; i++) {\n        free(*(zs + i));\n    }\n    zs = NULL;\n}\n\n","/*****************************************************************************\n\n* File Name: zone_pair.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 31-07-2015\n\n*****************************************************************************/\n\n#include <stdlib.h>\n\n#include \"pair.h\"\n#include \"zone_pair.h\"\n\nZonePairPointer ZonePair_create(const Pair pr, const ZonePairPointer next)\n{\n    ZonePairPointer rtn = (ZonePairPointer) malloc(sizeof(ZonePair));\n    rtn->fst = (ZonePointer) pr.fst;\n    rtn->snd = (ZonePointer) pr.snd;\n    rtn->next = next;\n    return rtn;\n}\n\nvoid ZonePairs_free(ZonePairPointer z2p)\n{\n    ZonePairPointer cur = z2p;\n    while(cur != NULL) {\n        ZonePairPointer tmp = cur;\n        cur = cur->next;\n        free(tmp);\n    }\n}\n\n"]}