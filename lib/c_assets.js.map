{"version":3,"file":"lib/c_assets.js","sources":["lib/c/brent.c","lib/c/mnbrak.c","lib/c/objective.c","lib/c/util.c","lib/c/minimizer.c","lib/c/frprmn.c","lib/c/get_clustersizes.c","lib/c/linmin.c","lib/c/json.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;AAAA;AACA;AAAA;AAEA;AAGA;;;AADA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A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","sourcesContent":["/*****************************************************************************\n * Author : Ludvig Sundström\n *\n * File Name : brent.c\n *\n * Purpose : \n *\n * Creation Date : 25-06-2015\n *\n *****************************************************************************/\n\n#include <math.h>\n#include \"util.h\"\n\n#define ITMAX 100\n#define CGOLD 0.3819660\n#define ZEPS 1.0e-10\n\nfloat brent(float ax, float bx, float cx, float (*f)(float), float tol,\n        float *xmin)\n{\n    int iter;\n    float a,b,d,etemp,fu,fv,fw,fx,p,q,r,tol1,tol2,u,v,w,x,xm;\n    float e=0.0;\n    void rt_error(); \n\n    a=(ax < cx ? ax : cx);\n    b=(ax > cx ? ax : cx);\n    x = w = v = bx;\n    fw=fv=fx=(*f)(x);\n    for (iter = 1;iter <= ITMAX; iter++) {\n        xm = 0.5 * (a + b);\n        tol2 = 2.0 * (tol1 = tol * fabs(x) + ZEPS);\n        if (fabs(x-xm) <= (tol2-0.5*(b-a))) {\n            *xmin=x;\n            return fx;\n        }\n        if (fabs(e) > tol1) {\n            r = (x - w) * (fx - fv);\n            q =(x - v) * (fx - fw);\n            p = (x - v) * q - (x - w) * r;\n            q = 2.0 * (q - r);\n            if (q > 0.0) p = -p;\n            q=fabs(q);\n            etemp=e;\n            e=d;\n            if (fabs(p) >= fabs(0.5*q*etemp) || p <= q*(a-x) || p >= q*(b-x))\n                d=CGOLD*(e=(x >= xm ? a-x : b-x));\n            else {\n                d=p/q;\n                u=x+d;\n                if (u-a < tol2 || b-u < tol2)\n                    d=SIGN(tol1,xm-x);\n            }\n        } else {\n            d=CGOLD*(e=(x >= xm ? a-x : b-x));\n        }\n        u=(fabs(d) >= tol1 ? x+d : x+SIGN(tol1,d));\n        fu=(*f)(u);\n        if (fu <= fx) {\n            if (u >= x) a=x; else b=x;\n            SHFT(v,w,x,u)\n                SHFT(fv,fw,fx,fu)\n        } else {\n            if (u < x) a=u; else b=u;\n            if (fu <= fw || w == x) {\n                v=w;\n                w=u;\n                fv=fw;\n                fw=fu;\n            } else if (fu <= fv || v == x || v == w) {\n                v=u;\n                fv=fu;\n            }\n        }\n    }\n    rt_error(\"Too many iterations in brent\");\n    *xmin=x;\n    return fx;\n}\n\n#undef ITMAX\n#undef CGOLD\n#undef ZEPS\n#undef SHFT\n","\n#include <math.h>\n#include \"util.h\"\n\n#define GOLD 1.618034\n#define GLIMIT 100.0\n#define TINY 1.0e-20\n\nvoid mnbrak(float *ax, float *bx, float *cx, float *fa, float *fb, \n        float *fc, float (*func)())\n{\n    float ulim,u,r,q,fu,dum;\n\n    *fa=(*func)(*ax);\n    *fb=(*func)(*bx);\n    if (*fb > *fa) {\n        SHFT(dum,*ax,*bx,dum)\n            SHFT(dum,*fb,*fa,dum)\n    }\n    *cx=(*bx)+GOLD*(*bx-*ax);\n    *fc=(*func)(*cx);\n    while (*fb > *fc) {\n        r=(*bx-*ax)*(*fb-*fc);\n        q=(*bx-*cx)*(*fb-*fa);\n        u=(*bx)-((*bx-*cx)*q-(*bx-*ax)*r)/ (2.0*SIGN(MAX(fabs(q-r),TINY),q-r));\n        ulim=(*bx)+GLIMIT*(*cx-*bx);\n        if ((*bx-u)*(u-*cx) > 0.0) {\n            fu=(*func)(u);\n            if (fu < *fc) {\n                *ax=(*bx);\n                *bx=u;\n                *fa=(*fb);\n                *fb=fu;\n                return;\n            } else if (fu > *fb) {\n                *cx=u;\n                *fc=fu;\n                return;\n            }\n            u=(*cx)+GOLD*(*cx-*bx);\n            fu=(*func)(u);\n        } else if ((*cx-u)*(u-ulim) > 0.0) {\n            fu=(*func)(u);\n            if (fu < *fc) {\n                SHFT(*bx,*cx,u,*cx+GOLD*(*cx-*bx))\n                    SHFT(*fb,*fc,fu,(*func)(u))\n            }\n        } else if ((u-ulim)*(ulim-*cx) >= 0.0) {\n            u=ulim;\n            fu=(*func)(u);\n        } else {\n            u=(*cx)+GOLD*(*cx-*bx);\n            fu=(*func)(u);\n        }\n        SHFT(*ax,*bx,*cx,u)\n        SHFT(*fa,*fb,*fc,fu)\n    }\n}\n\n#undef GOLD\n#undef GLIMIT\n#undef TINY\n#undef MAX\n#undef SIGN\n#undef SHFT\n","/*****************************************************************************\n\n* File Name: objective.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 05-07-2015\n\n*****************************************************************************/\n\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define PADDING 10.0f\n#define WR 1.0f\n\nstatic int dim, nv, elen;\nstatic float *fdm, *ml, *rl, *w0;\n\nstruct vertex {\n    struct vertex *neighbors;\n};\n\nvoid setGlobals(float *distanceMatrix, float *massList, float *radiusList,\n        float *edgeMassMatrix, int dimension, int nVertices, int edgeLength) \n{\n    fdm = distanceMatrix;\n    ml = massList;\n    rl = radiusList;\n    w0 = edgeMassMatrix;\n    dim = dimension;\n    nv  = nVertices;\n    elen = edgeLength;\n}\n\nfloat attr1(float p[]) {\n    return 0.0;\n}\nfloat rep1() {\n    return 0.0;\n}\n\nfloat f2(float p[]) \n{\n    int i, j, ij;\n    float rtn, ri, rj, d0ij, wij, dx, dy, dij, critlen;\n    rtn = 0;\n    for (i = 0; i < dim - 1; i += 2) {\n        for (j = i + 2; j < dim; j += 2) {\n            ij = (i / 2) * nv + (j / 2);\n            ri = rl[i / 2];\n            rj = rl[j / 2];\n            wij = ml[i / 2] * ml[j / 2] * w0[ij];\n            d0ij = fdm[ij] * elen;\n            dx = p[i] - p[j];\n            dy = p[i + 1] - p[j + 1];\n            dij = (float) sqrt(dx * dx + dy * dy);\n            if (fabs(dij) <  0.01) {\n                dij = 0.01;\n            } \n            critlen = ri + rj + PADDING;\n            if (ri + rj + PADDING > dij) {\n                rtn += WR * pow(critlen - dij, 2);\n            }\n            // Need to filter out only connected vertices here TODO\n            rtn += wij * (float) pow(dij - d0ij, 2);\n        }\n    }\n    return rtn;\n}\n\nfloat f1(float p[]) \n{\n    // Repulsion (from walls) TODO\n    return attr1(p) + rep1();\n}\n\nfloat f3() \n{\n    // Angular resolution TODO\n    return 0.0;\n}\n\nfloat f4() \n{\n    // Edge crossings TODO\n    return 0.0;\n}\n\nfloat f(float p[]) \n{\n    return f1(p) + f2(p) + f3() + f4();\n}\n\nvoid df2(float p[], float df[]) \n{\n    int i, j, ij; float wij, d0ij, dij, dx, dy, ri, rj, critlen, forcexattr,\n        forceyattr, forcexrep, forceyrep;\n    for (i = 0; i < dim; i += 2) {\n        for (j = i + 2; j < dim; j += 2) {\n            ij = (i / 2) * nv + (j / 2);\n            wij = ml[i / 2] * ml[j / 2] * w0[ij];\n            d0ij = fdm[ij] * elen;\n            dx = p[i] - p[j];\n            dy = p[i + 1] - p[j + 1]; \n            ri = rl[i / 2];\n            rj = rl[j / 2];\n            dij = (float) sqrt(dx * dx + dy * dy);\n            if (fabs(dij) <  0.01) {\n                dij = 0.01;\n            } \n            critlen = ri + rj + PADDING;\n            \n            // Need to filter out the actual connected nodes here TODO\n            forcexattr = -2 * wij * dx * (dij - d0ij) / dij;\n            forceyattr = -2 * wij * dy * (dij - d0ij) / dij;\n\n            if (ri + rj + PADDING > dij) {\n                forcexrep = -2 * WR * dx * (critlen - dij) / dij;\n                forceyrep = -2 * WR * dy * (critlen - dij) / dij;\n            }\n\n            df[i]     += (forcexattr + forcexrep);\n            df[i + 1] += (forceyattr + forceyrep);\n            df[j]     -= (forcexattr + forcexrep);\n            df[j + 1] -= (forceyattr + forceyrep); \n        }\n    }\n}\n\nvoid df(float p[], float df[]) \n{\n    df2(p, df);\n}\n\n","/*****************************************************************************\n\n * Author : Ludvig Sundström\n\n * File Name : util.c\n\n * Purpose : \n\n * Creation Date : 26-06-2015\n\n * Last Modified : \n\n *****************************************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n\nvoid rt_error(char error_text[])\n{\n    fprintf(stderr,\"Run-time error...\\n\");\n    fprintf(stderr,\"%s\\n\",error_text);\n    fprintf(stderr,\"...now exiting to system...\\n\");\n    exit(1);\n}\n\nfloat *vector(long n) \n{\n    float *v;\n    v = (float *) malloc((size_t) (n * sizeof(float)));\n    if (v == NULL) {\n        rt_error(\"error while allocating memory\");\n    }\n    return v;\n}\n","/*****************************************************************************\n\n * Author: Ludvig Sundström\n\n * File Name: minimizer.c\n\n * Description: Defines an energy function and its derivatives aswell as\n * working as minimize() which is the exported function by emscripten.\n\n * Creation Date: 24-06-2015\n\n *****************************************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n\n#include \"util.h\"\n#include \"frprmn.h\"\n#include \"objective.h\"\n#include \"get_clustersizes.h\"\n\n#define STIFFNESS 100\n#define SPRING_LENGTH 500\n#define FTOL 0.00001\n#define MIN_DIST 0.1\n#define PRECISION_DIGITS 8\n#define DEFAULT_MASS 1.0\n#define DEFAULT_RADIUS 1.0\n\n// fdm the distance matrix - len nv * nv\n// w0 the bond weight matrix - len nv * nv\n// ml the mass list - len nv\n// rl the radius list - len nv\n\nfloat *fdm, *w0, *ml, *rl;\n\nint dim, nv, elen, spanx, spany, pox, poy;\n\nvoid initW0() \n{ \n    int i;\n    for (i = 0; i < nv * nv; i++) {\n        w0[i] = STIFFNESS;\n    }\n}\nvoid initML() \n{ \n    int i;\n    for (i = 0; i < nv; i++) {\n        ml[i] = DEFAULT_MASS;\n    }\n}\nvoid initRL(int customSizes, const char *ssFilename) \n{ \n    if (customSizes) {\n        get_sizes(rl, ssFilename, nv);\n    } else {\n        int i;\n        for (i = 0; i < nv; i++) {\n            rl[i] = DEFAULT_RADIUS;\n        }\n    }\n}\n\nvoid initDMT(const char *fname) \n{\n    FILE *fp;\n    char *pend, *p, *buf;\n    int i, j, ij;\n\n    const long rowMaxLen = (PRECISION_DIGITS + 3) * nv;\n\n    buf = malloc(sizeof(char) * rowMaxLen);\n    fp = fopen(fname, \"r\"); \n\n    if (buf == NULL) {\n        rt_error(\"error in getDMT while allocating memory\");\n    }\n    if (fp == NULL) {\n        printf(\"Error while opening file: %s for reading\", fname);\n        rt_error(\"Error...\");\n    }\n\n    for (i = 0; i < nv; i++) {\n        fgets(buf, rowMaxLen, fp);\n        p = buf;\n        for (j = 0; j < nv; j++) {\n            ij = j + (i * nv);\n            fdm[ij] = strtof(p, &pend);\n            if (fabs(fdm[ij]) < MIN_DIST) {\n                fdm[ij] = MIN_DIST;\n            }\n            p = pend + 1;\n        }\n    }\n\n    fclose(fp);\n    free(buf);\n}\n\nvoid initFPS(float *ps) \n{\n    int i, n, vdim;\n    float gapx, gapy, offsetx, offsety;\n    n = nv; \n    while (fabs(sqrt(n) - (int) sqrt(n)) > 0.01) {\n        n++;\n    }\n    vdim = sqrt(n);\n    gapx = spanx / vdim;\n    gapy = spany / vdim;\n    offsetx = gapx / 2;\n    offsety = gapy / 2;\n    int rows = 0;\n    int cols = -1;\n    for (i = 0; i < dim; i += 2) {\n        if (i % (vdim * 2) == 0) {\n            rows++;\n            cols = 0;\n        }\n        ps[i] = cols * gapx + offsetx + pox;\n        ps[i + 1] = rows * gapy + offsety + poy; \n        cols++;\n    }\n}\n\nfloat (*func)(float []) = f;\nvoid (*dfunc)(float [], float []) = df;\n\nint minimize (const char *dmtFilename, const char *ssFilename, float *flatpos,\n        const int len, const int panelx, const int panely,\n        const int panelOffsetX, const int panelOffsetY, const float fact) {\n    int *iter;\n    float *fret;\n\n    int customSizes = strcmp(ssFilename, \"noCustomSizes\") != 0;\n\n    pox = panelOffsetX;\n    poy = panelOffsetY;\n    spanx = panelx * fact;\n    spany = panely * fact;\n    elen = SPRING_LENGTH * fact;\n\n    dim = len;\n    nv = len / 2;\n\n    fdm = malloc(sizeof(float) * (nv * nv));\n    w0 = malloc(sizeof(float) * (nv * nv));\n    ml = malloc(sizeof(float) * nv);\n    rl = malloc(sizeof(float) * nv);\n\n    iter = malloc(sizeof(int));\n    fret = malloc(sizeof(float));\n\n    if (iter == NULL || fret == NULL || fdm == NULL) {\n        rt_error(\"Error in minimize when allocating memory\");\n    }\n    \n    initDMT(dmtFilename);\n    initFPS(flatpos);\n    initW0();\n    initML();\n    initRL(customSizes, ssFilename);\n    setGlobals(fdm, ml, rl, w0, dim, nv, elen);\n\n    frprmn(flatpos, dim, FTOL, iter, fret, func, dfunc);\n    \n    free(fret);\n    free(iter);\n    free(rl);\n    free(ml);\n    free(w0);\n    free(fdm);\n\n    return 0;\n}\n\n\n","/*****************************************************************************\n\n * Author : Numerical recepies in C, modiefied by Ludvig Sundström\n\n * File Name : frprmn.c\n\n * Purpose : Performs Fletcher-Reeves-Polak-Ribiere minimization\n\n * Creation Date : 25-06-2015\n\n *****************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#include \"util.h\"\n#include \"linmin.h\"\n\n#define ITMAX 200\n#define EPS 1.0e-10\n#define FREEALL free(xi);free(h);free(g);\n\n/** \n * Given a starting point p, performs minimization on a function func using its\n * gradient calculated by dfunc. The convergence tolerance of func is ftol.\n * Returned quatities are p - the location of the minimum, iter - the number of\n * iterations performed and fret - the minimum value of value. \n * Calls routine linmin to perform line minimizations.\n */\nvoid frprmn(float p[], int n, float ftol, int *iter, float *fret, \n        float (*func)(), void (*dfunc)(float [], float []))\n{\n    int j, its;\n    float gg, gam, fp, dgg;\n    float *g, *h, *xi;\n\n    g = vector(n);\n    h = vector(n);\n    xi = vector(n);\n    fp = (*func)(p);\n    (*dfunc)(p, xi);\n    for (j = 0; j < n; j++) {\n        g[j] = -xi[j];\n        xi[j] = h[j] = g[j];\n    }\n    for (its = 0; its < ITMAX; its++) {\n        *iter = its;\n        linmin(p, xi, n, fret, func);\n        if (2.0 * fabs(*fret - fp) <= ftol * (fabs(*fret) + fabs(fp) + EPS)) {\n            FREEALL\n                return;\n        }\n        fp = (*func)(p);\n        (*dfunc)(p, xi);\n        dgg = gg = 0.0;\n        for (j = 0; j < n; j++) {\n            gg += g[j] * g[j];\n            dgg += (xi[j] + g[j]) * xi[j];\n        }\n        if (fabs(gg) < EPS) {\n            FREEALL\n                return;\n        }\n        gam = dgg / gg;\n        for (j = 0; j < n; j++) {\n            g[j] = -xi[j];\n            xi[j] = h[j] = g[j] + gam * h[j];\n        }\n    }\n    FREEALL\n        rt_error(\"Too many iterations in frprmn()\");\n}\n\n#undef ITMAX\n#undef EPS\n#undef FREEALL\n\n","/*****************************************************************************\n\n * Author: Ludvig Sundström\n\n * File Name: getSizes.c\n\n * Description: \n\n * Creation Date: 02-07-2015\n\n *****************************************************************************/\n\n#include <stdio.h>\n#include <math.h>\n#include <sys/stat.h>\n#include \"json.h\"\n\nvoid norm(float *arr, int length) {\n    int i;\n    double sum;\n    sum = 0.0; \n    for (i = 0; i < length; i++) {\n        sum += pow(arr[i], 2);\n    }\n    double len = sqrt(sum);\n    for (i = 0; i < length; i++) {\n        arr[i] /= len;\n    }\n}\n\nvoid sort(float *rtn, float *sizes, int length) {\n    int iter; \n    int index = 1;\n    for (index = 1; index <= length; index++) {\n        for (iter = 0; iter < length; iter++) {\n            if (sizes[iter * 2] == index) {\n                rtn[index - 1] = sizes[iter * 2 + 1];\n                break;\n            }\n        }\n    }\n    free(sizes);\n}\n\nstatic int get_intval(json_value* value, int depth) \n{\n    return value->u.integer;\n}\n\nstatic void fill_arr(float *sizes, json_value* value, int ntotal, int depth)\n{\n    if (value == NULL) {\n        return;\n    }\n    int i, n, v, length;\n\n    length = value->u.array.length;  \n\n    for (i = 0; i < length; i++) {\n        json_value *obj= value->u.array.values[i];\n        n = get_intval(obj->u.object.values[0].value, depth+1);\n        v = get_intval(obj->u.object.values[1].value, depth+1);\n        sizes[i * 2] = n;\n        sizes[i * 2 + 1] = v;\n    }\n}\n\nint get_sizes(float *fss, const char *filename, int nv) {\n\n    FILE *fp;\n    struct stat filestatus;\n    int file_size;\n    char* file_contents;\n    json_char* json;\n    json_value* value;\n\n    if (stat(filename, &filestatus) != 0) {\n        fprintf(stderr, \"File %s not found\\n\", filename);\n        return 1;\n    }\n\n    file_size = filestatus.st_size;\n    file_contents = (char*)malloc(filestatus.st_size);\n    if ( file_contents == NULL) {\n        fprintf(stderr, \"Memory error: unable to allocate %d bytes\\n\", \n                file_size);\n        return 1;\n    }\n\n    fp = fopen(filename, \"rt\");\n    if (fp == NULL) {\n        fprintf(stderr, \"Unable to open %s\\n\", filename);\n        fclose(fp);\n        free(file_contents);\n        return 1;\n    }\n\n    if (fread(file_contents, file_size, 1, fp) != 1 ) {\n        fprintf(stderr, \"Unable t read content of %s\\n\", filename);\n        fclose(fp);\n        free(file_contents);\n        return 1;\n    }\n    fclose(fp);\n\n    json = (json_char*)file_contents;\n    value = json_parse(json,file_size);\n    if (value == NULL) {\n        fprintf(stderr, \"Unable to parse data\\n\");\n        free(file_contents);\n        exit(1);\n    }\n\n    float *sizes = malloc(sizeof(float) * nv * 2); \n\n    fill_arr(sizes, value, nv, 0);\n\n    sort(fss, sizes, nv);\n    /*norm(fss, nv);*/\n\n    json_value_free(value);\n\n    free(file_contents);\n\n    return 0;\n\n}\n\n","/*****************************************************************************\n\n * Author: Numerical recepies in C, modified by Ludvig Sundström\n\n * File Name: linmin.c\n\n * Description: Performs line minimization.\n\n * Creation Date: 25-06-2015\n\n *****************************************************************************/\n\n#include <stdlib.h>\n\n#define TOL 2.0e-4 \n\nint ncom; \nfloat *pcom, *xicom, (*nrfunc)(float []);   \n\n/*  Given an n-dimensional point p[1..n] and an n-dimensional direction\n    xi[1..n], moves and resets p to where the function func(p) takes on a\n    minimum along the direction xi from p, and replaces xi by the actual\n    vector displacement that p was moved. Also returns as fret the value\n    of func at the returned location p. This is actually all accomplished\n    by calling the routines mnbrak and brent.  \n    */   \nvoid linmin(float p[], float xi[], int n, float *fret, float (*func)())   \n{   \n    float brent(float ax, float bx, float cx,   \n            float (*f)(float), float tol, float *xmin);   \n    float f1dim(float x);   \n    void mnbrak(float *ax, float *bx, float *cx, float *fa, float *fb,   \n            float *fc, float (*func)(float));   \n    int i;   \n    float *vector();\n    float xx, xmin, fx, fb, fa, bx, ax;   \n    ncom = n; \n    pcom = vector(n);   \n    xicom = vector(n);   \n    nrfunc = func;   \n    for (i = 0; i < n; i++) {   \n        pcom[i] = p[i];   \n        xicom[i] = xi[i];   \n    }   \n    ax = 0.0; \n    xx = 1.0;   \n    mnbrak(&ax, &xx, &bx, &fa, &fx, &fb, f1dim);   \n    *fret = brent(ax, xx, bx, f1dim, TOL, &xmin);   \n    for (i=0; i<n; i++) { \n        xi[i] *= xmin;   \n        p[i] += xi[i];   \n    }   \n    free(xicom);\n    free(pcom);\n}   \n\nfloat f1dim(float x)   \n{   \n    float *vector();\n    int i;   \n    float f, *xt;   \n    xt = vector(ncom);   \n    for (i = 0; i <ncom; i++) {\n        xt[i] = pcom[i] + x * xicom[i];   \n    }\n    f = (*nrfunc)(xt);   \n    free(xt);\n    return f;   \n}  \n\n","/* vim: set et ts=3 sw=3 sts=3 ft=c:\n *\n * Copyright (C) 2012, 2013, 2014 James McLaughlin et al.  All rights reserved.\n * https://github.com/udp/json-parser\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *   notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"json.h\"\n\n#ifdef _MSC_VER\n#ifndef _CRT_SECURE_NO_WARNINGS\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n#endif\n\nconst struct _json_value json_value_none;\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\ntypedef unsigned int json_uchar;\n\nstatic unsigned char hex_value (json_char c)\n{\n    if (isdigit(c))\n        return c - '0';\n\n    switch (c) {\n        case 'a': case 'A': return 0x0A;\n        case 'b': case 'B': return 0x0B;\n        case 'c': case 'C': return 0x0C;\n        case 'd': case 'D': return 0x0D;\n        case 'e': case 'E': return 0x0E;\n        case 'f': case 'F': return 0x0F;\n        default: return 0xFF;\n    }\n}\n\ntypedef struct\n{\n    unsigned long used_memory;\n\n    unsigned int uint_max;\n    unsigned long ulong_max;\n\n    json_settings settings;\n    int first_pass;\n\n    const json_char * ptr;\n    unsigned int cur_line, cur_col;\n\n} json_state;\n\nstatic void * default_alloc (size_t size, int zero, void * user_data)\n{\n    return zero ? calloc (1, size) : malloc (size);\n}\n\nstatic void default_free (void * ptr, void * user_data)\n{\n    free (ptr);\n}\n\nstatic void * json_alloc (json_state * state, unsigned long size, int zero)\n{\n    if ((state->ulong_max - state->used_memory) < size)\n        return 0;\n\n    if (state->settings.max_memory\n            && (state->used_memory += size) > state->settings.max_memory)\n    {\n        return 0;\n    }\n\n    return state->settings.mem_alloc (size, zero, state->settings.user_data);\n}\n\nstatic int new_value (json_state * state,\n        json_value ** top, json_value ** root, json_value ** alloc,\n        json_type type)\n{\n    json_value * value;\n    int values_size;\n\n    if (!state->first_pass)\n    {\n        value = *top = *alloc;\n        *alloc = (*alloc)->_reserved.next_alloc;\n\n        if (!*root)\n            *root = value;\n\n        switch (value->type)\n        {\n            case json_array:\n\n                if (value->u.array.length == 0)\n                    break;\n\n                if (! (value->u.array.values = (json_value **) json_alloc\n                            (state, value->u.array.length * sizeof (json_value *), 0)) )\n                {\n                    return 0;\n                }\n\n                value->u.array.length = 0;\n                break;\n\n            case json_object:\n\n                if (value->u.object.length == 0)\n                    break;\n\n                values_size = sizeof (*value->u.object.values) * value->u.object.length;\n\n                if (! (value->u.object.values = (json_object_entry *) json_alloc\n                            (state, values_size + ((unsigned long) value->u.object.values), 0)) )\n                {\n                    return 0;\n                }\n\n                value->_reserved.object_mem = (*(char **) &value->u.object.values) + values_size;\n\n                value->u.object.length = 0;\n                break;\n\n            case json_string:\n\n                if (! (value->u.string.ptr = (json_char *) json_alloc\n                            (state, (value->u.string.length + 1) * sizeof (json_char), 0)) )\n                {\n                    return 0;\n                }\n\n                value->u.string.length = 0;\n                break;\n\n            default:\n                break;\n        };\n\n        return 1;\n    }\n\n    if (! (value = (json_value *) json_alloc\n                (state, sizeof (json_value) + state->settings.value_extra, 1)))\n    {\n        return 0;\n    }\n\n    if (!*root)\n        *root = value;\n\n    value->type = type;\n    value->parent = *top;\n\n#ifdef JSON_TRACK_SOURCE\n    value->line = state->cur_line;\n    value->col = state->cur_col;\n#endif\n\n    if (*alloc)\n        (*alloc)->_reserved.next_alloc = value;\n\n    *alloc = *top = value;\n\n    return 1;\n}\n\n#define whitespace \\\n    case '\\n': ++ state.cur_line;  state.cur_col = 0; \\\ncase ' ': case '\\t': case '\\r'\n\n#define string_add(b)  \\\n    do { if (!state.first_pass) string [string_length] = b;  ++ string_length; } while (0);\n\n#define line_and_col \\\n    state.cur_line, state.cur_col\n\nstatic const long\nflag_next             = 1 << 0,\n                      flag_reproc           = 1 << 1,\n                      flag_need_comma       = 1 << 2,\n                      flag_seek_value       = 1 << 3, \n                      flag_escaped          = 1 << 4,\n                      flag_string           = 1 << 5,\n                      flag_need_colon       = 1 << 6,\n                      flag_done             = 1 << 7,\n                      flag_num_negative     = 1 << 8,\n                      flag_num_zero         = 1 << 9,\n                      flag_num_e            = 1 << 10,\n                      flag_num_e_got_sign   = 1 << 11,\n                      flag_num_e_negative   = 1 << 12,\n                      flag_line_comment     = 1 << 13,\n                      flag_block_comment    = 1 << 14;\n\njson_value * json_parse_ex (json_settings * settings,\n        const json_char * json,\n        size_t length,\n        char * error_buf)\n{\n    json_char error [json_error_max];\n    const json_char * end;\n    json_value * top, * root, * alloc = 0;\n    json_state state = { 0 };\n    long flags;\n    long num_digits = 0, num_e = 0;\n    json_int_t num_fraction = 0;\n\n    /* Skip UTF-8 BOM\n    */\n    if (length >= 3 && ((unsigned char) json [0]) == 0xEF\n            && ((unsigned char) json [1]) == 0xBB\n            && ((unsigned char) json [2]) == 0xBF)\n    {\n        json += 3;\n        length -= 3;\n    }\n\n    error[0] = '\\0';\n    end = (json + length);\n\n    memcpy (&state.settings, settings, sizeof (json_settings));\n\n    if (!state.settings.mem_alloc)\n        state.settings.mem_alloc = default_alloc;\n\n    if (!state.settings.mem_free)\n        state.settings.mem_free = default_free;\n\n    memset (&state.uint_max, 0xFF, sizeof (state.uint_max));\n    memset (&state.ulong_max, 0xFF, sizeof (state.ulong_max));\n\n    state.uint_max -= 8; /* limit of how much can be added before next check */\n    state.ulong_max -= 8;\n\n    for (state.first_pass = 1; state.first_pass >= 0; -- state.first_pass)\n    {\n        json_uchar uchar;\n        unsigned char uc_b1, uc_b2, uc_b3, uc_b4;\n        json_char * string = 0;\n        unsigned int string_length = 0;\n\n        top = root = 0;\n        flags = flag_seek_value;\n\n        state.cur_line = 1;\n\n        for (state.ptr = json ;; ++ state.ptr)\n        {\n            json_char b = (state.ptr == end ? 0 : *state.ptr);\n\n            if (flags & flag_string)\n            {\n                if (!b)\n                {  sprintf (error, \"Unexpected EOF in string (at %d:%d)\", line_and_col);\n                    goto e_failed;\n                }\n\n                if (string_length > state.uint_max)\n                    goto e_overflow;\n\n                if (flags & flag_escaped)\n                {\n                    flags &= ~ flag_escaped;\n\n                    switch (b)\n                    {\n                        case 'b':  string_add ('\\b');  break;\n                        case 'f':  string_add ('\\f');  break;\n                        case 'n':  string_add ('\\n');  break;\n                        case 'r':  string_add ('\\r');  break;\n                        case 't':  string_add ('\\t');  break;\n                        case 'u':\n\n                                   if (end - state.ptr < 4 || \n                                           (uc_b1 = hex_value (*++ state.ptr)) == 0xFF ||\n                                           (uc_b2 = hex_value (*++ state.ptr)) == 0xFF ||\n                                           (uc_b3 = hex_value (*++ state.ptr)) == 0xFF ||\n                                           (uc_b4 = hex_value (*++ state.ptr)) == 0xFF)\n                                   {\n                                       sprintf (error, \"Invalid character value `%c` (at %d:%d)\", b, line_and_col);\n                                       goto e_failed;\n                                   }\n\n                                   uc_b1 = (uc_b1 << 4) | uc_b2;\n                                   uc_b2 = (uc_b3 << 4) | uc_b4;\n                                   uchar = (uc_b1 << 8) | uc_b2;\n\n                                   if ((uchar & 0xF800) == 0xD800) {\n                                       json_uchar uchar2;\n\n                                       if (end - state.ptr < 6 || (*++ state.ptr) != '\\\\' || (*++ state.ptr) != 'u' ||\n                                               (uc_b1 = hex_value (*++ state.ptr)) == 0xFF ||\n                                               (uc_b2 = hex_value (*++ state.ptr)) == 0xFF ||\n                                               (uc_b3 = hex_value (*++ state.ptr)) == 0xFF ||\n                                               (uc_b4 = hex_value (*++ state.ptr)) == 0xFF)\n                                       {\n                                           sprintf (error, \"Invalid character value `%c` (at %d:%d)\", b, line_and_col);\n                                           goto e_failed;\n                                       }\n\n                                       uc_b1 = (uc_b1 << 4) | uc_b2;\n                                       uc_b2 = (uc_b3 << 4) | uc_b4;\n                                       uchar2 = (uc_b1 << 8) | uc_b2;\n\n                                       uchar = 0x010000 | ((uchar & 0x3FF) << 10) | (uchar2 & 0x3FF);\n                                   }\n\n                                   if (sizeof (json_char) >= sizeof (json_uchar) || (uchar <= 0x7F))\n                                   {\n                                       string_add ((json_char) uchar);\n                                       break;\n                                   }\n\n                                   if (uchar <= 0x7FF)\n                                   {\n                                       if (state.first_pass)\n                                           string_length += 2;\n                                       else\n                                       {  string [string_length ++] = 0xC0 | (uchar >> 6);\n                                           string [string_length ++] = 0x80 | (uchar & 0x3F);\n                                       }\n\n                                       break;\n                                   }\n\n                                   if (uchar <= 0xFFFF) {\n                                       if (state.first_pass)\n                                           string_length += 3;\n                                       else\n                                       {  string [string_length ++] = 0xE0 | (uchar >> 12);\n                                           string [string_length ++] = 0x80 | ((uchar >> 6) & 0x3F);\n                                           string [string_length ++] = 0x80 | (uchar & 0x3F);\n                                       }\n\n                                       break;\n                                   }\n\n                                   if (state.first_pass)\n                                       string_length += 4;\n                                   else\n                                   {  string [string_length ++] = 0xF0 | (uchar >> 18);\n                                       string [string_length ++] = 0x80 | ((uchar >> 12) & 0x3F);\n                                       string [string_length ++] = 0x80 | ((uchar >> 6) & 0x3F);\n                                       string [string_length ++] = 0x80 | (uchar & 0x3F);\n                                   }\n\n                                   break;\n\n                        default:\n                                   string_add (b);\n                    };\n\n                    continue;\n                }\n\n                if (b == '\\\\')\n                {\n                    flags |= flag_escaped;\n                    continue;\n                }\n\n                if (b == '\"')\n                {\n                    if (!state.first_pass)\n                        string [string_length] = 0;\n\n                    flags &= ~ flag_string;\n                    string = 0;\n\n                    switch (top->type)\n                    {\n                        case json_string:\n\n                            top->u.string.length = string_length;\n                            flags |= flag_next;\n\n                            break;\n\n                        case json_object:\n\n                            if (state.first_pass)\n                                (*(json_char **) &top->u.object.values) += string_length + 1;\n                            else\n                            {  \n                                top->u.object.values [top->u.object.length].name\n                                    = (json_char *) top->_reserved.object_mem;\n\n                                top->u.object.values [top->u.object.length].name_length\n                                    = string_length;\n\n                                (*(json_char **) &top->_reserved.object_mem) += string_length + 1;\n                            }\n\n                            flags |= flag_seek_value | flag_need_colon;\n                            continue;\n\n                        default:\n                            break;\n                    };\n                }\n                else\n                {\n                    string_add (b);\n                    continue;\n                }\n            }\n\n            if (state.settings.settings & json_enable_comments)\n            {\n                if (flags & (flag_line_comment | flag_block_comment))\n                {\n                    if (flags & flag_line_comment)\n                    {\n                        if (b == '\\r' || b == '\\n' || !b)\n                        {\n                            flags &= ~ flag_line_comment;\n                            -- state.ptr;  /* so null can be reproc'd */\n                        }\n\n                        continue;\n                    }\n\n                    if (flags & flag_block_comment)\n                    {\n                        if (!b)\n                        {  sprintf (error, \"%d:%d: Unexpected EOF in block comment\", line_and_col);\n                            goto e_failed;\n                        }\n\n                        if (b == '*' && state.ptr < (end - 1) && state.ptr [1] == '/')\n                        {\n                            flags &= ~ flag_block_comment;\n                            ++ state.ptr;  /* skip closing sequence */\n                        }\n\n                        continue;\n                    }\n                }\n                else if (b == '/')\n                {\n                    if (! (flags & (flag_seek_value | flag_done)) && top->type != json_object)\n                    {  sprintf (error, \"%d:%d: Comment not allowed here\", line_and_col);\n                        goto e_failed;\n                    }\n\n                    if (++ state.ptr == end)\n                    {  sprintf (error, \"%d:%d: EOF unexpected\", line_and_col);\n                        goto e_failed;\n                    }\n\n                    switch (b = *state.ptr)\n                    {\n                        case '/':\n                            flags |= flag_line_comment;\n                            continue;\n\n                        case '*':\n                            flags |= flag_block_comment;\n                            continue;\n\n                        default:\n                            sprintf (error, \"%d:%d: Unexpected `%c` in comment opening sequence\", line_and_col, b);\n                            goto e_failed;\n                    };\n                }\n            }\n\n            if (flags & flag_done)\n            {\n                if (!b)\n                    break;\n\n                switch (b)\n                {\nwhitespace:\n                    continue;\n\n                    default:\n\n                    sprintf (error, \"%d:%d: Trailing garbage: `%c`\",\n                            state.cur_line, state.cur_col, b);\n\n                    goto e_failed;\n                };\n            }\n\n            if (flags & flag_seek_value)\n            {\n                switch (b)\n                {\nwhitespace:\n                    continue;\n\n                    case ']':\n\n                    if (top && top->type == json_array)\n                        flags = (flags & ~ (flag_need_comma | flag_seek_value)) | flag_next;\n                    else\n                    {  sprintf (error, \"%d:%d: Unexpected ]\", line_and_col);\n                        goto e_failed;\n                    }\n\n                    break;\n\n                    default:\n\n                    if (flags & flag_need_comma)\n                    {\n                        if (b == ',')\n                        {  flags &= ~ flag_need_comma;\n                            continue;\n                        }\n                        else\n                        {\n                            sprintf (error, \"%d:%d: Expected , before %c\",\n                                    state.cur_line, state.cur_col, b);\n\n                            goto e_failed;\n                        }\n                    }\n\n                    if (flags & flag_need_colon)\n                    {\n                        if (b == ':')\n                        {  flags &= ~ flag_need_colon;\n                            continue;\n                        }\n                        else\n                        { \n                            sprintf (error, \"%d:%d: Expected : before %c\",\n                                    state.cur_line, state.cur_col, b);\n\n                            goto e_failed;\n                        }\n                    }\n\n                    flags &= ~ flag_seek_value;\n\n                    switch (b)\n                    {\n                        case '{':\n\n                            if (!new_value (&state, &top, &root, &alloc, json_object))\n                                goto e_alloc_failure;\n\n                            continue;\n\n                        case '[':\n\n                            if (!new_value (&state, &top, &root, &alloc, json_array))\n                                goto e_alloc_failure;\n\n                            flags |= flag_seek_value;\n                            continue;\n\n                        case '\"':\n\n                            if (!new_value (&state, &top, &root, &alloc, json_string))\n                                goto e_alloc_failure;\n\n                            flags |= flag_string;\n\n                            string = top->u.string.ptr;\n                            string_length = 0;\n\n                            continue;\n\n                        case 't':\n\n                            if ((end - state.ptr) < 3 || *(++ state.ptr) != 'r' ||\n                                    *(++ state.ptr) != 'u' || *(++ state.ptr) != 'e')\n                            {\n                                goto e_unknown_value;\n                            }\n\n                            if (!new_value (&state, &top, &root, &alloc, json_boolean))\n                                goto e_alloc_failure;\n\n                            top->u.boolean = 1;\n\n                            flags |= flag_next;\n                            break;\n\n                        case 'f':\n\n                            if ((end - state.ptr) < 4 || *(++ state.ptr) != 'a' ||\n                                    *(++ state.ptr) != 'l' || *(++ state.ptr) != 's' ||\n                                    *(++ state.ptr) != 'e')\n                            {\n                                goto e_unknown_value;\n                            }\n\n                            if (!new_value (&state, &top, &root, &alloc, json_boolean))\n                                goto e_alloc_failure;\n\n                            flags |= flag_next;\n                            break;\n\n                        case 'n':\n\n                            if ((end - state.ptr) < 3 || *(++ state.ptr) != 'u' ||\n                                    *(++ state.ptr) != 'l' || *(++ state.ptr) != 'l')\n                            {\n                                goto e_unknown_value;\n                            }\n\n                            if (!new_value (&state, &top, &root, &alloc, json_null))\n                                goto e_alloc_failure;\n\n                            flags |= flag_next;\n                            break;\n\n                        default:\n\n                            if (isdigit (b) || b == '-')\n                            {\n                                if (!new_value (&state, &top, &root, &alloc, json_integer))\n                                    goto e_alloc_failure;\n\n                                if (!state.first_pass)\n                                {\n                                    while (isdigit (b) || b == '+' || b == '-'\n                                            || b == 'e' || b == 'E' || b == '.')\n                                    {\n                                        if ( (++ state.ptr) == end)\n                                        {\n                                            b = 0;\n                                            break;\n                                        }\n\n                                        b = *state.ptr;\n                                    }\n\n                                    flags |= flag_next | flag_reproc;\n                                    break;\n                                }\n\n                                flags &= ~ (flag_num_negative | flag_num_e |\n                                        flag_num_e_got_sign | flag_num_e_negative |\n                                        flag_num_zero);\n\n                                num_digits = 0;\n                                num_fraction = 0;\n                                num_e = 0;\n\n                                if (b != '-')\n                                {\n                                    flags |= flag_reproc;\n                                    break;\n                                }\n\n                                flags |= flag_num_negative;\n                                continue;\n                            }\n                            else\n                            {  sprintf (error, \"%d:%d: Unexpected %c when seeking value\", line_and_col, b);\n                                goto e_failed;\n                            }\n                    };\n                };\n            }\n            else\n            {\n                switch (top->type)\n                {\n                    case json_object:\n\n                        switch (b)\n                        {\nwhitespace:\n                            continue;\n\n                            case '\"':\n\n                            if (flags & flag_need_comma)\n                            {  sprintf (error, \"%d:%d: Expected , before \\\"\", line_and_col);\n                                goto e_failed;\n                            }\n\n                            flags |= flag_string;\n\n                            string = (json_char *) top->_reserved.object_mem;\n                            string_length = 0;\n\n                            break;\n\n                            case '}':\n\n                            flags = (flags & ~ flag_need_comma) | flag_next;\n                            break;\n\n                            case ',':\n\n                            if (flags & flag_need_comma)\n                            {\n                                flags &= ~ flag_need_comma;\n                                break;\n                            }\n\n                            default:\n                            sprintf (error, \"%d:%d: Unexpected `%c` in object\", line_and_col, b);\n                            goto e_failed;\n                        };\n\n                        break;\n\n                    case json_integer:\n                    case json_double:\n\n                        if (isdigit (b))\n                        {\n                            ++ num_digits;\n\n                            if (top->type == json_integer || flags & flag_num_e)\n                            {\n                                if (! (flags & flag_num_e))\n                                {\n                                    if (flags & flag_num_zero)\n                                    {  sprintf (error, \"%d:%d: Unexpected `0` before `%c`\", line_and_col, b);\n                                        goto e_failed;\n                                    }\n\n                                    if (num_digits == 1 && b == '0')\n                                        flags |= flag_num_zero;\n                                }\n                                else\n                                {\n                                    flags |= flag_num_e_got_sign;\n                                    num_e = (num_e * 10) + (b - '0');\n                                    continue;\n                                }\n\n                                top->u.integer = (top->u.integer * 10) + (b - '0');\n                                continue;\n                            }\n\n                            num_fraction = (num_fraction * 10) + (b - '0');\n                            continue;\n                        }\n\n                        if (b == '+' || b == '-')\n                        {\n                            if ( (flags & flag_num_e) && !(flags & flag_num_e_got_sign))\n                            {\n                                flags |= flag_num_e_got_sign;\n\n                                if (b == '-')\n                                    flags |= flag_num_e_negative;\n\n                                continue;\n                            }\n                        }\n                        else if (b == '.' && top->type == json_integer)\n                        {\n                            if (!num_digits)\n                            {  sprintf (error, \"%d:%d: Expected digit before `.`\", line_and_col);\n                                goto e_failed;\n                            }\n\n                            top->type = json_double;\n                            top->u.dbl = (double) top->u.integer;\n\n                            num_digits = 0;\n                            continue;\n                        }\n\n                        if (! (flags & flag_num_e))\n                        {\n                            if (top->type == json_double)\n                            {\n                                if (!num_digits)\n                                {  sprintf (error, \"%d:%d: Expected digit after `.`\", line_and_col);\n                                    goto e_failed;\n                                }\n\n                                top->u.dbl += ((double) num_fraction) / (pow (10.0, (double) num_digits));\n                            }\n\n                            if (b == 'e' || b == 'E')\n                            {\n                                flags |= flag_num_e;\n\n                                if (top->type == json_integer)\n                                {\n                                    top->type = json_double;\n                                    top->u.dbl = (double) top->u.integer;\n                                }\n\n                                num_digits = 0;\n                                flags &= ~ flag_num_zero;\n\n                                continue;\n                            }\n                        }\n                        else\n                        {\n                            if (!num_digits)\n                            {  sprintf (error, \"%d:%d: Expected digit after `e`\", line_and_col);\n                                goto e_failed;\n                            }\n\n                            top->u.dbl *= pow (10.0, (double)\n                                    (flags & flag_num_e_negative ? - num_e : num_e));\n                        }\n\n                        if (flags & flag_num_negative)\n                        {\n                            if (top->type == json_integer)\n                                top->u.integer = - top->u.integer;\n                            else\n                                top->u.dbl = - top->u.dbl;\n                        }\n\n                        flags |= flag_next | flag_reproc;\n                        break;\n\n                    default:\n                        break;\n                };\n            }\n\n            if (flags & flag_reproc)\n            {\n                flags &= ~ flag_reproc;\n                -- state.ptr;\n            }\n\n            if (flags & flag_next)\n            {\n                flags = (flags & ~ flag_next) | flag_need_comma;\n\n                if (!top->parent)\n                {\n                    /* root value done */\n\n                    flags |= flag_done;\n                    continue;\n                }\n\n                if (top->parent->type == json_array)\n                    flags |= flag_seek_value;\n\n                if (!state.first_pass)\n                {\n                    json_value * parent = top->parent;\n\n                    switch (parent->type)\n                    {\n                        case json_object:\n\n                            parent->u.object.values\n                                [parent->u.object.length].value = top;\n\n                            break;\n\n                        case json_array:\n\n                            parent->u.array.values\n                                [parent->u.array.length] = top;\n\n                            break;\n\n                        default:\n                            break;\n                    };\n                }\n\n                if ( (++ top->parent->u.array.length) > state.uint_max)\n                    goto e_overflow;\n\n                top = top->parent;\n\n                continue;\n            }\n        }\n\n        alloc = root;\n    }\n\n    return root;\n\ne_unknown_value:\n\n    sprintf (error, \"%d:%d: Unknown value\", line_and_col);\n    goto e_failed;\n\ne_alloc_failure:\n\n    strcpy (error, \"Memory allocation failure\");\n    goto e_failed;\n\ne_overflow:\n\n    sprintf (error, \"%d:%d: Too long (caught overflow)\", line_and_col);\n    goto e_failed;\n\ne_failed:\n\n    if (error_buf)\n    {\n        if (*error)\n            strcpy (error_buf, error);\n        else\n            strcpy (error_buf, \"Unknown error\");\n    }\n\n    if (state.first_pass)\n        alloc = root;\n\n    while (alloc)\n    {\n        top = alloc->_reserved.next_alloc;\n        state.settings.mem_free (alloc, state.settings.user_data);\n        alloc = top;\n    }\n\n    if (!state.first_pass)\n        json_value_free_ex (&state.settings, root);\n\n    return 0;\n}\n\njson_value * json_parse (const json_char * json, size_t length)\n{\n    json_settings settings = { 0 };\n    return json_parse_ex (&settings, json, length, 0);\n}\n\nvoid json_value_free_ex (json_settings * settings, json_value * value)\n{\n    json_value * cur_value;\n\n    if (!value)\n        return;\n\n    value->parent = 0;\n\n    while (value)\n    {\n        switch (value->type)\n        {\n            case json_array:\n\n                if (!value->u.array.length)\n                {\n                    settings->mem_free (value->u.array.values, settings->user_data);\n                    break;\n                }\n\n                value = value->u.array.values [-- value->u.array.length];\n                continue;\n\n            case json_object:\n\n                if (!value->u.object.length)\n                {\n                    settings->mem_free (value->u.object.values, settings->user_data);\n                    break;\n                }\n\n                value = value->u.object.values [-- value->u.object.length].value;\n                continue;\n\n            case json_string:\n\n                settings->mem_free (value->u.string.ptr, settings->user_data);\n                break;\n\n            default:\n                break;\n        };\n\n        cur_value = value;\n        value = value->parent;\n        settings->mem_free (cur_value, settings->user_data);\n    }\n}\n\nvoid json_value_free (json_value * value)\n{\n    json_settings settings = { 0 };\n    settings.mem_free = default_free;\n    json_value_free_ex (&settings, value);\n}\n\n"]}