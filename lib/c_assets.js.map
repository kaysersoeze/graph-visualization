{"version":3,"file":"lib/c_assets.js","sources":["lib/minimizer/angular_gradient.c","lib/minimizer/bond.c","lib/minimizer/bond_cross.c","lib/minimizer/bond_pair.c","lib/minimizer/bond_set.c","lib/minimizer/crossing_gradient.c","lib/minimizer/energy.c","lib/minimizer/global_minimizer.c","lib/minimizer/gradient.c","lib/minimizer/graph.c","lib/minimizer/grid.c","lib/minimizer/json.c","lib/minimizer/linmin.c","lib/minimizer/local_minimizer.c","lib/minimizer/minimizer.c","lib/minimizer/pair.c","lib/minimizer/placement.c","lib/minimizer/process_input.c","lib/minimizer/util.c","lib/minimizer/vector.c","lib/minimizer/vertex.c","lib/minimizer/vertex_pair.c","lib/minimizer/vertex_set.c","lib/minimizer/zone.c","lib/minimizer/zone_pair.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgDA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAjBA;AAAA;;;;;;;;;;;;;;;;;;;AAsBA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAjBA;AAAA;;;;;;;;;;;;;;;;;;;AAsBA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAEA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;AAjBA;AAAA;;;;;;;;;;;;;;;;;;;AAsBA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAlBA;AAAA;;;;;;;;;;;;;;;;;;;AAuBA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;AAhBA;AAAA;;;;;;;;;;;;;;;;;;;AAqBA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;AAhBA;AAAA;;;;;;;;;;AA5UA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;;;AAGA;AAAA;;AAAA;AAAA;;AACA;AACA;AACA;;;;;;;AAKA;AACA;AAAA;;;;AAAA;AAAA;AAAA;;;AACA;AAAA;;AACA;AACA;;AAFA;AAAA;;;;;;;;;AChBA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;AAWA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAMA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAKA;AACA;;;;;;;;;;;;AC2BA;AACA;AAIA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;AAOA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAA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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAWA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAWA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAWA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAWA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAWA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAWA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAYA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAWA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAWA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAWA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAWA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAWA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAYA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAWA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAYA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAWA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAWA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAWA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAWA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAWA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAWA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;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","sourcesContent":["/*****************************************************************************\n\n* File Name: pair_gradient.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 10-08-2015\n\n*****************************************************************************/\n\n#include <math.h>\n\n#include \"stdio.h\"\n#include \"util.h\"\n#include \"constants.h\"\n#include \"vector.h\"\n\nstatic void check1(double *a, double *b)\n{\n    double x, y;\n    x = *a;\n    y = *b;\n    if (Util_close_to(x, -1.0)) x = -1.0 + EPS;\n    if (Util_close_to(x, 1.0)) x = 1.0 - EPS;\n    assert(Util_in_range_strict(-1.0, 1.0, x));\n    if (Util_equal(y, 1.0) && y > 1.0) {\n        y = 1.0 - TINY;\n    } else if (Util_close_to(y, 1.0) && y > 1.0) {\n        y = 1.0 - EPS;\n    }\n    assert((1 - y) >= 0);\n    *a = x;\n    *b = y;\n}\n\nstatic void check2(double *a)\n{\n    double x;\n    x = *a;\n    if (Util_is_zero(x)) x = Util_sign(x) == MINUS ? -EPS : EPS;\n    assert(!Util_is_zero(x));\n    *a = x;\n}\n\ndouble AngularGradient_dfx0(Vector v0, Vector v1, Vector v2, double w, int mass) {\n    double x0, y0, x1, y1, x2, y2;\n    x0 = v0.x; \n    y0 = v0.y; \n    x1 = v1.x; \n    y1 = v1.y; \n    x2 = v2.x; \n    y2 = v2.y; \n    double a00 = -x1 + x2;\n    double a01 = x0 - x1;\n    double a02 = y0 - y1;\n    double a03 = -y1 + y2;\n    double a04 = 2 * M_PI / mass;\n\n    double b00 = pow(a01, 2);\n    double b01 = pow(a02, 2);\n    double b02 = pow(a00, 2);\n    double b04 = pow(a03, 2);\n    double b05 = a01 * a00 + a02 * a03;\n\n    double c00 = sqrt(b00 + b01);\n    double c01 = sqrt(b02 + b04);\n    double c02 = pow(b00 + b01, 1.5);\n    double c03 = pow(b05, 2);\n    double c05 = b00 + b01;\n    double c06 = b02 + b04;\n    double c07 = a01 * b05;\n\n    double d00 = c00 * c01;\n    double d01 = c02 * c01;\n    double d03 = c05 * c06;\n    assert(!Util_is_zero(d00));\n    assert(!Util_is_zero(d01));\n    assert(!Util_is_zero(d03));\n\n    double e00 = a00 / d00;\n    double e01 = c07 / d01;\n    double e02 = b05 / d00;\n    double e03 = c03 / d03;\n    check1(&e02, &e03);\n\n    double f00 = e00 - e01;\n    double f01 = acosf(e02);\n    double f02 = sqrt(1 - e03);\n    check2(&f02);\n\n    double g00 = a04 - f01;\n\n    double h00 = (2*w*f00*g00);\n\n    return h00 / f02;\n}\n\ndouble AngularGradient_dfy0(Vector v0, Vector v1, Vector v2, double w, int mass) {\n    double x0, y0, x1, y1, x2, y2;\n    x0 = v0.x; \n    y0 = v0.y; \n    x1 = v1.x; \n    y1 = v1.y; \n    x2 = v2.x; \n    y2 = v2.y; \n    double a00 = -x1 + x2;\n    double a01 = x0 - x1;\n    double a02 = y0 - y1;\n    double a03 = -y1 + y2;\n    double a04 = 2 * M_PI / mass;\n\n    double b00 = pow(a01, 2);\n    double b01 = pow(a02, 2);\n    double b02 = pow(a00, 2);\n    double b04 = pow(a03, 2);\n    double b05 = a01 * a00 + a02 * a03;\n\n    double c00 = sqrt(b00 + b01);\n    double c01 = sqrt(b02 + b04);\n    double c02 = pow(b00 + b01, 1.5);\n    double c03 = pow(b05, 2);\n    double c05 = b00 + b01;\n    double c06 = b02 + b04;\n    double c08 = a02 * b05;\n\n    double d00 = c00 * c01;\n    double d01 = c02 * c01;\n    double d03 = c05 * c06;\n    assert(!Util_is_zero(d00));\n    assert(!Util_is_zero(d01));\n    assert(!Util_is_zero(d03));\n\n    double e02 = b05 / d00;\n    double e03 = c03 / d03;\n    double e04 = a03 / d00;\n    double e05 = c08 / d01;\n    check1(&e02, &e03);\n\n    double f01 = acosf(e02);\n    double f02 = sqrt(1 - e03);\n    double f03 = e04 - e05;\n    check2(&f02);\n\n    double g00 = a04 - f01;\n\n    double h01 = (2*w*f03*g00);\n\n    return h01/f02;\n}\n\ndouble AngularGradient_dfx1(Vector v0, Vector v1, Vector v2, double w, int mass) {\n    double x0, y0, x1, y1, x2, y2;\n    x0 = v0.x; \n    y0 = v0.y; \n    x1 = v1.x; \n    y1 = v1.y; \n    x2 = v2.x; \n    y2 = v2.y; \n    double a00 = -x1 + x2;\n    double a01 = x0 - x1;\n    double a02 = y0 - y1;\n    double a03 = -y1 + y2;\n    double a04 = 2 * M_PI / mass;\n    double a06 = -x0 + 2 * x1 - x2;\n\n    double b00 = pow(a01, 2);\n    double b01 = pow(a02, 2);\n    double b02 = pow(a00, 2);\n    double b04 = pow(a03, 2);\n    double b05 = a01 * a00 + a02 * a03;\n\n    double c00 = sqrt(b00 + b01);\n    double c01 = sqrt(b02 + b04);\n    double c02 = pow(b00 + b01, 1.5);\n    double c03 = pow(b05, 2);\n    double c04 = pow(b02 + b04, 1.5);\n    double c05 = b00 + b01;\n    double c06 = b02 + b04;\n    double c07 = a01 * b05;\n    double c09 = a00 * b05;\n\n    double d00 = c00 * c01;\n    double d01 = c02 * c01;\n    double d03 = c05 * c06;\n    double d04 = c00 * c04;\n    assert(!Util_is_zero(d00));\n    assert(!Util_is_zero(d01));\n    assert(!Util_is_zero(d03));\n    assert(!Util_is_zero(d04));\n\n    double e01 = c07 / d01;\n    double e02 = b05 / d00;\n    double e03 = c03 / d03;\n    double e06 = c09 / d04;\n    double e08 = a06 / d00;\n    check1(&e02, &e03);\n\n    double f01 = acosf(e02);\n    double f02 = sqrt(1 - e03);\n    double f04 = e06 +e08 +e01;\n    check2(&f02);\n\n    double g00 = a04 - f01;\n\n    double h02 = (2*w*f04*g00);\n    return h02/f02;\n}\n\ndouble AngularGradient_dfy1(Vector v0, Vector v1, Vector v2, double w, int mass) {\n    double x0, y0, x1, y1, x2, y2;\n    x0 = v0.x; \n    y0 = v0.y; \n    x1 = v1.x; \n    y1 = v1.y; \n    x2 = v2.x; \n    y2 = v2.y; \n    double a00 = -x1 + x2;\n    double a01 = x0 - x1;\n    double a02 = y0 - y1;\n    double a03 = -y1 + y2;\n    double a04 = 2 * M_PI / mass;\n    double a05 = -y0 + 2 * y1 - y2;\n\n    double b00 = pow(a01, 2);\n    double b01 = pow(a02, 2);\n    double b02 = pow(a00, 2);\n    double b04 = pow(a03, 2);\n    double b05 = a01 * a00 + a02 * a03;\n\n    double c00 = sqrt(b00 + b01);\n    double c01 = sqrt(b02 + b04);\n    double c02 = pow(b00 + b01, 1.5);\n    double c03 = pow(b05, 2);\n    double c04 = pow(b02 + b04, 1.5);\n    double c05 = b00 + b01;\n    double c06 = b02 + b04;\n    double c08 = a02 * b05;\n    double c10 = a03 * b05;\n\n    double d00 = c00 * c01;\n    double d01 = c02 * c01;\n    double d03 = c05 * c06;\n    double d04 = c00 * c04;\n    assert(!Util_is_zero(d00));\n    assert(!Util_is_zero(d01));\n    assert(!Util_is_zero(d03));\n    assert(!Util_is_zero(d04));\n\n    double e02 = b05 / d00;\n    double e03 = c03 / d03;\n    double e05 = c08 / d01;\n    double e09 = c10 / d04;\n    double e11 = a05 / d00;\n    check1(&e02, &e03);\n\n    double f01 = acosf(e02);\n    double f02 = sqrt(1 - e03);\n    double f05 = e09 +e11 +e05;\n    check2(&f02);\n\n    double g00 = a04 - f01;\n\n    double h03 = (2*w*f05*g00);\n    \n    return h03/f02;\n}\n\ndouble AngularGradient_dfx2(Vector v0, Vector v1, Vector v2, double w, int mass) {\n    double x0, y0, x1, y1, x2, y2;\n    x0 = v0.x; \n    y0 = v0.y; \n    x1 = v1.x; \n    y1 = v1.y; \n    x2 = v2.x; \n    y2 = v2.y; \n    double a00 = -x1 + x2;\n    double a01 = x0 - x1;\n    double a02 = y0 - y1;\n    double a03 = -y1 + y2;\n    double a04 = 2 * M_PI / mass;\n\n    double b00 = pow(a01, 2);\n    double b01 = pow(a02, 2);\n    double b02 = pow(a00, 2);\n    double b04 = pow(a03, 2);\n    double b05 = a01 * a00 + a02 * a03;\n\n    double c00 = sqrt(b00 + b01);\n    double c01 = sqrt(b02 + b04);\n    double c03 = pow(b05, 2);\n    double c04 = pow(b02 + b04, 1.5);\n    double c05 = b00 + b01;\n    double c06 = b02 + b04;\n    double c09 = a00 * b05;\n\n    double d00 = c00 * c01;\n    double d03 = c05 * c06;\n    double d04 = c00 * c04;\n    assert(!Util_is_zero(d00));\n    assert(!Util_is_zero(d03));\n    assert(!Util_is_zero(d04));\n\n    double e02 = b05 / d00;\n    double e03 = c03 / d03;\n    double e06 = c09 / d04;\n    double e07 = a01 / d00;\n    check1(&e02, &e03);\n\n    double f01 = acosf(e02);\n    double f02 = sqrt(1 - e03);\n    double f06 = -e06 + e07;\n    check2(&f02);\n\n    double g00 = a04 - f01;\n\n    double h04 = (2*w*f06*g00);\n    return h04/f02;\n}\n\ndouble AngularGradient_dfy2(Vector v0, Vector v1, Vector v2, double w, int mass) {\n    double x0, y0, x1, y1, x2, y2;\n    x0 = v0.x; \n    y0 = v0.y; \n    x1 = v1.x; \n    y1 = v1.y; \n    x2 = v2.x; \n    y2 = v2.y; \n    double a00 = -x1 + x2;\n    double a01 = x0 - x1;\n    double a02 = y0 - y1;\n    double a03 = -y1 + y2;\n    double a04 = 2 * M_PI / mass;\n\n    double b00 = pow(a01, 2);\n    double b01 = pow(a02, 2);\n    double b02 = pow(a00, 2);\n    double b04 = pow(a03, 2);\n    double b05 = a01 * a00 + a02 * a03;\n\n    double c00 = sqrt(b00 + b01);\n    double c01 = sqrt(b02 + b04);\n    double c03 = pow(b05, 2);\n    double c04 = pow(b02 + b04, 1.5);\n    double c05 = b00 + b01;\n    double c06 = b02 + b04;\n    double c10 = a03 * b05;\n\n    double d00 = c00 * c01;\n    double d03 = c05 * c06;\n    double d04 = c00 * c04;\n    assert(!Util_is_zero(d00));\n    assert(!Util_is_zero(d03));\n    assert(!Util_is_zero(d04));\n\n    double e02 = b05 / d00;\n    double e03 = c03 / d03;\n    double e09 = c10 / d04;\n    double e10 = a02 / d00;\n    check1(&e02, &e03);\n\n    double f01 = acosf(e02);\n    double f02 = sqrt(1 - e03);\n    double f07 = -e09 + e10;\n    check2(&f02);\n\n    double g00 = a04 - f01;\n\n    double h05 = (2*w*f07*g00);\n    return h05/f02;\n}\n\n","/*****************************************************************************\n\n* File Name: Bond.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 28-07-2015\n\n*****************************************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n\n#include \"util.h\"\n#include \"constants.h\"\n#include \"bond.h\"\n\nBondPointer Bond_create(\n        const VertexPointer fst, \n        const VertexPointer snd, \n        const double dist0\n    )\n{\n    fst->mass++;\n    snd->mass++;\n\n    BondPointer rtn = malloc(sizeof(Bond));\n    rtn->fst = fst;\n    rtn->snd = snd;\n    rtn->dist0 = dist0;\n    return rtn;\n}\n\nstatic double Bond_attraction_weight(const BondPointer bp)\n{\n    return WATR;\n}\n\ndouble Bond_attraction_energy(const BondPointer bp)\n{\n    double d0, d;\n    d0 = bp->dist0 * SPRING_LENGTH;\n    d = Vector_norm(Vector_sub(bp->snd->pos, bp->fst->pos)); \n\n    double w;\n    w = Bond_attraction_weight(bp);\n    return w * pow(d - d0, 2);\n}\n\nVector Bond_attraction_gradient(const BondPointer bp)\n{\n    double d0;\n    d0 = bp->dist0 * SPRING_LENGTH;\n    Vector vecb;\n    vecb = Vector_sub(bp->snd->pos, bp->fst->pos);\n\n    double d;\n    d = Vector_norm(vecb); \n    if (fabs(d) <  MIN_DIST) {\n        d = MIN_DIST;\n    } \n    \n    double w;\n    w = Bond_attraction_weight(bp);\n\n    return Vector_scalar_mult(vecb, 2 * w * (1 - (d0 / d)));\n}\n\nvoid Bond_free(BondPointer bp)\n{\n    free(bp);\n}\n\n","/*****************************************************************************\n\n* File Name: bond_crossing.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 03-08-2015\n\n*****************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#include \"bond_cross.h\"\n#include \"util.h\"\n#include \"constants.h\"\n#include \"crossing_gradient.h\"\n\n/* Private *******************************************************************/\n\n#ifndef TEST\n#define TEST 0\n#endif\n\nstatic double crossing_weight(const BondCrossPointer bcrs)\n{\n    return WCRS;\n}\n\nstatic double bump(const double d, const double b) {\n    const double a = 1 / (b / 2);\n    const double c = (a * pow((b / 2), 2)) / 2;\n    if (Util_in_range(0, (b / 4), d)) {\n        return a * pow(d, 2);\n    } else if (Util_in_range((b / 4), (3 * b / 4), d)) {\n        return -a * pow(d - (b / 2), 2) + c;\n    } else if (Util_in_range((3 * b / 4), b, d)) {\n        return a * pow(d - b, 2);\n    } else {\n        return 0;\n    }\n}\n\nstatic void dbump(\n        double *gradient, \n        const double d,\n        const double b,\n        const Vector v0,\n        const Vector v1,\n        const Vector v2,\n        const Vector v3\n    )\n{\n    if (Util_in_range(0, (b / 4), d)) {\n        gradient[0] = CrossingGradient_df0x0(v0, v1, v2, v3);\n        gradient[1] = CrossingGradient_df0y0(v0, v1, v2, v3);\n        gradient[2] = CrossingGradient_df0x1(v0, v1, v2, v3);\n        gradient[3] = CrossingGradient_df0y1(v0, v1, v2, v3);\n        gradient[4] = CrossingGradient_df0x2(v0, v1, v2, v3);\n        gradient[5] = CrossingGradient_df0y2(v0, v1, v2, v3);\n        gradient[6] = CrossingGradient_df0x3(v0, v1, v2, v3);\n        gradient[7] = CrossingGradient_df0y3(v0, v1, v2, v3);\n    } else if (Util_in_range((b / 4), (3 * b / 4), d)) {\n        gradient[0] = CrossingGradient_df1x0(v0, v1, v2, v3);\n        gradient[1] = CrossingGradient_df1y0(v0, v1, v2, v3);\n        gradient[2] = CrossingGradient_df1x1(v0, v1, v2, v3);\n        gradient[3] = CrossingGradient_df1y1(v0, v1, v2, v3);\n        gradient[4] = CrossingGradient_df1x2(v0, v1, v2, v3);\n        gradient[5] = CrossingGradient_df1y2(v0, v1, v2, v3);\n        gradient[6] = CrossingGradient_df1x3(v0, v1, v2, v3);\n        gradient[7] = CrossingGradient_df1y3(v0, v1, v2, v3);\n    } else if (Util_in_range((3 * b / 4), b, d)) {\n        gradient[0] = CrossingGradient_df2x0(v0, v1, v2, v3);\n        gradient[1] = CrossingGradient_df2y0(v0, v1, v2, v3);\n        gradient[2] = CrossingGradient_df2x1(v0, v1, v2, v3);\n        gradient[3] = CrossingGradient_df2y1(v0, v1, v2, v3);\n        gradient[4] = CrossingGradient_df2x2(v0, v1, v2, v3);\n        gradient[5] = CrossingGradient_df2y2(v0, v1, v2, v3);\n        gradient[6] = CrossingGradient_df2x3(v0, v1, v2, v3);\n        gradient[7] = CrossingGradient_df2y3(v0, v1, v2, v3);\n    } else {\n        gradient[0] = 0;\n        gradient[1] = 0;\n        gradient[2] = 0;\n        gradient[3] = 0;\n        gradient[4] = 0;\n        gradient[5] = 0;\n        gradient[6] = 0;\n        gradient[7] = 0;\n    }\n}\n\n/* Public ********************************************************************/\n\nBondCross BondCross_initialize(const BondPair bpr, const Vector cross)\n{\n    BondCross rtn;\n\n    rtn.bpr = bpr;\n    rtn.cross = cross;\n    rtn.next = NULL;\n\n    BondPointer b0, b1;\n    b0 = bpr.fst; b1 = bpr.snd;\n\n    VertexPointer v0, v1, v2, v3;\n    v0 = b0->fst; v1 = b0->snd; \n    v2 = b1->fst; v3 = b1->snd;\n    \n    *(v0->crs_bof + v2->id) = 1;\n    *(v0->crs_bof + v3->id) = 1;\n\n    *(v1->crs_bof + v2->id) = 1;\n    *(v1->crs_bof + v3->id) = 1;\n\n    *(v2->crs_bof + v0->id) = 1;\n    *(v2->crs_bof + v1->id) = 1;\n\n    *(v3->crs_bof + v0->id) = 1;\n    *(v3->crs_bof + v1->id) = 1;\n\n    rtn.cross = cross;\n    return rtn;\n}\n\nBondCrossPointer BondCross_create(\n        const BondPair bcrs, \n        const Vector cross\n    )\n{\n    BondCrossPointer rtn = Util_allocate(1, sizeof(BondCross));\n    *rtn = BondCross_initialize(bcrs, cross);\n    return rtn;\n}\n\ndouble BondCross_crossing_energy(const BondCrossPointer bcrs)\n{\n    \n    BondPointer b0, b1;\n    b0 = bcrs->bpr.fst; b1 = bcrs->bpr.snd;\n\n    VertexPointer v[4];\n    v[0] = b0->fst; \n    v[1] = b0->snd; \n    v[2] = b1->fst; \n    v[3] = b1->snd;\n    \n    Vector vecs[4]; \n    vecs[0] = Vector_sub(bcrs->cross, v[0]->pos);\n    vecs[1] = Vector_sub(bcrs->cross, v[1]->pos);\n    vecs[2] = Vector_sub(bcrs->cross, v[2]->pos);\n    vecs[3] = Vector_sub(bcrs->cross, v[3]->pos);\n    \n    double dsum;\n    dsum = fmax(Vector_norm(vecs[0]), EPS) + fmax(Vector_norm(vecs[2]), EPS);\n\n    double d0, d1;\n    d0 = Vector_sub(b0->snd->pos, b0->fst->pos).len; \n    d1 = Vector_sub(b1->snd->pos, b1->fst->pos).len; \n\n    double rtn = bump(dsum, d0 + d1);\n    \n    double wi;\n    if (!TEST) {\n        wi = crossing_weight(bcrs) / (v[0]->mass + v[1]->mass + v[2]->mass + v[3]->mass) ;\n    } else {\n        wi = crossing_weight(bcrs);\n    }\n    return wi * rtn;\n}\n\nVectorPointer BondCross_crossing_gradient(const BondCrossPointer bcrs)\n{\n    BondPointer b0, b1;\n    b0 = bcrs->bpr.fst; b1 = bcrs->bpr.snd;\n\n    VertexPointer v[4];\n    v[0] = b0->fst; \n    v[1] = b0->snd; \n    v[2] = b1->fst; \n    v[3] = b1->snd;\n    \n    Vector vecs[4]; \n    vecs[0] = Vector_sub(bcrs->cross, v[0]->pos);\n    vecs[1] = Vector_sub(bcrs->cross, v[1]->pos);\n    vecs[2] = Vector_sub(bcrs->cross, v[2]->pos);\n    vecs[3] = Vector_sub(bcrs->cross, v[3]->pos);\n    \n    double dsum;\n    dsum = fmax(Vector_norm(vecs[0]), EPS) + fmax(Vector_norm(vecs[2]), EPS);\n\n    double d0, d1;\n    d0 = Vector_sub(v[1]->pos, v[0]->pos).len; \n    d1 = Vector_sub(v[3]->pos, v[2]->pos).len; \n\n    double gradient[8];\n    dbump(gradient, dsum, d0 + d1, v[0]->pos, v[1]->pos, v[2]->pos, v[3]->pos);\n    \n    assert(!(gradient[0] != gradient[0]));\n    assert(!(gradient[1] != gradient[1]));\n    assert(!(gradient[2] != gradient[2]));\n    assert(!(gradient[3] != gradient[3]));\n    assert(!(gradient[4] != gradient[4]));\n    assert(!(gradient[5] != gradient[5]));\n    assert(!(gradient[6] != gradient[6]));\n    assert(!(gradient[7] != gradient[7]));\n\n    Vector v0_grad, v1_grad, v2_grad, v3_grad;\n    v0_grad = Vector_initialize(gradient[0], gradient[1]);\n    v1_grad = Vector_initialize(gradient[2], gradient[3]);\n    v2_grad = Vector_initialize(gradient[4], gradient[5]);\n    v3_grad = Vector_initialize(gradient[6], gradient[7]);\n\n    double wi;\n    wi = crossing_weight(bcrs);\n    \n    VectorPointer rtn = Util_allocate(4, sizeof(Vector));\n    \n    if (!TEST) {\n        rtn[0] = Vector_scalar_mult(v0_grad, -wi / v[0]->mass);\n        rtn[1] = Vector_scalar_mult(v1_grad, -wi / v[1]->mass);\n        rtn[2] = Vector_scalar_mult(v2_grad, -wi / v[2]->mass);\n        rtn[3] = Vector_scalar_mult(v3_grad, -wi / v[3]->mass);\n    } else {\n        rtn[0] = Vector_scalar_mult(v0_grad, -wi);\n        rtn[1] = Vector_scalar_mult(v1_grad, -wi);\n        rtn[2] = Vector_scalar_mult(v2_grad, -wi);\n        rtn[3] = Vector_scalar_mult(v3_grad, -wi);\n    }\n    \n    return rtn;\n}\n\n\nvoid BondCrosses_free(BondCrossPointer bcrss)\n{\n    BondCrossPointer bcrs = bcrss;\n    while(bcrs != NULL) {\n\n        BondPointer b0, b1;\n        b0 = bcrs->bpr.fst; b1 = bcrs->bpr.snd;\n\n        VertexPointer v0, v1, v2, v3;\n        v0 = b0->fst; v1 = b0->snd; \n        v2 = b1->fst; v3 = b1->snd;\n        \n        *(v0->crs_bof + v2->id) = 0;\n        *(v0->crs_bof + v3->id) = 0;\n\n        *(v1->crs_bof + v2->id) = 0;\n        *(v1->crs_bof + v3->id) = 0;\n\n        *(v2->crs_bof + v0->id) = 0;\n        *(v2->crs_bof + v1->id) = 0;\n\n        *(v3->crs_bof + v0->id) = 0;\n        *(v3->crs_bof + v1->id) = 0;\n\n        BondCrossPointer tmp = bcrs;\n        bcrs = bcrs->next;\n        free(tmp);\n        tmp = NULL;\n    }\n}\n\n","/*****************************************************************************\n\n* File Name: bondPair.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 30-07-2015\n\n*****************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#include \"util.h\"\n#include \"constants.h\"\n#include \"bond_pair.h\"\n#include \"bond_set.h\"\n#include \"angular_gradient.h\"\n\n/* Private ******************************************************************/\n\nstatic double angular_weight(const BondPairPointer bpr)\n{\n   return WANG;\n}\n\n\n/* Public *******************************************************************/\n\nBondPair BondPair_initialize(Pair pr)\n{\n    BondPair rtn;\n    rtn.fst = (BondPointer) pr.fst;\n    rtn.snd = (BondPointer) pr.snd;\n    rtn.next = NULL;\n\n    VertexPointer v0, v1, v2, v3;\n    v0 = rtn.fst->fst;\n    v1 = rtn.fst->snd;\n    v2 = rtn.snd->fst;\n    v3 = rtn.snd->snd;\n\n    if (v0->id == v2->id) {\n        rtn.common = v0;\n        rtn.other1 = v1;\n        rtn.other2 = v3;\n    } else if (v0->id == v3->id) {\n        rtn.common = v0;\n        rtn.other1 = v1;\n        rtn.other2 = v2;\n    } else if (v1->id == v2->id) {\n        rtn.common = v1;\n        rtn.other1 = v0;\n        rtn.other2 = v3;\n    } else {\n        rtn.common = v1;\n        rtn.other1 = v0;\n        rtn.other2 = v2;\n    }\n    return rtn;\n}\n\nBondPairPointer BondPair_create(Pair pr)\n{\n    BondPairPointer rtn = calloc(1, sizeof(BondPair));\n    *rtn = BondPair_initialize(pr);\n\n    return rtn;\n}\n\n/**\n * Returns 1 if the lines intersect, otherwise 0. In Vector_addition, if the\n * lines intersect the intersection point may be stored in the const doubles i_x\n * and i_y.  \n * Credit: http://stackoverflow.com/users/78216/gavin\n */\nint BondPair_intersect(const BondPair bpr, VectorPointer v) \n{\n    assert(v);\n\n    BondPointer b0, b1;\n    b0 = bpr.fst; b1 = bpr.snd;\n    \n    VertexPointer vertices[4];\n    vertices[0] = b0->fst; \n    vertices[1] = b0->snd; \n    vertices[2] = b1->fst; \n    vertices[3] = b1->snd;\n\n    double p0_x, p0_y, p1_x, p1_y, p2_x, p2_y, p3_x, p3_y;\n    p0_x = vertices[0]->pos.x; p0_y = vertices[0]->pos.y;\n    p1_x = vertices[1]->pos.x; p1_y = vertices[1]->pos.y;\n    p2_x = vertices[2]->pos.x; p2_y = vertices[2]->pos.y;\n    p3_x = vertices[3]->pos.x; p3_y = vertices[3]->pos.y;\n\n    double s1_x, s1_y, s2_x, s2_y;\n    s1_x = p1_x - p0_x;     \n    s1_y = p1_y - p0_y;\n    s2_x = p3_x - p2_x;     \n    s2_y = p3_y - p2_y;\n\n    double s, t;\n    s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / \n        (-s2_x * s1_y + s1_x * s2_y);\n    t = ( s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / \n        (-s2_x * s1_y + s1_x * s2_y);\n\n    if (s >= EPS && s <= 1 - EPS && \n        t >= EPS && t <= 1 - EPS)\n    {\n        double i_x, i_y;\n        i_x = p0_x + (t * s1_x);\n        i_y = p0_y + (t * s1_y);\n        *v = Vector_initialize(i_x, i_y);\n        return 1;\n    }\n    return 0; \n}\n\ndouble BondPair_angular_energy(const BondPairPointer bpr)\n{\n    VertexPointer vi, vj, vk;\n    vi = bpr->other1; \n    vj = bpr->common;\n    vk = bpr->other2; \n\n    double xji, yji, xjk, yjk;\n    xji = vi->pos.x - vj->pos.x; yji = vi->pos.y - vj->pos.y;\n    xjk = vk->pos.x - vj->pos.x; yjk = vk->pos.y - vj->pos.y;\n\n    Vector vecji, vecjk;\n    vecji = Vector_initialize(xji, yji);\n    vecjk = Vector_initialize(xjk, yjk);\n    \n    double theta; \n    theta = Vector_angle(vecji, vecjk);\n    \n    double wij, theta0;\n    wij = angular_weight(bpr);\n    theta0 = (2 * M_PI) / (vj->mass - 1);\n\n    return wij * pow(theta - theta0, 2);\n}\n\nVectorPointer BondPair_angular_gradient(const BondPairPointer bpr)\n{\n    VertexPointer vi, vj, vk;\n    vi = bpr->other1; \n    vj = bpr->common;\n    vk = bpr->other2; \n    \n    Vector v0, v1, v2; \n    v0 = vi->pos; v1 = vj->pos; v2 = vk->pos;\n    \n    double w;\n    int m;\n    w = angular_weight(bpr);\n    m = vj->mass - 1;\n\n    double gradient[6];\n    gradient[0] = AngularGradient_dfx0(v0, v1, v2, w, m);\n    gradient[1] = AngularGradient_dfy0(v0, v1, v2, w, m);\n    gradient[2] = AngularGradient_dfx1(v0, v1, v2, w, m);\n    gradient[3] = AngularGradient_dfy1(v0, v1, v2, w, m);\n    gradient[4] = AngularGradient_dfx2(v0, v1, v2, w, m);\n    gradient[5] = AngularGradient_dfy2(v0, v1, v2, w, m);\n\n    assert(!(gradient[0] != gradient[0]));\n    assert(!(gradient[1] != gradient[1]));\n    assert(!(gradient[2] != gradient[2]));\n    assert(!(gradient[3] != gradient[3]));\n    assert(!(gradient[4] != gradient[4]));\n    assert(!(gradient[5] != gradient[5]));\n    \n    VectorPointer rtn = Util_allocate(3, sizeof(Vector));\n\n    rtn[0] = Vector_scalar_mult(Vector_initialize(gradient[0], gradient[1]), w);\n    rtn[1] = Vector_scalar_mult(Vector_initialize(gradient[2], gradient[3]), w);\n    rtn[2] = Vector_scalar_mult(Vector_initialize(gradient[4], gradient[5]), w);\n\n    return rtn;\n}\n\nint BondPair_has_common_vertex(const BondPair bpr) \n{\n    BondPointer bp1, bp2;\n    bp1 = bpr.fst; bp2 = bpr.snd;\n    return  bp1->fst->id == bp2->fst->id ||\n            bp1->fst->id == bp2->snd->id || \n            bp1->snd->id == bp2->fst->id ||\n            bp1->snd->id == bp2->snd->id;\n}\n\nvoid BondPairs_free(const BondPairPointer bprs)\n{\n    BondPairPointer bpr = bprs;\n    while(bpr != NULL) {\n        BondPairPointer tmp = bpr;\n        bpr = bpr->next;\n        free(tmp);\n        tmp = NULL;\n    }\n}\n\n","/*****************************************************************************\n\n* File Name: Bond_set.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 31-07-2015\n\n*****************************************************************************/\n\n#include \"util.h\"\n#include \"vertex_set.h\"\n#include \"bond_set.h\"\n\nBondSet BondSet_initialize(VertexPointer *vs, json_value *contents, int *nbp)\n{\n    int i, fstid, sndid;\n    double len;\n    VertexPointer fst, snd;\n\n    json_value *bsarr = contents->u.object.values[1].value;\n    *nbp = bsarr->u.array.length;\n    int nb;\n    nb = *nbp;\n\n    BondSet rtn;\n    rtn.set = (BondPointer *) Util_allocate(nb, sizeof(BondPointer));\n    rtn.n = nb;\n\n    for (i = 0; i < nb; i++) {\n        \n        json_value *Bond = bsarr->u.array.values[i];\n        \n        json_value *first = Bond->u.object.values[0].value;\n        json_value *second = Bond->u.object.values[1].value;\n        json_value *length = Bond->u.object.values[2].value;\n\n        if (first->type == json_integer && second->type == json_integer) {\n            fstid = first->u.integer;\n            sndid = second->u.integer;\n        } else {\n            Util_runtime_error(\"Bad JSON data\");\n        }\n\n        if (length->type == json_integer) {\n            len = (double) length->u.integer;\n        } else if (length->type == json_double) {\n            len = (double) length->u.dbl;\n        } else {\n            Util_runtime_error(\"Bad JSON data\\n\");\n        }\n\n        fst = *(vs + fstid);\n        snd = *(vs + sndid);\n\n        BondPointer bp;\n        bp = Bond_create(fst, snd, len);\n        *(rtn.set + i) = bp;\n    }\n\n    return rtn;\n}\n\nBondPointer BondSet_get_bond(const BondSet bs, const int i) \n{\n    return *(bs.set + i);  \n}\n\nBondSetPointer BondSet_create(\n        VertexPointer *vs, \n        json_value *contents, \n        int *nbp\n    )\n{\n    BondSetPointer rtn;\n    rtn = (BondSetPointer) malloc(sizeof(BondSet));\n    *rtn = BondSet_initialize(vs, contents, nbp);\n    return rtn;\n}\n\nint *Bondset_to_array(BondSet bs)\n{\n    int *rtn = (int *) Util_allocate(bs.n * 2, sizeof(int));\n    int i;\n    for (i = 0; i < bs.n; i++) {\n        *(rtn + i * 2) = (*(bs.set + i))->fst->id;\n        *(rtn + i * 2 + 1) = (*(bs.set + i))->snd->id;\n    }\n    return rtn;\n}\n\nvoid BondSet_free(BondSet bs) \n{\n    int i;\n    for (i = 0; i < bs.n; i++) {\n        Bond_free(*(bs.set + i));\n    }\n    free(bs.set);\n}\n\n","\n#include <stdio.h>\n#include \"constants.h\"\n#include \"vector.h\"\n#include \"util.h\"\n\n#include <math.h>\n\n\ndouble CrossingGradient_df0x0(\n        Vector v0, \n        Vector v1, \n        Vector v2,\n        Vector v3\n)\n {\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n\tx0=v0.x;\n\ty0=v0.y;\n\tx1=v1.x;\n\ty1=v1.y;\n\tx2=v2.x;\n\ty2=v2.y;\n\tx3=v3.x;\n\ty3=v3.y;\nreturn (4*(((2*pow(-x0+x1,2)*(y2-y3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(2*pow(-y0+y1,2)*(y2-y3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)-(2*pow(-x0+x1,2)*(y2-y3)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*pow(-y0+y1,2)*(y2-y3)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*(-x0+x1)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))/(2.*sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)))+(2*(-1-((-x0+x1)*(y2-y3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))+((-x0+x1)*(y2-y3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))*(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+2*(-(((-y0+y1)*(y2-y3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+((-y0+y1)*(y2-y3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))))/(2.*sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))*(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))+(2*(-x0+x1)*pow(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)),2))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))*pow(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)),2));\n}\n\ndouble CrossingGradient_df0y0(\n        Vector v0, \n        Vector v1, \n        Vector v2,\n        Vector v3\n)\n{\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n\tx0=v0.x;\n\ty0=v0.y;\n\tx1=v1.x;\n\ty1=v1.y;\n\tx2=v2.x;\n\ty2=v2.y;\n\tx3=v3.x;\n\ty3=v3.y;\nreturn (4*(((2*pow(-x0+x1,2)*(-x2+x3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(2*(-x2+x3)*pow(-y0+y1,2)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)-(2*pow(-x0+x1,2)*(-x2+x3)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*(-x2+x3)*pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*(-y0+y1)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))/(2.*sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)))+(2*(-(((-x0+x1)*(-x2+x3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+((-x0+x1)*(-x2+x3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+2*(-1-((-x2+x3)*(-y0+y1))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))+((-x2+x3)*(-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))*(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))))/(2.*sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))*(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))+(2*(-y0+y1)*pow(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)),2))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))*pow(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)),2));\n}\n\ndouble CrossingGradient_df0x1(\n        Vector v0, \n        Vector v1, \n        Vector v2,\n        Vector v3\n)\n{\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n\tx0=v0.x;\n\ty0=v0.y;\n\tx1=v1.x;\n\ty1=v1.y;\n\tx2=v2.x;\n\ty2=v2.y;\n\tx3=v3.x;\n\ty3=v3.y;\nreturn (4*(((-2*pow(-x0+x1,2)*(-y2+y3)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*pow(-y0+y1,2)*(-y2+y3)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)+(2*(-x0+x1)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))/(2.*sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)))+(2*(((-x0+x1)*(-y2+y3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)-((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))*(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+(2*(-y0+y1)*(-y2+y3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3))*(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))/(2.*sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))*(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))-(2*(-x0+x1)*pow(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)),2))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))*pow(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)),2));\n}\n\ndouble CrossingGradient_df0y1(\n        Vector v0, \n        Vector v1, \n        Vector v2,\n        Vector v3\n)\n{\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n\tx0=v0.x;\n\ty0=v0.y;\n\tx1=v1.x;\n\ty1=v1.y;\n\tx2=v2.x;\n\ty2=v2.y;\n\tx3=v3.x;\n\ty3=v3.y;\nreturn (4*(((-2*pow(-x0+x1,2)*(x2-x3)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*(x2-x3)*pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)+(2*(-y0+y1)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))/(2.*sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)))+((2*(-x0+x1)*(x2-x3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3))*(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+2*(((x2-x3)*(-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)-((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))*(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))))/(2.*sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))*(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))-(2*(-y0+y1)*pow(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)),2))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))*pow(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)),2));\n}\n\ndouble CrossingGradient_df0x2(\n        Vector v0, \n        Vector v1, \n        Vector v2,\n        Vector v3\n)\n{\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n\tx0=v0.x;\n\ty0=v0.y;\n\tx1=v1.x;\n\ty1=v1.y;\n\tx2=v2.x;\n\ty2=v2.y;\n\tx3=v3.x;\n\ty3=v3.y;\nreturn (4*(((2*pow(-x0+x1,2)*(-y0+y3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(2*pow(-y0+y1,2)*(-y0+y3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)-(2*pow(-x0+x1,2)*(-y0+y1)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*pow(-y0+y1,3)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3))/(2.*sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)))+(2*(1-((-x0+x1)*(-y0+y3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))+((-x0+x1)*(-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+2*(-(((-y0+y1)*(-y0+y3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+(pow(-y0+y1,2)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))))/(2.*sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))*(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))+(2*(-x2+x3)*pow(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)),2))/(sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))*pow(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)),2));\n}\n\ndouble CrossingGradient_df0y2(\n        Vector v0, \n        Vector v1, \n        Vector v2,\n        Vector v3\n)\n{\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n\tx0=v0.x;\n\ty0=v0.y;\n\tx1=v1.x;\n\ty1=v1.y;\n\tx2=v2.x;\n\ty2=v2.y;\n\tx3=v3.x;\n\ty3=v3.y;\nreturn (4*(((2*pow(-x0+x1,2)*(x0-x3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(2*(x0-x3)*pow(-y0+y1,2)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)-(2*(x0-x1)*pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*(x0-x1)*pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3))/(2.*sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)))+(2*(-(((-x0+x1)*(x0-x3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+((x0-x1)*(-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+2*(1-((x0-x3)*(-y0+y1))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))+((x0-x1)*(-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))))/(2.*sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))*(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))+(2*(-y2+y3)*pow(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)),2))/(sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))*pow(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)),2));\n}\n\ndouble CrossingGradient_df0x3(\n        Vector v0, \n        Vector v1, \n        Vector v2,\n        Vector v3\n)\n{\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n\tx0=v0.x;\n\ty0=v0.y;\n\tx1=v1.x;\n\ty1=v1.y;\n\tx2=v2.x;\n\ty2=v2.y;\n\tx3=v3.x;\n\ty3=v3.y;\nreturn (4*(((2*pow(-x0+x1,2)*(y0-y2)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(2*pow(-y0+y1,2)*(y0-y2)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)-(2*pow(-x0+x1,2)*(y0-y1)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*(y0-y1)*pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3))/(2.*sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)))+(2*(-(((-x0+x1)*(y0-y2))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+((-x0+x1)*(y0-y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+2*(-(((-y0+y1)*(y0-y2))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+((y0-y1)*(-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))))/(2.*sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))*(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))-(2*(-x2+x3)*pow(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)),2))/(sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))*pow(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)),2));\n}\n\ndouble CrossingGradient_df0y3(\n        Vector v0, \n        Vector v1, \n        Vector v2,\n        Vector v3\n)\n{\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n\tx0=v0.x;\n\ty0=v0.y;\n\tx1=v1.x;\n\ty1=v1.y;\n\tx2=v2.x;\n\ty2=v2.y;\n\tx3=v3.x;\n\ty3=v3.y;\nreturn (4*(((2*pow(-x0+x1,2)*(-x0+x2)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(2*(-x0+x2)*pow(-y0+y1,2)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)-(2*pow(-x0+x1,3)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*(-x0+x1)*pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3))/(2.*sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)))+(2*(-(((-x0+x1)*(-x0+x2))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+(pow(-x0+x1,2)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+2*(-(((-x0+x2)*(-y0+y1))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+((-x0+x1)*(-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))))/(2.*sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))*(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))-(2*(-y2+y3)*pow(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)),2))/(sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))*pow(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)),2));\n}\n\n\ndouble CrossingGradient_df1x0(\n        Vector v0, \n        Vector v1, \n        Vector v2,\n        Vector v3\n)\n {\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n\tx0=v0.x;\n\ty0=v0.y;\n\tx1=v1.x;\n\ty1=v1.y;\n\tx2=v2.x;\n\ty2=v2.y;\n\tx3=v3.x;\n\ty3=v3.y;\nreturn -(-x0+x1)/(4.*sqrt(pow(-x0+x1,2)+pow(-y0+y1,2)))-(4*((-x0+x1)/(2.*sqrt(pow(-x0+x1,2)+pow(-y0+y1,2)))+((2*pow(-x0+x1,2)*(y2-y3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(2*pow(-y0+y1,2)*(y2-y3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)-(2*pow(-x0+x1,2)*(y2-y3)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*pow(-y0+y1,2)*(y2-y3)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*(-x0+x1)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))/(2.*sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)))+(2*(-1-((-x0+x1)*(y2-y3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))+((-x0+x1)*(y2-y3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))*(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+2*(-(((-y0+y1)*(y2-y3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+((-y0+y1)*(y2-y3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))))/(2.*sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))*(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))/2.+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))-(2*(-x0+x1)*pow(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))/2.+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)),2))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))*pow(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)),2));\n}\n\ndouble CrossingGradient_df1y0(\n        Vector v0, \n        Vector v1, \n        Vector v2,\n        Vector v3\n)\n {\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n\tx0=v0.x;\n\ty0=v0.y;\n\tx1=v1.x;\n\ty1=v1.y;\n\tx2=v2.x;\n\ty2=v2.y;\n\tx3=v3.x;\n\ty3=v3.y;\nreturn -(-y0+y1)/(4.*sqrt(pow(-x0+x1,2)+pow(-y0+y1,2)))-(4*((-y0+y1)/(2.*sqrt(pow(-x0+x1,2)+pow(-y0+y1,2)))+((2*pow(-x0+x1,2)*(-x2+x3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(2*(-x2+x3)*pow(-y0+y1,2)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)-(2*pow(-x0+x1,2)*(-x2+x3)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*(-x2+x3)*pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*(-y0+y1)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))/(2.*sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)))+(2*(-(((-x0+x1)*(-x2+x3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+((-x0+x1)*(-x2+x3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+2*(-1-((-x2+x3)*(-y0+y1))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))+((-x2+x3)*(-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))*(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))))/(2.*sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))*(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))/2.+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))-(2*(-y0+y1)*pow(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))/2.+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)),2))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))*pow(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)),2));\n}\n\ndouble CrossingGradient_df1x1(\n        Vector v0, \n        Vector v1, \n        Vector v2,\n        Vector v3\n)\n {\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n\tx0=v0.x;\n\ty0=v0.y;\n\tx1=v1.x;\n\ty1=v1.y;\n\tx2=v2.x;\n\ty2=v2.y;\n\tx3=v3.x;\n\ty3=v3.y;\nreturn (-x0+x1)/(4.*sqrt(pow(-x0+x1,2)+pow(-y0+y1,2)))-(4*(-(-x0+x1)/(2.*sqrt(pow(-x0+x1,2)+pow(-y0+y1,2)))+((-2*pow(-x0+x1,2)*(-y2+y3)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*pow(-y0+y1,2)*(-y2+y3)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)+(2*(-x0+x1)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))/(2.*sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)))+(2*(((-x0+x1)*(-y2+y3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)-((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))*(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+(2*(-y0+y1)*(-y2+y3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3))*(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))/(2.*sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))*(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))/2.+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))+(2*(-x0+x1)*pow(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))/2.+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)),2))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))*pow(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)),2));\n}\n\ndouble CrossingGradient_df1y1(\n        Vector v0, \n        Vector v1, \n        Vector v2,\n        Vector v3\n)\n {\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n\tx0=v0.x;\n\ty0=v0.y;\n\tx1=v1.x;\n\ty1=v1.y;\n\tx2=v2.x;\n\ty2=v2.y;\n\tx3=v3.x;\n\ty3=v3.y;\nreturn (-y0+y1)/(4.*sqrt(pow(-x0+x1,2)+pow(-y0+y1,2)))-(4*(-(-y0+y1)/(2.*sqrt(pow(-x0+x1,2)+pow(-y0+y1,2)))+((-2*pow(-x0+x1,2)*(x2-x3)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*(x2-x3)*pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)+(2*(-y0+y1)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))/(2.*sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)))+((2*(-x0+x1)*(x2-x3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3))*(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+2*(((x2-x3)*(-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)-((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))*(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))))/(2.*sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))*(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))/2.+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))+(2*(-y0+y1)*pow(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))/2.+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)),2))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))*pow(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)),2));\n}\n\ndouble CrossingGradient_df1x2(\n        Vector v0, \n        Vector v1, \n        Vector v2,\n        Vector v3\n)\n {\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n\tx0=v0.x;\n\ty0=v0.y;\n\tx1=v1.x;\n\ty1=v1.y;\n\tx2=v2.x;\n\ty2=v2.y;\n\tx3=v3.x;\n\ty3=v3.y;\nreturn -(-x2+x3)/(4.*sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))-(4*((-x2+x3)/(2.*sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))+((2*pow(-x0+x1,2)*(-y0+y3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(2*pow(-y0+y1,2)*(-y0+y3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)-(2*pow(-x0+x1,2)*(-y0+y1)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*pow(-y0+y1,3)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3))/(2.*sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)))+(2*(1-((-x0+x1)*(-y0+y3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))+((-x0+x1)*(-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+2*(-(((-y0+y1)*(-y0+y3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+(pow(-y0+y1,2)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))))/(2.*sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))*(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))/2.+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))-(2*(-x2+x3)*pow(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))/2.+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)),2))/(sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))*pow(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)),2));\n}\n\ndouble CrossingGradient_df1y2(\n        Vector v0, \n        Vector v1, \n        Vector v2,\n        Vector v3\n)\n{\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n\tx0=v0.x;\n\ty0=v0.y;\n\tx1=v1.x;\n\ty1=v1.y;\n\tx2=v2.x;\n\ty2=v2.y;\n\tx3=v3.x;\n\ty3=v3.y;\nreturn -(-y2+y3)/(4.*sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))-(4*((-y2+y3)/(2.*sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))+((2*pow(-x0+x1,2)*(x0-x3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(2*(x0-x3)*pow(-y0+y1,2)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)-(2*(x0-x1)*pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*(x0-x1)*pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3))/(2.*sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)))+(2*(-(((-x0+x1)*(x0-x3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+((x0-x1)*(-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+2*(1-((x0-x3)*(-y0+y1))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))+((x0-x1)*(-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))))/(2.*sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))*(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))/2.+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))-(2*(-y2+y3)*pow(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))/2.+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)),2))/(sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))*pow(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)),2));\n}\n\n\ndouble CrossingGradient_df1x3(\n        Vector v0, \n        Vector v1, \n        Vector v2,\n        Vector v3\n)\n {\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n\tx0=v0.x;\n\ty0=v0.y;\n\tx1=v1.x;\n\ty1=v1.y;\n\tx2=v2.x;\n\ty2=v2.y;\n\tx3=v3.x;\n\ty3=v3.y;\nreturn (-x2+x3)/(4.*sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))-(4*(-(-x2+x3)/(2.*sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))+((2*pow(-x0+x1,2)*(y0-y2)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(2*pow(-y0+y1,2)*(y0-y2)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)-(2*pow(-x0+x1,2)*(y0-y1)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*(y0-y1)*pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3))/(2.*sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)))+(2*(-(((-x0+x1)*(y0-y2))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+((-x0+x1)*(y0-y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+2*(-(((-y0+y1)*(y0-y2))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+((y0-y1)*(-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))))/(2.*sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))*(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))/2.+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))+(2*(-x2+x3)*pow(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))/2.+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)),2))/(sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))*pow(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)),2));\n}\n\ndouble CrossingGradient_df1y3(\n        Vector v0, \n        Vector v1, \n        Vector v2,\n        Vector v3\n)\n {\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n\tx0=v0.x;\n\ty0=v0.y;\n\tx1=v1.x;\n\ty1=v1.y;\n\tx2=v2.x;\n\ty2=v2.y;\n\tx3=v3.x;\n\ty3=v3.y;\nreturn (-y2+y3)/(4.*sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))-(4*(-(-y2+y3)/(2.*sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))+((2*pow(-x0+x1,2)*(-x0+x2)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(2*(-x0+x2)*pow(-y0+y1,2)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)-(2*pow(-x0+x1,3)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*(-x0+x1)*pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3))/(2.*sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)))+(2*(-(((-x0+x1)*(-x0+x2))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+(pow(-x0+x1,2)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+2*(-(((-x0+x2)*(-y0+y1))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+((-x0+x1)*(-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))))/(2.*sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))*(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))/2.+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))+(2*(-y2+y3)*pow(sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))/2.+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)),2))/(sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))*pow(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)),2));\n}\n\n\ndouble CrossingGradient_df2x0(\n        Vector v0, \n        Vector v1, \n        Vector v2,\n        Vector v3\n)\n {\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n\tx0=v0.x;\n\ty0=v0.y;\n\tx1=v1.x;\n\ty1=v1.y;\n\tx2=v2.x;\n\ty2=v2.y;\n\tx3=v3.x;\n\ty3=v3.y;\nreturn (4*((-x0+x1)/sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+((2*pow(-x0+x1,2)*(y2-y3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(2*pow(-y0+y1,2)*(y2-y3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)-(2*pow(-x0+x1,2)*(y2-y3)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*pow(-y0+y1,2)*(y2-y3)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*(-x0+x1)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))/(2.*sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)))+(2*(-1-((-x0+x1)*(y2-y3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))+((-x0+x1)*(y2-y3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))*(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+2*(-(((-y0+y1)*(y2-y3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+((-y0+y1)*(y2-y3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))))/(2.*sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))*(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))+sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))+(2*(-x0+x1)*pow(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))+sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)),2))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))*pow(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)),2));\n}\n\ndouble CrossingGradient_df2y0(\n        Vector v0, \n        Vector v1, \n        Vector v2,\n        Vector v3\n)\n {\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n\tx0=v0.x;\n\ty0=v0.y;\n\tx1=v1.x;\n\ty1=v1.y;\n\tx2=v2.x;\n\ty2=v2.y;\n\tx3=v3.x;\n\ty3=v3.y;\nreturn (4*((-y0+y1)/sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+((2*pow(-x0+x1,2)*(-x2+x3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(2*(-x2+x3)*pow(-y0+y1,2)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)-(2*pow(-x0+x1,2)*(-x2+x3)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*(-x2+x3)*pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*(-y0+y1)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))/(2.*sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)))+(2*(-(((-x0+x1)*(-x2+x3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+((-x0+x1)*(-x2+x3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+2*(-1-((-x2+x3)*(-y0+y1))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))+((-x2+x3)*(-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))*(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))))/(2.*sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))*(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))+sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))+(2*(-y0+y1)*pow(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))+sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)),2))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))*pow(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)),2));\n }\n\ndouble CrossingGradient_df2x1(\n        Vector v0, \n        Vector v1, \n        Vector v2,\n        Vector v3\n)\n {\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n\tx0=v0.x;\n\ty0=v0.y;\n\tx1=v1.x;\n\ty1=v1.y;\n\tx2=v2.x;\n\ty2=v2.y;\n\tx3=v3.x;\n\ty3=v3.y;\nreturn (4*(-((-x0+x1)/sqrt(pow(-x0+x1,2)+pow(-y0+y1,2)))+((-2*pow(-x0+x1,2)*(-y2+y3)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*pow(-y0+y1,2)*(-y2+y3)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)+(2*(-x0+x1)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))/(2.*sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)))+(2*(((-x0+x1)*(-y2+y3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)-((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))*(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+(2*(-y0+y1)*(-y2+y3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3))*(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))/(2.*sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))*(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))+sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))-(2*(-x0+x1)*pow(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))+sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)),2))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))*pow(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)),2));\n}\n\ndouble CrossingGradient_df2y1(\n        Vector v0, \n        Vector v1, \n        Vector v2,\n        Vector v3\n)\n{\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n\tx0=v0.x;\n\ty0=v0.y;\n\tx1=v1.x;\n\ty1=v1.y;\n\tx2=v2.x;\n\ty2=v2.y;\n\tx3=v3.x;\n\ty3=v3.y;\nreturn (4*(-((-y0+y1)/sqrt(pow(-x0+x1,2)+pow(-y0+y1,2)))+((-2*pow(-x0+x1,2)*(x2-x3)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*(x2-x3)*pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)+(2*(-y0+y1)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))/(2.*sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)))+((2*(-x0+x1)*(x2-x3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3))*(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+2*(((x2-x3)*(-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)-((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))*(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))))/(2.*sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))*(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))+sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))-(2*(-y0+y1)*pow(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))+sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)),2))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))*pow(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)),2));\n}\n\ndouble CrossingGradient_df2x2(\n        Vector v0, \n        Vector v1, \n        Vector v2,\n        Vector v3\n)\n{\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n\tx0=v0.x;\n\ty0=v0.y;\n\tx1=v1.x;\n\ty1=v1.y;\n\tx2=v2.x;\n\ty2=v2.y;\n\tx3=v3.x;\n\ty3=v3.y;\nreturn (4*((-x2+x3)/sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))+((2*pow(-x0+x1,2)*(-y0+y3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(2*pow(-y0+y1,2)*(-y0+y3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)-(2*pow(-x0+x1,2)*(-y0+y1)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*pow(-y0+y1,3)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3))/(2.*sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)))+(2*(1-((-x0+x1)*(-y0+y3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))+((-x0+x1)*(-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+2*(-(((-y0+y1)*(-y0+y3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+(pow(-y0+y1,2)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))))/(2.*sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))*(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))+sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))+(2*(-x2+x3)*pow(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))+sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)),2))/(sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))*pow(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)),2));\n}\n\ndouble CrossingGradient_df2y2(\n        Vector v0, \n        Vector v1, \n        Vector v2,\n        Vector v3\n)\n{\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n\tx0=v0.x;\n\ty0=v0.y;\n\tx1=v1.x;\n\ty1=v1.y;\n\tx2=v2.x;\n\ty2=v2.y;\n\tx3=v3.x;\n\ty3=v3.y;\nreturn (4*((-y2+y3)/sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))+((2*pow(-x0+x1,2)*(x0-x3)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(2*(x0-x3)*pow(-y0+y1,2)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)-(2*(x0-x1)*pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*(x0-x1)*pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3))/(2.*sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)))+(2*(-(((-x0+x1)*(x0-x3))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+((x0-x1)*(-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+2*(1-((x0-x3)*(-y0+y1))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))+((x0-x1)*(-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))))/(2.*sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))*(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))+sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))+(2*(-y2+y3)*pow(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))+sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)),2))/(sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))*pow(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)),2));\n}\n\ndouble CrossingGradient_df2x3(\n        Vector v0, \n        Vector v1, \n        Vector v2,\n        Vector v3\n)\n{\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n\tx0=v0.x;\n\ty0=v0.y;\n\tx1=v1.x;\n\ty1=v1.y;\n\tx2=v2.x;\n\ty2=v2.y;\n\tx3=v3.x;\n\ty3=v3.y;\nreturn (4*(-((-x2+x3)/sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))+((2*pow(-x0+x1,2)*(y0-y2)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(2*pow(-y0+y1,2)*(y0-y2)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)-(2*pow(-x0+x1,2)*(y0-y1)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*(y0-y1)*pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3))/(2.*sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)))+(2*(-(((-x0+x1)*(y0-y2))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+((-x0+x1)*(y0-y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+2*(-(((-y0+y1)*(y0-y2))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+((y0-y1)*(-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))))/(2.*sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))*(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))+sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))-(2*(-x2+x3)*pow(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))+sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)),2))/(sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))*pow(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)),2));\n}\n\ndouble CrossingGradient_df2y3(\n        Vector v0, \n        Vector v1, \n        Vector v2,\n        Vector v3\n)\n{\n    double x0, y0, x1, y1, x2, y2, x3, y3;\n\tx0=v0.x;\n\ty0=v0.y;\n\tx1=v1.x;\n\ty1=v1.y;\n\tx2=v2.x;\n\ty2=v2.y;\n\tx3=v3.x;\n\ty3=v3.y;\nreturn (4*(-((-y2+y3)/sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))+((2*pow(-x0+x1,2)*(-x0+x2)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(2*(-x0+x2)*pow(-y0+y1,2)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)-(2*pow(-x0+x1,3)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3)-(2*(-x0+x1)*pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),3))/(2.*sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)))+(2*(-(((-x0+x1)*(-x0+x2))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+(pow(-x0+x1,2)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+2*(-(((-x0+x2)*(-y0+y1))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)))+((-x0+x1)*(-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))*(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3))))/(2.*sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))*(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))+sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2))))/(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)))-(2*(-y2+y3)*pow(-sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))-sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))+sqrt((pow(-x0+x1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2)+(pow(-y0+y1,2)*pow((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3),2))/pow(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3),2))+sqrt(pow(-x0+x2-((-x0+x1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)+pow(-y0+y2-((-y0+y1)*((-x2+x3)*(y0-y2)-(x0-x2)*(-y2+y3)))/(-((-x2+x3)*(-y0+y1))+(-x0+x1)*(-y2+y3)),2)),2))/(sqrt(pow(-x2+x3,2)+pow(-y2+y3,2))*pow(sqrt(pow(-x0+x1,2)+pow(-y0+y1,2))+sqrt(pow(-x2+x3,2)+pow(-y2+y3,2)),2));\n}\n\n","/*****************************************************************************\n\n* File Name: objective.c \n* Author: Ludvp0g Sundström\n\n* Description: The objective function F = F1 + F2 + F3 + F4 where FN considers\n* N vertices. \n\n* Creation Date: 05-07-2015\n\n*****************************************************************************/\n\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"constants.h\"\n#include \"graph.h\"\n#include \"util.h\"\n#include \"energy.h\"\n\n/* Private ******************************************************************/\n\nstatic void first_order(const GraphPointer graph) \n{\n    VertexSet vs; \n    vs = graph->vs;\n    int i;\n    for (i = 0; i < vs.n; i++) {\n        VertexPointer v = *(vs.set + i);\n        double e;\n        e = Vertex_potential_energy(v);\n        graph->energy += e;\n        v->energy = e;\n    }\n}\n\nstatic void second_order_attraction(const GraphPointer graph) \n{\n    BondSet bs;\n    bs = graph->bs;\n    int i;\n    for (i = 0; i < bs.n; i++) {\n        BondPointer b;\n        b = *(bs.set + i);\n        double e;\n        e = Bond_attraction_energy(b);\n        graph->energy += e;\n        b->fst->energy += e / 2;\n        b->snd->energy += e / 2;\n    }\n}\n\nstatic void second_order_repulsion(const GraphPointer graph) \n{\n    GridPointer grid;\n    grid = graph->grid;\n    int i;\n    for (i = 0; i < grid->npz; i++) {\n        ZonePointer zp = *(grid->pzps + i);\n        VertexPointer v0 = zp->members;\n        while (v0->next) {\n            VertexPointer v1;\n            v1 = v0->next; \n            while (v1) {\n                Pair pr;\n                if (v0->id > v1->id) {\n                    pr = Pair_initialize(v1, v0);\n                } else {\n                    pr = Pair_initialize(v0, v1);\n                }\n                double e;\n                e = VertexPair_repulsion_energy(pr);\n                graph->energy += e;\n                v0->energy += e / 2;\n                v1->energy += e / 2;\n                v1 = v1->next;\n            }\n            v0 = v0->next;\n        }\n    }\n    ZonePairPointer z2p = grid->azps;\n    while (z2p) {\n        VertexPointer v0;\n        v0 = z2p->fst->members;\n        while (v0) {\n            VertexPointer v1;\n            v1 = z2p->snd->members;\n            while (v1) {\n                Pair pr;\n                if (v0->id > v1->id) {\n                    pr = Pair_initialize(v1, v0);\n                } else {\n                    pr = Pair_initialize(v0, v1);\n                }\n                double e;\n                e = VertexPair_repulsion_energy(pr);\n                graph->energy += e;\n                v0->energy += e / 2;\n                v1->energy += e / 2;\n                v1 = v1->next;          \n            }\n            v0 = v0->next;\n        }\n        z2p = z2p->next;\n    }\n}\n\nstatic void second_order(const GraphPointer graph)\n{\n    second_order_attraction(graph);\n    second_order_repulsion(graph);\n}\n\nstatic void third_order(const GraphPointer graph)\n{\n    \n    BondPairPointer bpr;\n    bpr = graph->con;\n\n    while (bpr) {\n        double e;\n        e = BondPair_angular_energy(bpr);\n        graph->energy += e;\n        bpr->common->energy += e / 3;\n        bpr->other1->energy += e / 3;\n        bpr->other2->energy += e / 3;\n        bpr = bpr->next;\n    }\n}\n\nstatic void fourth_order(const GraphPointer graph)\n{\n    BondCrossPointer bcrs;\n    bcrs = graph->crs;\n\n    while (bcrs) {\n        double e;\n        e = BondCross_crossing_energy(bcrs);\n        graph->energy += e;\n        bcrs->bpr.fst->fst->energy += e / 4;\n        bcrs->bpr.fst->snd->energy += e / 4;\n        bcrs->bpr.snd->fst->energy += e / 4;\n        bcrs->bpr.snd->snd->energy += e / 4;\n        bcrs = bcrs->next;\n    }\n}\n\n/* Public *******************************************************************/\n\nvoid Energy_calculate(const GraphPointer graph) \n{\n    graph->energy = 0.0;\n    first_order(graph);\n    second_order(graph);\n    third_order(graph);\n    fourth_order(graph);\n}\n\n/* Testing facade ***********************************************************/\n\nvoid  (*test_first_order_energy)(const GraphPointer graph) = \n        first_order;\nvoid  (*test_second_order_energy)(const GraphPointer graph) = \n        second_order;\nvoid  (*test_second_order_attraction_energy)(const GraphPointer graph) = \n        second_order_attraction;\nvoid  (*test_second_order_repulsion_energy)(const GraphPointer graph) = \n        second_order_repulsion;\nvoid  (*test_third_order_energy)(const GraphPointer graph) = \n        third_order;\nvoid  (*test_fourth_order_energy)(const GraphPointer graph) = \n        fourth_order;\n\n","/*****************************************************************************\n\n* File Name: global_minimizer.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 13-08-2015\n\n*****************************************************************************/\n\n#include \"constants.h\"\n#include \"util.h\"\n#include \"graph.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n/* Private *****************************************************************/\n\nstatic double move_func()\n{\n    // TODO\n    return ((double) rand()) / RAND_MAX;\n}\n\nstatic VertexPointer pick_candidate_random(const VertexSet vs)\n{\n    int rvi;\n    rvi = ((double) (rand()) / RAND_MAX) * vs.n;\n    assert(rvi <= vs.n);\n    return VertexSet_get_vertex(vs, rvi);\n}\n\nstatic VertexPointer pick_candidate_high_energy(const VertexSet vs)\n{\n    VertexPointer chosen = *vs.set;\n    int i;\n    for (i = 0; i < vs.n; i++) {\n         \n    }\n    return chosen;\n}\n\nstatic Vertex mutate(const GraphPointer graph)\n{\n    assert(graph);\n    assert(graph->vs.n);\n    \n    VertexSet vs = graph->vs;\n    \n    VertexPointer chosen = pick_candidate_high_energy(vs); \n\n    Vertex old_v;\n    old_v = Vertex_copy(*chosen);\n\n    double rx, ry;\n    rx = move_func();\n    ry = move_func();\n    \n    Vertex_move(chosen, Vector_initialize(rx, ry));\n\n    return old_v;\n}\n\n/* Public ******************************************************************/\n\nvoid GlobalMinimizer_run(\n        const GraphPointer graph,\n        void (*e_fun)(GraphPointer)\n    )\n{\n    assert(graph);\n    \n    srand(time(NULL));\n\n    int i; \n    for (i = 0; i < G_ITMAX; i++) {\n        e_fun(graph);\n\n        double old_e; \n        old_e = graph->energy;\n\n        Vertex old_v;\n        old_v = mutate(graph);\n\n        e_fun(graph);\n        double new_e; \n        new_e = graph->energy;\n\n        if (old_e < new_e) {\n            VertexPointer new_v;\n            new_v  = *(graph->vs.set + old_v.id);\n            *new_v = old_v;\n        }\n    }\n}\n\n","/***************************************************************************** \n \n* File Name: gradient.c\n\n* Author: Ludvig Sundström\n\n* Description: The gradient of the objective function.\n\n* Creation Date: 06-07-2015\n\n*****************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#include \"pair.h\"\n#include \"util.h\"\n#include \"constants.h\"\n#include \"graph.h\"\n#include \"vertex_set.h\"\n\n/* Private ******************************************************************/\n\nstatic void apply_repulsion(const VertexPointer vi, const VertexPointer vj) \n{\n    Vector rpls_grad;\n    Pair pr = Pair_initialize(vi, vj);\n    rpls_grad = VertexPair_repulsion_gradient(pr);\n\n    vi->gradient = Vector_add(vi->gradient, rpls_grad);\n    vj->gradient = Vector_add(vj->gradient, Vector_negate(rpls_grad));\n}\n\nstatic void first_order(const VertexSet vs)\n{\n    int i;\n    for (i = 0; i < vs.n; i++) {\n        VertexPointer v;\n        v = *(vs.set + i);\n        v->gradient = Vector_add(v->gradient, Vertex_potential_gradient(v));\n    }\n}\n\nstatic void second_order_repulsion(const GridPointer grid)\n{\n    int i;\n    for (i = 0; i < grid->npz; i++) {\n        ZonePointer z = *(grid->pzps + i);\n        VertexPointer vi = z->members;\n        while (vi->next) {\n            VertexPointer vj;\n            vj = vi->next; \n            while (vj) {\n                if (vi->id > vj->id) {\n                    apply_repulsion(vj, vi);\n                } else {\n                    apply_repulsion(vi, vj);\n                }\n                vj = vj->next;\n            }\n            vi = vi->next;\n        }\n    }\n    ZonePairPointer z2p = grid->azps;\n    while (z2p) {\n        VertexPointer vi;\n        vi = z2p->fst->members;\n        while (vi) {\n            VertexPointer vj;\n            vj = z2p->snd->members;\n            while (vj) {\n                if (vi->id > vj->id) {\n                    apply_repulsion(vj, vi);\n                } else {\n                    apply_repulsion(vi, vj);\n                }\n                vj = vj->next;          \n            }\n            vi = vi->next;\n        }\n        z2p = z2p->next;\n    }\n}\n\nstatic void second_order_attraction(const BondSet bs)\n{\n    int i;\n    for (i = 0; i < bs.n; i++) {\n        BondPointer b;\n        b = *(bs.set + i);\n        Vector grad, neg_grad;\n        grad = Bond_attraction_gradient(b);\n        neg_grad = Vector_negate(grad);\n\n        b->fst->gradient = Vector_add(b->fst->gradient, grad);\n        b->snd->gradient = Vector_add(b->snd->gradient, neg_grad);\n    }\n}\n\nstatic void second_order(const GraphPointer graph)\n{\n    second_order_repulsion(graph->grid);\n    second_order_attraction(graph->bs);\n}\n\nstatic void third_order(const BondPairPointer con)\n{\n    BondPairPointer bpr = con;\n    while (bpr) {\n        \n        VectorPointer grad;\n        grad = BondPair_angular_gradient(bpr);\n        VertexPointer vi, vj, vk;\n        vi = bpr->other1; \n        vj = bpr->common; \n        vk = bpr->other2; \n\n        vi->gradient = Vector_add(vi->gradient, grad[0]);\n        vj->gradient = Vector_add(vj->gradient, grad[1]);\n        vk->gradient = Vector_add(vk->gradient, grad[2]);\n        \n        free(grad); \n\n        bpr = bpr->next;\n    }\n}\n\nstatic void fourth_order(const BondCrossPointer crs)\n{\n    BondCrossPointer bcrs;\n    bcrs = crs;\n    while (bcrs) {\n\n        VectorPointer grad = BondCross_crossing_gradient(bcrs);\n\n        VertexPointer v0, v1, v2, v3;\n        v0 = bcrs->bpr.fst->fst; v1 = bcrs->bpr.fst->snd; \n        v2 = bcrs->bpr.snd->fst; v3 = bcrs->bpr.snd->snd;\n\n        v0->gradient = Vector_add(v0->gradient, grad[0]);\n        v1->gradient = Vector_add(v1->gradient, grad[1]);\n        v2->gradient = Vector_add(v2->gradient, grad[2]);\n        v3->gradient = Vector_add(v3->gradient, grad[3]);\n        \n        free(grad); \n                \n        bcrs = bcrs->next;\n    }\n}\n\n/* Public *******************************************************************/\n\nvoid Gradient_calculate(const GraphPointer graph)\n{\n    first_order(graph->vs);\n    second_order(graph);\n    third_order(graph->con);\n    fourth_order(graph->crs);\n}\n\n/* Test facade *************************************************************/\n\nvoid (*test_first_order_gradient)(const VertexSet vs) = first_order;\nvoid (*test_second_order_gradient)(const GraphPointer graph) = second_order;\nvoid (*test_second_order_attraction_gradient)(const BondSet bs) =second_order_attraction;\nvoid (*test_second_order_repulsion_gradient)(const GridPointer grid) =second_order_repulsion; \nvoid (*test_third_order_gradient)(const BondPairPointer con) = third_order; \nvoid (*test_fourth_order_gradient)(const BondCrossPointer crs) = fourth_order;\n\n","/*****************************************************************************\n\n* File Name: graph.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 07-07-2015\n\n*****************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <stdio.h>\n\n#include \"constants.h\"\n#include \"graph.h\"\n#include \"placement.h\"\n\n#include \"process_input.h\"\n\n/* Private ******************************************************************/\n\nGraphPointer create(VertexSet vs, BondSet bs) \n{\n    assert(vs.set && bs.set);\n    assert(vs.n > 0);\n\n    GraphPointer rtn; \n    rtn = (GraphPointer) calloc(1, sizeof(Graph));\n    \n    rtn->grid = Grid_create(); \n    rtn->con = NULL; rtn->crs = NULL;\n    rtn->energy = 0;\n    rtn->vs = vs; \n    rtn->bs = bs;\n\n    Graph_detect_connected(rtn);\n    \n    assert(rtn); \n    return rtn;\n}\n\n/** \n * Given a vertex in a graph, assign it a zone.\n */\n\nstatic void assign_vertex_to_zone(\n        const GridPointer grid, \n        const VertexPointer v\n    )\n{\n    assert(grid && v);\n    assert(grid->nz > 0 && grid->is_populated);\n    assert(grid->zps && grid->pzps);\n    \n    int i, j; \n    i = Vertex_zone_idx(v);\n    j = Vertex_zone_idy(v);\n\n    Grid_append_member(grid, v, Grid_get_zone(grid, i, j));\n}\n\nstatic void link_bondpair(const GraphPointer graph, const Pair pr) \n{\n    BondPairPointer newpr;\n    newpr = BondPair_create(pr);\n    newpr->next = graph->con;\n    graph->con = newpr;\n}\n\nstatic void link_bondcross(\n        const GraphPointer graph, \n        const BondPair bpr, \n        const Vector cross\n    )\n{\n    BondCrossPointer bcrs;\n    bcrs = BondCross_create(bpr, cross);\n    bcrs->next = graph->crs;\n    graph->crs = bcrs;\n} \n\n/* Public ******************************************************************/\n\nGraphPointer Graph_create(const char *fname) \n{\n    int nv, nb;\n    Pair pr;\n    pr = process_json(fname, &nv, &nb);\n    \n    assert(nb < (double) nv * log((double) nv));\n    assert(pr.fst && pr.snd);\n\n    VertexSetPointer vs;\n    vs = (VertexSetPointer) pr.fst; \n\n    BondSetPointer bs;\n    bs = (BondSetPointer) pr.snd; \n\n    GraphPointer rtn;\n    rtn = create(*vs, *bs);\n\n    free(vs);\n    free(bs);\n\n    Placement_set_spiral(rtn->vs, nv); \n    Graph_reset_dynamics(rtn);\n    \n    assert(rtn->max_vw >= 0 && rtn->max_vh >= 0);\n    assert(rtn->grid && rtn->vs.set && rtn->bs.set);\n    assert(rtn->vs.n > 0 && rtn->vs.n <= MAX_NV);\n    assert(rtn->bs.n >= 0);\n\n    return rtn;\n}\n\nvoid Graph_reset_dynamics(const GraphPointer graph)\n{\n    assert(graph && graph->grid && graph->vs.n > 0 && graph->vs.set);\n\n    Grid_reset_dynamics(graph->grid);\n\n    if (graph->crs) BondCrosses_free(graph->crs);\n    graph->crs = NULL;\n\n    int i;\n    for (i = 0; i < graph->vs.n; i++) {\n        VertexPointer v = *(graph->vs.set + i);\n        Vertex_reset_dynamics(v);\n        assign_vertex_to_zone(graph->grid, v);\n    }\n\n    Grid_check_adjacent(graph->grid);\n    Graph_detect_crosses(graph);\n}\n\nvoid Graph_detect_crosses(const GraphPointer graph)\n{\n    assert(graph && graph->bs.set && graph->bs.n >= 0);\n    assert(!graph->crs);\n\n    BondSet bs;\n    bs = graph->bs;\n\n    int i;\n    for (i = 0; i < bs.n - 1; i++) {\n        int j;\n        for (j = i + 1; j < bs.n; j++) {\n            BondPointer fst, snd;\n            fst = BondSet_get_bond(bs, i);\n            snd = BondSet_get_bond(bs, j);\n\n            BondPair bpr;\n            bpr = BondPair_initialize(Pair_initialize(fst, snd));\n\n            int crossing;\n            Vector cross;\n            crossing = BondPair_intersect(bpr, &cross);\n            if (crossing) {\n                link_bondcross(graph, bpr, cross);\n            } \n        }\n    }\n}\n\nvoid Graph_detect_connected(const GraphPointer graph)\n{\n    assert(!graph->con);\n    int i;\n    for (i = 0; i < graph->bs.n - 1; i++) {\n        int j;\n        for (j = i + 1; j < graph->bs.n; j++) {\n            BondPointer fst, snd;\n            fst = BondSet_get_bond(graph->bs, i);\n            snd = BondSet_get_bond(graph->bs, j);\n            Pair pr = Pair_initialize(fst, snd);\n            int common;\n            common = BondPair_has_common_vertex(BondPair_initialize(pr));\n            if (common) {\n                link_bondpair(graph, Pair_initialize(fst, snd));\n            }\n        }\n    }\n}\n\nvoid Graph_free(const GraphPointer graph)\n{\n    if (graph->con) BondPairs_free(graph->con);\n    if (graph->crs) BondCrosses_free(graph->crs);\n    VertexSet_free(graph->vs);\n    BondSet_free(graph->bs);\n    Grid_free(graph->grid);\n    free(graph->grid);\n    free(graph);\n}\n\n","/*****************************************************************************\n\n* File Name: grid.c\n\n* Author: Ludvig Sundström\n\n* Description: A collection of adjacent zones \n\n* Creation Date: 31-07-2015\n\n*****************************************************************************/\n\n#include <stdlib.h>\n\n#include \"util.h\"\n#include \"pair.h\"\n#include \"constants.h\"\n#include \"grid.h\"\n\n/* Private ******************************************************************/\n\n/* Public *******************************************************************/\n\nGridPointer Grid_create()\n{\n    GridPointer rtn;\n    rtn = (GridPointer) Util_allocate(1, sizeof(Grid));\n\n    rtn->nz = 0;\n\n    int nzones; \n    nzones = GRID_DIM_X * GRID_DIM_Y;\n\n    rtn->zps = (ZonePointer *) Util_allocate_initialize(nzones, sizeof(Zone));\n    int i, j, id;\n    for (j = 0; j < GRID_DIM_Y; j++) {\n        for (i = 0; i < GRID_DIM_X; i++) {\n            id = (j * GRID_DIM_Y) + i;\n            ZonePointer z;\n            z= Zone_create(id, i, j, \n                    (double) i * PADDING, (double) j * PADDING, \n                    (double) PADDING, (double) PADDING);\n            *(rtn->zps + id) = z;\n            rtn->nz++;\n        }\n    }\n    rtn->is_populated = (int *) Util_allocate_initialize(rtn->nz, sizeof(int));\n    rtn->pzps = (ZonePointer *) Util_allocate_initialize(rtn->nz, sizeof(void *));\n    rtn->azps = NULL;\n    rtn->npz = 0;\n    \n    return rtn;\n}\n\nZonePointer Grid_get_zone(const GridPointer grid, const int x, const int y)\n{\n    assert(x < GRID_DIM_X && x >= 0);\n    assert(y < GRID_DIM_Y && y >= 0);\n\n    return *(grid->zps + (y * GRID_DIM_X) + x);\n}\n\nvoid Grid_append_member(\n        const GridPointer grid, \n        const VertexPointer v, \n        const ZonePointer z\n    )\n{\n    v->next = z->members;\n    z->members = v;\n    if (!*(grid->is_populated + z->id)) {\n        *(grid->pzps + grid->npz) = z;\n        grid->npz++;\n    }\n    *(grid->is_populated + z->id) = 1;\n}\n\nvoid Grid_check_adjacent(const GridPointer grid) \n{\n    int i, j;\n    for (i = 0; i < grid->npz - 1; i++) {\n        for (j = i + 1; j < grid->npz; j++) {\n            ZonePointer zi = *(grid->pzps + i);\n            ZonePointer zj = *(grid->pzps + j);\n            int diff;\n            diff = zi->id - zj->id;\n            \n           int adj; \n            adj = \n                diff == 1 || \n                diff == -1 || \n                diff == GRID_DIM_X || \n                diff == -GRID_DIM_X ||\n                diff == GRID_DIM_X - 1 ||\n                diff == GRID_DIM_X + 1 ||\n                diff == -GRID_DIM_X - 1 ||\n                diff == -GRID_DIM_X + 1;\n            if (adj) {\n                Pair pr = Pair_initialize(zi, zj);\n                ZonePairPointer newz2p = ZonePair_create(pr, grid->azps);\n                grid->azps = newz2p;\n            }\n        }\n    }\n}\n\nvoid Grid_reset_dynamics(const GridPointer grid)\n{\n    if (grid->azps) ZonePairs_free(grid->azps);\n    grid->azps = NULL;\n    grid->npz = 0;\n    int i;\n    for (i = 0; i < grid->nz; i++) {\n        *(grid->is_populated + i) = 0;\n        ZonePointer z = *(grid->zps + i);\n        if (z) z->members = NULL;\n    }\n}\n\nint *Grid_to_array(const GridPointer grid)\n{\n    int *rtn;\n    rtn = (int *) Util_allocate(grid->nz * 3, sizeof(int));\n    int i;\n    for (i = 0; i < grid->nz; i++) {\n        ZonePointer z = *(grid->zps + i);\n        *(rtn + i * 3) = z->minx;\n        *(rtn + i * 3 + 1) = z->miny;\n        *(rtn + i * 3 + 2) = z->width;\n    }\n    return rtn;\n}\n\nvoid Grid_free(const GridPointer grid)\n{\n    ZonePairs_free(grid->azps);\n    Zones_free(grid->zps, grid->nz);\n    free(grid->pzps);\n    free(grid->zps);\n    free(grid->is_populated);\n}\n","/* vim: set et ts=3 sw=3 sts=3 ft=c:\n *\n * Copyright (C) 2012, 2013, 2014 James McLaughlin et al.  All rights reserved.\n * https://github.com/udp/json-parser\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *   notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"json.h\"\n\n#ifdef _MSC_VER\n   #ifndef _CRT_SECURE_NO_WARNINGS\n      #define _CRT_SECURE_NO_WARNINGS\n   #endif\n#endif\n\nconst struct _json_value json_value_none;\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\ntypedef unsigned int json_uchar;\n\nstatic unsigned char hex_value (json_char c)\n{\n   if (isdigit(c))\n      return c - '0';\n\n   switch (c) {\n      case 'a': case 'A': return 0x0A;\n      case 'b': case 'B': return 0x0B;\n      case 'c': case 'C': return 0x0C;\n      case 'd': case 'D': return 0x0D;\n      case 'e': case 'E': return 0x0E;\n      case 'f': case 'F': return 0x0F;\n      default: return 0xFF;\n   }\n}\n\ntypedef struct\n{\n   unsigned long used_memory;\n\n   unsigned int uint_max;\n   unsigned long ulong_max;\n\n   json_settings settings;\n   int first_pass;\n\n   const json_char * ptr;\n   unsigned int cur_line, cur_col;\n\n} json_state;\n\nstatic void * default_alloc (size_t size, int zero, void * user_data)\n{\n   return zero ? calloc (1, size) : malloc (size);\n}\n\nstatic void default_free (void * ptr, void * user_data)\n{\n   free (ptr);\n}\n\nstatic void * json_alloc (json_state * state, unsigned long size, int zero)\n{\n   if ((state->ulong_max - state->used_memory) < size)\n      return 0;\n\n   if (state->settings.max_memory\n         && (state->used_memory += size) > state->settings.max_memory)\n   {\n      return 0;\n   }\n\n   return state->settings.mem_alloc (size, zero, state->settings.user_data);\n}\n\nstatic int new_value (json_state * state,\n                      json_value ** top, json_value ** root, json_value ** alloc,\n                      json_type type)\n{\n   json_value * value;\n   int values_size;\n\n   if (!state->first_pass)\n   {\n      value = *top = *alloc;\n      *alloc = (*alloc)->_reserved.next_alloc;\n\n      if (!*root)\n         *root = value;\n\n      switch (value->type)\n      {\n         case json_array:\n\n            if (value->u.array.length == 0)\n               break;\n\n            if (! (value->u.array.values = (json_value **) json_alloc\n               (state, value->u.array.length * sizeof (json_value *), 0)) )\n            {\n               return 0;\n            }\n\n            value->u.array.length = 0;\n            break;\n\n         case json_object:\n\n            if (value->u.object.length == 0)\n               break;\n\n            values_size = sizeof (*value->u.object.values) * value->u.object.length;\n\n            if (! (value->u.object.values = (json_object_entry *) json_alloc\n                  (state, values_size + ((unsigned long) value->u.object.values), 0)) )\n            {\n               return 0;\n            }\n\n            value->_reserved.object_mem = (*(char **) &value->u.object.values) + values_size;\n\n            value->u.object.length = 0;\n            break;\n\n         case json_string:\n\n            if (! (value->u.string.ptr = (json_char *) json_alloc\n               (state, (value->u.string.length + 1) * sizeof (json_char), 0)) )\n            {\n               return 0;\n            }\n\n            value->u.string.length = 0;\n            break;\n\n         default:\n            break;\n      };\n\n      return 1;\n   }\n\n   if (! (value = (json_value *) json_alloc\n         (state, sizeof (json_value) + state->settings.value_extra, 1)))\n   {\n      return 0;\n   }\n\n   if (!*root)\n      *root = value;\n\n   value->type = type;\n   value->parent = *top;\n\n   #ifdef JSON_TRACK_SOURCE\n      value->line = state->cur_line;\n      value->col = state->cur_col;\n   #endif\n\n   if (*alloc)\n      (*alloc)->_reserved.next_alloc = value;\n\n   *alloc = *top = value;\n\n   return 1;\n}\n\n#define whitespace \\\n   case '\\n': ++ state.cur_line;  state.cur_col = 0; \\\n   case ' ': case '\\t': case '\\r'\n\n#define string_add(b)  \\\n   do { if (!state.first_pass) string [string_length] = b;  ++ string_length; } while (0);\n\n#define line_and_col \\\n   state.cur_line, state.cur_col\n\nstatic const long\n   flag_next             = 1 << 0,\n   flag_reproc           = 1 << 1,\n   flag_need_comma       = 1 << 2,\n   flag_seek_value       = 1 << 3, \n   flag_escaped          = 1 << 4,\n   flag_string           = 1 << 5,\n   flag_need_colon       = 1 << 6,\n   flag_done             = 1 << 7,\n   flag_num_negative     = 1 << 8,\n   flag_num_zero         = 1 << 9,\n   flag_num_e            = 1 << 10,\n   flag_num_e_got_sign   = 1 << 11,\n   flag_num_e_negative   = 1 << 12,\n   flag_line_comment     = 1 << 13,\n   flag_block_comment    = 1 << 14;\n\njson_value * json_parse_ex (json_settings * settings,\n                            const json_char * json,\n                            size_t length,\n                            char * error_buf)\n{\n   json_char error [json_error_max];\n   const json_char * end;\n   json_value * top, * root, * alloc = 0;\n   json_state state = { 0 };\n   long flags;\n   long num_digits = 0, num_e = 0;\n   json_int_t num_fraction = 0;\n\n   /* Skip UTF-8 BOM\n    */\n   if (length >= 3 && ((unsigned char) json [0]) == 0xEF\n                   && ((unsigned char) json [1]) == 0xBB\n                   && ((unsigned char) json [2]) == 0xBF)\n   {\n      json += 3;\n      length -= 3;\n   }\n\n   error[0] = '\\0';\n   end = (json + length);\n\n   memcpy (&state.settings, settings, sizeof (json_settings));\n\n   if (!state.settings.mem_alloc)\n      state.settings.mem_alloc = default_alloc;\n\n   if (!state.settings.mem_free)\n      state.settings.mem_free = default_free;\n\n   memset (&state.uint_max, 0xFF, sizeof (state.uint_max));\n   memset (&state.ulong_max, 0xFF, sizeof (state.ulong_max));\n\n   state.uint_max -= 8; /* limit of how much can be added before next check */\n   state.ulong_max -= 8;\n\n   for (state.first_pass = 1; state.first_pass >= 0; -- state.first_pass)\n   {\n      json_uchar uchar;\n      unsigned char uc_b1, uc_b2, uc_b3, uc_b4;\n      json_char * string = 0;\n      unsigned int string_length = 0;\n\n      top = root = 0;\n      flags = flag_seek_value;\n\n      state.cur_line = 1;\n\n      for (state.ptr = json ;; ++ state.ptr)\n      {\n         json_char b = (state.ptr == end ? 0 : *state.ptr);\n         \n         if (flags & flag_string)\n         {\n            if (!b)\n            {  sprintf (error, \"Unexpected EOF in string (at %d:%d)\", line_and_col);\n               goto e_failed;\n            }\n\n            if (string_length > state.uint_max)\n               goto e_overflow;\n\n            if (flags & flag_escaped)\n            {\n               flags &= ~ flag_escaped;\n\n               switch (b)\n               {\n                  case 'b':  string_add ('\\b');  break;\n                  case 'f':  string_add ('\\f');  break;\n                  case 'n':  string_add ('\\n');  break;\n                  case 'r':  string_add ('\\r');  break;\n                  case 't':  string_add ('\\t');  break;\n                  case 'u':\n\n                    if (end - state.ptr < 4 || \n                        (uc_b1 = hex_value (*++ state.ptr)) == 0xFF ||\n                        (uc_b2 = hex_value (*++ state.ptr)) == 0xFF ||\n                        (uc_b3 = hex_value (*++ state.ptr)) == 0xFF ||\n                        (uc_b4 = hex_value (*++ state.ptr)) == 0xFF)\n                    {\n                        sprintf (error, \"Invalid character value `%c` (at %d:%d)\", b, line_and_col);\n                        goto e_failed;\n                    }\n\n                    uc_b1 = (uc_b1 << 4) | uc_b2;\n                    uc_b2 = (uc_b3 << 4) | uc_b4;\n                    uchar = (uc_b1 << 8) | uc_b2;\n\n                    if ((uchar & 0xF800) == 0xD800) {\n                        json_uchar uchar2;\n                        \n                        if (end - state.ptr < 6 || (*++ state.ptr) != '\\\\' || (*++ state.ptr) != 'u' ||\n                            (uc_b1 = hex_value (*++ state.ptr)) == 0xFF ||\n                            (uc_b2 = hex_value (*++ state.ptr)) == 0xFF ||\n                            (uc_b3 = hex_value (*++ state.ptr)) == 0xFF ||\n                            (uc_b4 = hex_value (*++ state.ptr)) == 0xFF)\n                        {\n                            sprintf (error, \"Invalid character value `%c` (at %d:%d)\", b, line_and_col);\n                            goto e_failed;\n                        }\n\n                        uc_b1 = (uc_b1 << 4) | uc_b2;\n                        uc_b2 = (uc_b3 << 4) | uc_b4;\n                        uchar2 = (uc_b1 << 8) | uc_b2;\n                        \n                        uchar = 0x010000 | ((uchar & 0x3FF) << 10) | (uchar2 & 0x3FF);\n                    }\n\n                    if (sizeof (json_char) >= sizeof (json_uchar) || (uchar <= 0x7F))\n                    {\n                       string_add ((json_char) uchar);\n                       break;\n                    }\n\n                    if (uchar <= 0x7FF)\n                    {\n                        if (state.first_pass)\n                           string_length += 2;\n                        else\n                        {  string [string_length ++] = 0xC0 | (uchar >> 6);\n                           string [string_length ++] = 0x80 | (uchar & 0x3F);\n                        }\n\n                        break;\n                    }\n\n                    if (uchar <= 0xFFFF) {\n                        if (state.first_pass)\n                           string_length += 3;\n                        else\n                        {  string [string_length ++] = 0xE0 | (uchar >> 12);\n                           string [string_length ++] = 0x80 | ((uchar >> 6) & 0x3F);\n                           string [string_length ++] = 0x80 | (uchar & 0x3F);\n                        }\n                        \n                        break;\n                    }\n\n                    if (state.first_pass)\n                       string_length += 4;\n                    else\n                    {  string [string_length ++] = 0xF0 | (uchar >> 18);\n                       string [string_length ++] = 0x80 | ((uchar >> 12) & 0x3F);\n                       string [string_length ++] = 0x80 | ((uchar >> 6) & 0x3F);\n                       string [string_length ++] = 0x80 | (uchar & 0x3F);\n                    }\n\n                    break;\n\n                  default:\n                     string_add (b);\n               };\n\n               continue;\n            }\n\n            if (b == '\\\\')\n            {\n               flags |= flag_escaped;\n               continue;\n            }\n\n            if (b == '\"')\n            {\n               if (!state.first_pass)\n                  string [string_length] = 0;\n\n               flags &= ~ flag_string;\n               string = 0;\n\n               switch (top->type)\n               {\n                  case json_string:\n\n                     top->u.string.length = string_length;\n                     flags |= flag_next;\n\n                     break;\n\n                  case json_object:\n\n                     if (state.first_pass)\n                        (*(json_char **) &top->u.object.values) += string_length + 1;\n                     else\n                     {  \n                        top->u.object.values [top->u.object.length].name\n                           = (json_char *) top->_reserved.object_mem;\n\n                        top->u.object.values [top->u.object.length].name_length\n                           = string_length;\n\n                        (*(json_char **) &top->_reserved.object_mem) += string_length + 1;\n                     }\n\n                     flags |= flag_seek_value | flag_need_colon;\n                     continue;\n\n                  default:\n                     break;\n               };\n            }\n            else\n            {\n               string_add (b);\n               continue;\n            }\n         }\n\n         if (state.settings.settings & json_enable_comments)\n         {\n            if (flags & (flag_line_comment | flag_block_comment))\n            {\n               if (flags & flag_line_comment)\n               {\n                  if (b == '\\r' || b == '\\n' || !b)\n                  {\n                     flags &= ~ flag_line_comment;\n                     -- state.ptr;  /* so null can be reproc'd */\n                  }\n\n                  continue;\n               }\n\n               if (flags & flag_block_comment)\n               {\n                  if (!b)\n                  {  sprintf (error, \"%d:%d: Unexpected EOF in block comment\", line_and_col);\n                     goto e_failed;\n                  }\n\n                  if (b == '*' && state.ptr < (end - 1) && state.ptr [1] == '/')\n                  {\n                     flags &= ~ flag_block_comment;\n                     ++ state.ptr;  /* skip closing sequence */\n                  }\n\n                  continue;\n               }\n            }\n            else if (b == '/')\n            {\n               if (! (flags & (flag_seek_value | flag_done)) && top->type != json_object)\n               {  sprintf (error, \"%d:%d: Comment not allowed here\", line_and_col);\n                  goto e_failed;\n               }\n\n               if (++ state.ptr == end)\n               {  sprintf (error, \"%d:%d: EOF unexpected\", line_and_col);\n                  goto e_failed;\n               }\n\n               switch (b = *state.ptr)\n               {\n                  case '/':\n                     flags |= flag_line_comment;\n                     continue;\n\n                  case '*':\n                     flags |= flag_block_comment;\n                     continue;\n\n                  default:\n                     sprintf (error, \"%d:%d: Unexpected `%c` in comment opening sequence\", line_and_col, b);\n                     goto e_failed;\n               };\n            }\n         }\n\n         if (flags & flag_done)\n         {\n            if (!b)\n               break;\n\n            switch (b)\n            {\n               whitespace:\n                  continue;\n\n               default:\n\n                  sprintf (error, \"%d:%d: Trailing garbage: `%c`\",\n                           state.cur_line, state.cur_col, b);\n\n                  goto e_failed;\n            };\n         }\n\n         if (flags & flag_seek_value)\n         {\n            switch (b)\n            {\n               whitespace:\n                  continue;\n\n               case ']':\n\n                  if (top && top->type == json_array)\n                     flags = (flags & ~ (flag_need_comma | flag_seek_value)) | flag_next;\n                  else\n                  {  sprintf (error, \"%d:%d: Unexpected ]\", line_and_col);\n                     goto e_failed;\n                  }\n\n                  break;\n\n               default:\n\n                  if (flags & flag_need_comma)\n                  {\n                     if (b == ',')\n                     {  flags &= ~ flag_need_comma;\n                        continue;\n                     }\n                     else\n                     {\n                        sprintf (error, \"%d:%d: Expected , before %c\",\n                                 state.cur_line, state.cur_col, b);\n\n                        goto e_failed;\n                     }\n                  }\n\n                  if (flags & flag_need_colon)\n                  {\n                     if (b == ':')\n                     {  flags &= ~ flag_need_colon;\n                        continue;\n                     }\n                     else\n                     { \n                        sprintf (error, \"%d:%d: Expected : before %c\",\n                                 state.cur_line, state.cur_col, b);\n\n                        goto e_failed;\n                     }\n                  }\n\n                  flags &= ~ flag_seek_value;\n\n                  switch (b)\n                  {\n                     case '{':\n\n                        if (!new_value (&state, &top, &root, &alloc, json_object))\n                           goto e_alloc_failure;\n\n                        continue;\n\n                     case '[':\n\n                        if (!new_value (&state, &top, &root, &alloc, json_array))\n                           goto e_alloc_failure;\n\n                        flags |= flag_seek_value;\n                        continue;\n\n                     case '\"':\n\n                        if (!new_value (&state, &top, &root, &alloc, json_string))\n                           goto e_alloc_failure;\n\n                        flags |= flag_string;\n\n                        string = top->u.string.ptr;\n                        string_length = 0;\n\n                        continue;\n\n                     case 't':\n\n                        if ((end - state.ptr) < 3 || *(++ state.ptr) != 'r' ||\n                            *(++ state.ptr) != 'u' || *(++ state.ptr) != 'e')\n                        {\n                           goto e_unknown_value;\n                        }\n\n                        if (!new_value (&state, &top, &root, &alloc, json_boolean))\n                           goto e_alloc_failure;\n\n                        top->u.boolean = 1;\n\n                        flags |= flag_next;\n                        break;\n\n                     case 'f':\n\n                        if ((end - state.ptr) < 4 || *(++ state.ptr) != 'a' ||\n                            *(++ state.ptr) != 'l' || *(++ state.ptr) != 's' ||\n                            *(++ state.ptr) != 'e')\n                        {\n                           goto e_unknown_value;\n                        }\n\n                        if (!new_value (&state, &top, &root, &alloc, json_boolean))\n                           goto e_alloc_failure;\n\n                        flags |= flag_next;\n                        break;\n\n                     case 'n':\n\n                        if ((end - state.ptr) < 3 || *(++ state.ptr) != 'u' ||\n                            *(++ state.ptr) != 'l' || *(++ state.ptr) != 'l')\n                        {\n                           goto e_unknown_value;\n                        }\n\n                        if (!new_value (&state, &top, &root, &alloc, json_null))\n                           goto e_alloc_failure;\n\n                        flags |= flag_next;\n                        break;\n\n                     default:\n\n                        if (isdigit (b) || b == '-')\n                        {\n                           if (!new_value (&state, &top, &root, &alloc, json_integer))\n                              goto e_alloc_failure;\n\n                           if (!state.first_pass)\n                           {\n                              while (isdigit (b) || b == '+' || b == '-'\n                                        || b == 'e' || b == 'E' || b == '.')\n                              {\n                                 if ( (++ state.ptr) == end)\n                                 {\n                                    b = 0;\n                                    break;\n                                 }\n\n                                 b = *state.ptr;\n                              }\n\n                              flags |= flag_next | flag_reproc;\n                              break;\n                           }\n\n                           flags &= ~ (flag_num_negative | flag_num_e |\n                                        flag_num_e_got_sign | flag_num_e_negative |\n                                           flag_num_zero);\n\n                           num_digits = 0;\n                           num_fraction = 0;\n                           num_e = 0;\n\n                           if (b != '-')\n                           {\n                              flags |= flag_reproc;\n                              break;\n                           }\n\n                           flags |= flag_num_negative;\n                           continue;\n                        }\n                        else\n                        {  sprintf (error, \"%d:%d: Unexpected %c when seeking value\", line_and_col, b);\n                           goto e_failed;\n                        }\n                  };\n            };\n         }\n         else\n         {\n            switch (top->type)\n            {\n            case json_object:\n               \n               switch (b)\n               {\n                  whitespace:\n                     continue;\n\n                  case '\"':\n\n                     if (flags & flag_need_comma)\n                     {  sprintf (error, \"%d:%d: Expected , before \\\"\", line_and_col);\n                        goto e_failed;\n                     }\n\n                     flags |= flag_string;\n\n                     string = (json_char *) top->_reserved.object_mem;\n                     string_length = 0;\n\n                     break;\n                  \n                  case '}':\n\n                     flags = (flags & ~ flag_need_comma) | flag_next;\n                     break;\n\n                  case ',':\n\n                     if (flags & flag_need_comma)\n                     {\n                        flags &= ~ flag_need_comma;\n                        break;\n                     }\n\n                  default:\n                     sprintf (error, \"%d:%d: Unexpected `%c` in object\", line_and_col, b);\n                     goto e_failed;\n               };\n\n               break;\n\n            case json_integer:\n            case json_double:\n\n               if (isdigit (b))\n               {\n                  ++ num_digits;\n\n                  if (top->type == json_integer || flags & flag_num_e)\n                  {\n                     if (! (flags & flag_num_e))\n                     {\n                        if (flags & flag_num_zero)\n                        {  sprintf (error, \"%d:%d: Unexpected `0` before `%c`\", line_and_col, b);\n                           goto e_failed;\n                        }\n\n                        if (num_digits == 1 && b == '0')\n                           flags |= flag_num_zero;\n                     }\n                     else\n                     {\n                        flags |= flag_num_e_got_sign;\n                        num_e = (num_e * 10) + (b - '0');\n                        continue;\n                     }\n\n                     top->u.integer = (top->u.integer * 10) + (b - '0');\n                     continue;\n                  }\n\n                  num_fraction = (num_fraction * 10) + (b - '0');\n                  continue;\n               }\n\n               if (b == '+' || b == '-')\n               {\n                  if ( (flags & flag_num_e) && !(flags & flag_num_e_got_sign))\n                  {\n                     flags |= flag_num_e_got_sign;\n\n                     if (b == '-')\n                        flags |= flag_num_e_negative;\n\n                     continue;\n                  }\n               }\n               else if (b == '.' && top->type == json_integer)\n               {\n                  if (!num_digits)\n                  {  sprintf (error, \"%d:%d: Expected digit before `.`\", line_and_col);\n                     goto e_failed;\n                  }\n\n                  top->type = json_double;\n                  top->u.dbl = (double) top->u.integer;\n\n                  num_digits = 0;\n                  continue;\n               }\n\n               if (! (flags & flag_num_e))\n               {\n                  if (top->type == json_double)\n                  {\n                     if (!num_digits)\n                     {  sprintf (error, \"%d:%d: Expected digit after `.`\", line_and_col);\n                        goto e_failed;\n                     }\n\n                     top->u.dbl += ((double) num_fraction) / (pow (10.0, (double) num_digits));\n                  }\n\n                  if (b == 'e' || b == 'E')\n                  {\n                     flags |= flag_num_e;\n\n                     if (top->type == json_integer)\n                     {\n                        top->type = json_double;\n                        top->u.dbl = (double) top->u.integer;\n                     }\n\n                     num_digits = 0;\n                     flags &= ~ flag_num_zero;\n\n                     continue;\n                  }\n               }\n               else\n               {\n                  if (!num_digits)\n                  {  sprintf (error, \"%d:%d: Expected digit after `e`\", line_and_col);\n                     goto e_failed;\n                  }\n\n                  top->u.dbl *= pow (10.0, (double)\n                      (flags & flag_num_e_negative ? - num_e : num_e));\n               }\n\n               if (flags & flag_num_negative)\n               {\n                  if (top->type == json_integer)\n                     top->u.integer = - top->u.integer;\n                  else\n                     top->u.dbl = - top->u.dbl;\n               }\n\n               flags |= flag_next | flag_reproc;\n               break;\n\n            default:\n               break;\n            };\n         }\n\n         if (flags & flag_reproc)\n         {\n            flags &= ~ flag_reproc;\n            -- state.ptr;\n         }\n\n         if (flags & flag_next)\n         {\n            flags = (flags & ~ flag_next) | flag_need_comma;\n\n            if (!top->parent)\n            {\n               /* root value done */\n\n               flags |= flag_done;\n               continue;\n            }\n\n            if (top->parent->type == json_array)\n               flags |= flag_seek_value;\n               \n            if (!state.first_pass)\n            {\n               json_value * parent = top->parent;\n\n               switch (parent->type)\n               {\n                  case json_object:\n\n                     parent->u.object.values\n                        [parent->u.object.length].value = top;\n\n                     break;\n\n                  case json_array:\n\n                     parent->u.array.values\n                           [parent->u.array.length] = top;\n\n                     break;\n\n                  default:\n                     break;\n               };\n            }\n\n            if ( (++ top->parent->u.array.length) > state.uint_max)\n               goto e_overflow;\n\n            top = top->parent;\n\n            continue;\n         }\n      }\n\n      alloc = root;\n   }\n\n   return root;\n\ne_unknown_value:\n\n   sprintf (error, \"%d:%d: Unknown value\", line_and_col);\n   goto e_failed;\n\ne_alloc_failure:\n\n   strcpy (error, \"Memory allocation failure\");\n   goto e_failed;\n\ne_overflow:\n\n   sprintf (error, \"%d:%d: Too long (caught overflow)\", line_and_col);\n   goto e_failed;\n\ne_failed:\n\n   if (error_buf)\n   {\n      if (*error)\n         strcpy (error_buf, error);\n      else\n         strcpy (error_buf, \"Unknown error\");\n   }\n\n   if (state.first_pass)\n      alloc = root;\n\n   while (alloc)\n   {\n      top = alloc->_reserved.next_alloc;\n      state.settings.mem_free (alloc, state.settings.user_data);\n      alloc = top;\n   }\n\n   if (!state.first_pass)\n      json_value_free_ex (&state.settings, root);\n\n   return 0;\n}\n\njson_value * json_parse (const json_char * json, size_t length)\n{\n   json_settings settings = { 0 };\n   return json_parse_ex (&settings, json, length, 0);\n}\n\nvoid json_value_free_ex (json_settings * settings, json_value * value)\n{\n   json_value * cur_value;\n\n   if (!value)\n      return;\n\n   value->parent = 0;\n\n   while (value)\n   {\n      switch (value->type)\n      {\n         case json_array:\n\n            if (!value->u.array.length)\n            {\n               settings->mem_free (value->u.array.values, settings->user_data);\n               break;\n            }\n\n            value = value->u.array.values [-- value->u.array.length];\n            continue;\n\n         case json_object:\n\n            if (!value->u.object.length)\n            {\n               settings->mem_free (value->u.object.values, settings->user_data);\n               break;\n            }\n\n            value = value->u.object.values [-- value->u.object.length].value;\n            continue;\n\n         case json_string:\n\n            settings->mem_free (value->u.string.ptr, settings->user_data);\n            break;\n\n         default:\n            break;\n      };\n\n      cur_value = value;\n      value = value->parent;\n      settings->mem_free (cur_value, settings->user_data);\n   }\n}\n\nvoid json_value_free (json_value * value)\n{\n   json_settings settings = { 0 };\n   settings.mem_free = default_free;\n   json_value_free_ex (&settings, value);\n}\n\n","/*****************************************************************************\n\n * Author: Numerical recepies in C, modified by Ludvig Sundström\n\n * File Name: linmin.c\n\n * Description: \n * GraphPointeriven an n-dimensional point p[1..n] and an n-dimensional\n * direction xi[1..n], moves and resets p to where the function step(p) takes\n * on a minimum along the direction xi from p, and replaces xi by the actual\n * vector displacement that p was moved. Also returns as fret the value of func\n * at the returned location p. This is actually all accomplished by calling the\n * routines mnbrak and brent.  \n\n * Creation Date: 25-06-2015\n\n *****************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#include \"constants.h\"\n#include \"graph.h\"\n#include \"vertex.h\"\n#include \"util.h\"\n#include \"linmin.h\"\n\nstatic double parabolic_extrapolation(\n        const double *ax, \n        const double *bx, \n        const double *cx, \n        const double q, \n        const double r\n    )\n{\n    return (*bx) - ((*bx - *cx) * q - (*bx - *ax) *r ) / \n           (2.0 * SIGN(MAX(fabs(q - r), TINY), q - r));\n}\n\nstatic double step(\n        double x, GraphPointer graph, \n        void (*e_fun)(GraphPointer)\n    )   \n{   \n    VertexSet_move(graph->vs, x);\n    Graph_reset_dynamics(graph);\n\n    e_fun(graph);\n\n    return graph->energy;\n}\n\nstatic double isolate_minimum(\n        GraphPointer graph, \n        double ax, \n        double bx, \n        double cx, \n        double tol, \n        double *xmin,\n        void (*e_fun)(GraphPointer)\n    )\n{\n    int iter;\n    double a,b,d,etemp,fu,fv,fw,fx,p,q,r,tol1,tol2,u,v,w,x,xm;\n    double e=0.0;\n\n    a=(ax < cx ? ax : cx);\n    b=(ax > cx ? ax : cx);\n    x = w = v = bx;\n    fw = fv = fx = step(x, graph, e_fun);\n    for (iter = 0; iter < L_ITMAX; iter++) {\n        xm = 0.5 * (a + b);\n        tol2 = 2.0 * (tol1 = tol * fabs(x) + ZEPS);\n        if (fabs(x-xm) <= (tol2-0.5*(b-a))) {\n            *xmin=x;\n            return fx;\n        }\n        if (fabs(e) > tol1) {\n            r = (x - w) * (fx - fv);\n            q =(x - v) * (fx - fw);\n            p = (x - v) * q - (x - w) * r;\n            q = 2.0 * (q - r);\n            if (q > 0.0) p = -p;\n            q=fabs(q);\n            etemp=e;\n            e=d;\n            if (fabs(p) >= fabs(0.5*q*etemp) || p <= q*(a-x) || p >= q*(b-x))\n                d=CGOLD*(e=(x >= xm ? a-x : b-x));\n            else {\n                d=p/q;\n                u=x+d;\n                if (u-a < tol2 || b-u < tol2)\n                    d=SIGN(tol1,xm-x);\n            }\n        } else {\n            d=CGOLD*(e=(x >= xm ? a-x : b-x));\n        }\n        u=(fabs(d) >= tol1 ? x+d : x+SIGN(tol1,d));\n        fu = step(u, graph, e_fun);\n        if (fu <= fx) {\n            if (u >= x) a=x; else b=x;\n            SHFT(v,w,x,u)\n                SHFT(fv,fw,fx,fu)\n        } else {\n            if (u < x) a=u; else b=u;\n            if (fu <= fw || w == x) {\n                v=w;\n                w=u;\n                fv=fw;\n                fw=fu;\n            } else if (fu <= fv || v == x || v == w) {\n                v=u;\n                fv=fu;\n            }\n        }\n    }\n    Util_runtime_error(\"Too many iterations in brent\");\n    *xmin=x;\n    return fx;\n}\n\nvoid bracket_minimum(\n        GraphPointer gp, \n        double *ax, \n        double *bx, \n        double *cx, \n        double *fa, \n        double *fb, \n        double *fc, \n        void (*e_fun)(GraphPointer)\n    )\n{\n    \n    *fa = step(*ax, gp, e_fun);\n    *fb = step(*bx, gp, e_fun);\n    \n    if (*fb > *fa) {\n        double dum;\n        SHFT(dum,*ax,*bx,dum);\n        SHFT(dum,*fb,*fa,dum);\n    }\n\n    *cx = *bx + GOLD * (*bx - *ax);\n    *fc = step(*cx, gp, e_fun);\n\n    while (*fb > *fc) {\n        \n        double r, q;\n        r = (*bx - *ax) * (*fb - *fc);\n        q = (*bx - *cx) * (*fb - *fa);\n        \n        double u, ulim;\n        u = parabolic_extrapolation(ax, bx, cx, q, r);\n        ulim = (*bx)+GLIMIT*(*cx-*bx);\n\n        double fu;\n        if ((*bx-u)*(u-*cx) > 0.0) {\n            fu=(*step)(u, gp, e_fun);\n            if (fu < *fc) {\n                *ax=(*bx);\n                *bx=u;\n                *fa=(*fb);\n                *fb=fu;\n                return;\n            } else if (fu > *fb) {\n                *cx=u;\n                *fc=fu;\n                return;\n            }\n            u=(*cx)+GOLD*(*cx-*bx);\n            fu=(*step)(u, gp, e_fun);\n        } else if ((*cx-u)*(u-ulim) > 0.0) {\n            fu=(*step)(u, gp, e_fun);\n            if (fu < *fc) {\n                SHFT(*bx,*cx,u,*cx+GOLD*(*cx-*bx));\n                SHFT(*fb,*fc,fu,(*step)(u, gp, e_fun));\n            }\n        } else if ((u-ulim)*(ulim-*cx) >= 0.0) {\n            u=ulim;\n            fu=(*step)(u, gp, e_fun);\n        } else {\n            u = (*cx)+GOLD*(*cx-*bx);\n            fu=(*step)(u, gp, e_fun);\n        }\n        SHFT(*ax,*bx,*cx,u)\n        SHFT(*fa,*fb,*fc,fu)\n    }\n}\n\nvoid linmin(\n        GraphPointer graph, \n        void (*e_fun)(GraphPointer),\n        double *fret\n    )   \n{   \n    VertexSet vs;\n    vs = graph->vs;\n    \n    VertexSet_store_gradient(vs);\n\n    double ax, xx;\n    ax = 0.0; \n    xx = 1.0;   \n    \n    double bx, fa, fx, fb;\n    bracket_minimum(graph, &ax, &xx, &bx, &fa, &fx, &fb, e_fun);   \n\n    double xmin;\n    *fret = isolate_minimum(graph, ax, xx, bx, TOL, &xmin, e_fun);   \n\n    VertexSet_boost(vs, xmin);\n}\n\n","/*****************************************************************************\n\n* File Name: local_minimizer.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 13-08-2015\n\n*****************************************************************************/\n\n#include <math.h>\n\n#include \"constants.h\"\n#include \"graph.h\"\n#include \"emscripten.h\"\n#include \"linmin.h\"\n\n#ifndef EMSCRIPT\n#define EMSCRIPT 0\n#endif\n\n/* Private ******************************************************************/\n\nstatic int close_to_target(double fret, double e, double ftol)\n{\n    return 2.0 * fabs(fret - e) <= (ftol) * (fabs((fret)) + fabs((e)) + EPS);\n}\n\nstatic void js_interact(GraphPointer graph)\n{\n    assert(graph);\n    float *varr;\n    int *barr, *zarr;\n    varr = NULL;\n    barr = NULL; zarr = NULL;\n    if (EMSCRIPT) {\n        varr = VertexSet_to_array(graph->vs);\n        barr = Bondset_to_array(graph->bs);\n        zarr = Grid_to_array(graph->grid);\n        EM_ASM_({\n            window.EXPORTS.processCdata($0, $1, $2, $3, $4, $5);\n        }, varr, barr, zarr, \n                graph->vs.n * 2, graph->bs.n * 2, graph->grid->nz * 3);\n    }\n    free(varr); free(barr); free(zarr);\n    varr = NULL; barr = NULL; zarr = NULL;\n}\n\n/* Public ******************************************************************/\n\nvoid LocalMinimizer_run(\n        const GraphPointer graph, \n        void (*e_fun)(GraphPointer), \n        void (*g_fun)(GraphPointer),\n        const double ftol\n    )\n{\n    assert(graph && e_fun && g_fun);\n    assert(graph->grid && graph->vs.set && graph->bs.set);\n    assert(ftol > 0 && ftol < 0.1);\n\n    int nv;\n    nv = graph->vs.n;\n\n    g_fun(graph);\n\n    VertexSet_create_sequences(graph->vs, nv, 1, INITIALIZE);\n\n    double e;\n    e_fun(graph);\n    e = graph->energy;\n\n    assert(e >= 0);\n    \n    int i; \n    for (i = 0; i < L_ITMAX; i++) {\n        \n        double fret = 0.0;\n        linmin(graph, e_fun, &fret);\n\n        if (close_to_target(fret, e, ftol)) break;\n\n        g_fun(graph);\n        e_fun(graph);\n        e = graph->energy;\n\n        double gg, dgg;\n        dgg = gg = 0.0;\n        VertexSet_calculate_score(graph->vs, nv, &gg, &dgg); \n\n        if (fabs(gg) < EPS) {\n            break;\n        }\n        \n        double gam;\n        gam = dgg / gg;\n        VertexSet_create_sequences(graph->vs, nv, gam, UPDATE);\n    }\n\n    js_interact(graph);\n}\n\n","/***************************************************************************** \n * Author: Ludvig Sundström\n\n * File Name: minimizer.c\n \n * Description: Defines an object able to 'minimize' the energy of the graph\n * G(V, B) created by the set of Vertices V and Bonds B defined in JSON format.\n \n * Creation Date: 24-06-2015\n\n *****************************************************************************/\n\n#include <unistd.h>\n\n#include \"util.h\"\n#include \"constants.h\"\n#include \"graph.h\"\n#include \"process_input.h\"\n#include \"energy.h\"\n#include \"gradient.h\"\n#include \"local_minimizer.h\"\n#include \"global_minimizer.h\"\n\n\nvoid Minimizer_run(const char *fname) \n{\n    assert(fname);\n\n    if (access(fname, R_OK) != -1) {\n\n        GraphPointer graph;\n        graph = Graph_create(fname);\n\n        LocalMinimizer_run(graph, Energy_calculate, Gradient_calculate, FTOL);\n        GlobalMinimizer_run(graph, Energy_calculate);\n        \n        Graph_free(graph);\n        graph = NULL;\n        \n        assert(!graph);\n\n    } else {\n        Util_runtime_error(\"Minimizer_run(): Can't read file\");\n    }\n}\n\n\n","/*****************************************************************************\n\n* File Name: Pair.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 30-07-2015\n\n*****************************************************************************/\n\n#include <stdlib.h>\n#include \"util.h\"\n#include \"pair.h\"\n\nPair Pair_initialize(void *fst, void *snd) \n{\n    Pair rtn;\n    rtn.fst = fst;\n    rtn.snd = snd;\n    return rtn;\n}\n\nPairPointer Pair_create(void *fst, void *snd) \n{\n    PairPointer rtn = (PairPointer) Util_allocate(1, sizeof(Pair));\n    *rtn = Pair_initialize(fst, snd);\n    return rtn;\n}\n\n","/*****************************************************************************\n\n* File Name: placement.c\n\n* Author: Ludvig Sundström\n\n* Description: Assign positions (x, y) to a set of vertices\n\n* Creation Date: 13-07-2015\n\n*****************************************************************************/\n\n#include <stdio.h>\n#include <time.h>\n#include <math.h>\n#include <stdlib.h>\n\n#include \"vertex.h\"\n#include \"vertex_set.h\"\n#include \"constants.h\"\n#include \"util.h\"\n\n/* Private *******************************************************************/\n\nstatic int comp_by_mass(const void *elem1, const void *elem2) \n{\n    VertexPointer *fst = (VertexPointer *) elem1;\n    VertexPointer *snd = (VertexPointer *) elem2;\n    if ((*fst)->mass > (*snd)->mass) return 1;\n    if ((*fst)->mass < (*snd)->mass) return -1;\n    return 0;\n}\n\nstatic int comp_by_id(const void *elem1, const void *elem2) \n{\n    VertexPointer *fst = (VertexPointer *) elem1;\n    VertexPointer *snd = (VertexPointer *) elem2;\n    if ((*fst)->id > (*snd)->id) return 1;\n    if ((*fst)->id < (*snd)->id) return -1;\n    return 0;\n}\n\n/* Public ********************************************************************/\n\nvoid Placement_set_spiral(VertexSet vs, const int nv)\n{\n    qsort((void *) vs.set, vs.n, sizeof(void *), comp_by_mass);\n\n    int n;\n    n = nv;\n    while (fabs(sqrt(n) - (int) sqrt(n)) > EPS) {\n        n++;\n    }\n    \n    int dimx, dimy;\n    dimx = (int) sqrt(n);\n    dimy = dimx;\n    \n    double gapx, gapy;\n    gapx = PANEL_X / dimx;\n    gapy = PANEL_Y / dimy;\n    \n    int x, y;\n    x = 0; \n    y = 0;\n    \n    int dx, dy;\n    dx = 0;\n    dy = -1;\n\n    int t;\n    t = fmax(dimx, dimy);\n\n    int i;\n    for (i = nv - 1; i >= 0; i--) {\n        if (!(*(vs.set + i))->pos.given_coords) {\n            if ((-dimx / 2 <= x && x <= dimx / 2) && \n                (-dimy / 2 <= y && y <= dimy / 2))\n            {\n                double placex, placey;\n                placex = (double) x * gapx;\n                placey = (double) y * gapy;\n                Vertex_set_position(*(vs.set + i), Vector_initialize(placex, placey));\n            }\n        }\n        if ((x == y) || ((x < 0) && (x == -y)) || ((x > 0) && (x == 1 - y))) {\n            t = dx;\n            dx = -dy;\n            dy = t;\n        }\n        x += dx;\n        y += dy; \n    }\n    qsort((void *) vs.set, vs.n, sizeof(void *), comp_by_id);\n}\n\nvoid Placement_set_random(const VertexSet vs, const int nv)\n{\n    srand(time(NULL));\n    int i;\n    for (i = 0; i < nv; i++) {\n        double rx, ry;\n        rx = ((double) rand()) / RAND_MAX;\n        ry = ((double) rand()) / RAND_MAX;\n        Vertex_set_position(*(vs.set + i), Vector_initialize(rx, ry));\n    }\n}\n\nvoid Placement_set_grid(VertexSet vs, const int nv) \n{\n    int i, n, vdim, rows, cols;\n    double gapx, gapy, offsetx, offsety, x, y;\n    n = nv; \n    while (fabs(sqrt(n) - (int) sqrt(n)) > EPS) {\n        n++;\n    }\n    vdim = sqrt(n);\n    gapx = PANEL_X / vdim;\n    gapy = PANEL_Y / vdim;\n    offsetx = gapx / 2;\n    offsety = gapy / 2;\n    rows = 0;\n    cols = -1;\n    for (i = 0; i < nv; i++) {\n        if (i % vdim == 0) {\n            rows++;\n            cols = 0; \n        }\n        x = cols * gapx + offsetx;\n        y = rows * gapy + offsety; \n        Vertex_set_position(*(vs.set + i), Vector_initialize(x, y));\n        cols++;\n    }\n}\n","\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <math.h>\n\n#include \"constants.h\"\n#include \"util.h\"\n#include \"json.h\"\n#include \"graph.h\"\n#include \"vertex_set.h\"\n#include \"vertex_set.h\"\n\nPair process_json(const char *filename, int *nvp, int *nbp)\n{\n    FILE *fp;\n    struct stat filestatus;\n    int file_size;\n    char* file_contents;\n    json_char* json;\n    json_value* value;\n\n    if ( stat(filename, &filestatus) != 0) {\n        char  buf[256];\n        strcpy(buf, \"process_json(): File not found: \");\n        strcat(buf, filename);\n        Util_runtime_error(buf);\n    }\n    file_size = filestatus.st_size;\n    file_contents = (char *) malloc(filestatus.st_size);\n    if ( file_contents == NULL) {\n        Util_runtime_error(\"process_json(): Unable to allocate memory\");\n    }\n\n    fp = fopen(filename, \"rt\");\n\n    if (fp == NULL) {\n        fclose(fp);\n        free(file_contents);\n        Util_runtime_error(\"process_json(): Unable to open file\");\n    }\n    if ( fread(file_contents, file_size, 1, fp) != 1 ) {\n        fclose(fp);\n        free(file_contents);\n        Util_runtime_error(\"process_json(): Unable to read file\");\n    }\n\n    fclose(fp);\n\n    json = (json_char*)file_contents;\n\n    value = json_parse(json,file_size);\n\n    if (value == NULL) {\n        free(file_contents);\n        json_value_free(value);\n        Util_runtime_error(\"process_json(): Unable to parse data\");\n    }\n    if (value->u.object.length != 2) {\n        free(file_contents);\n        json_value_free(value);\n        Util_runtime_error(\"process_json(): Wrong number of keys\");\n    }\n    if (strcmp(value->u.object.values[0].name, \"vertices\") != 0) {\n        free(file_contents);\n        json_value_free(value);\n        Util_runtime_error(\"process_json(): First key is not vertices\");\n    }\n    if (strcmp(value->u.object.values[1].name, \"bonds\") != 0) {\n        free(file_contents);\n        json_value_free(value);\n        Util_runtime_error(\"process_json(): Second key is not 'bonds'\");\n    }\n\n    VertexSetPointer vs; BondSetPointer bs;\n    vs = VertexSet_create(value, nvp);\n    bs = BondSet_create(vs->set, value, nbp);\n\n    json_value_free(value);\n    free(file_contents);\n\n    return Pair_initialize(vs, bs);\n}\n\n","/*****************************************************************************\n* Author : Ludvig Sundström\n* File Name : util.c\n\n * Purpose : \n\n * Creation Date : 26-06-2015\n\n * Last Modified : \n\n *****************************************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <limits.h>\n\n#include \"util.h\"\n#include \"constants.h\"\n\n#define ANSI_COLOR_RED \"\\x1b[31m\"\n#define ANSI_COLOR_RESET \"\\x1b[0m\"\n\nSign Util_sign(const double x)\n{\n    return x > 0 ? PLUS : MINUS;\n}\n\ndouble Util_doubles_min(const double *set, const int n)\n{\n    double min;\n    min = set[0];\n\n    int i;\n    for (i = 1; i < n; i++) {\n        if (set[i] < min) min = set[i];\n    }\n    return min;\n}\n\ndouble Util_doubles_max(const double *set, const int n)\n{\n    double max;\n    max = set[0];\n\n    int i;\n    for (i = 1; i < n; i++) {\n        if (set[i] > max) max = set[i];\n    }\n    return max;\n}\n\nvoid Util_normalize(\n        double *set, \n        const int n, \n        const double upper, \n        const double min, \n        const double max \n    )\n{\n    int i;\n    for (i = 0; i < n; i++) {\n        assert(Util_in_range(min, max, set[i]));\n\n        set[i] = upper * ((set[i] - min) / (max - min));\n    }\n}\n\nint Util_is_zero(const double x)\n{\n    return Util_equal(x, 0.0);\n}\n\nint Util_equal(const double tar, const double x) {\n    if (tar == 0 && x == 0) return 1;\n    return fabs(x - tar) < TINY;\n}\n\nint Util_close_to(const double tar, const double x) {\n    if (tar == 0 && x == 0) return 1;\n    return fabs(x - tar) < EPS;\n}\n\nint Util_about(const double tar, const double x) {\n    if (Util_equal(tar, x)) return 1;\n    double err;\n    err = fabs(x * EPS);\n    return fabs(x - tar) <= err;\n}\n\nint Util_in_range(const double lower, const double upper, const double x)\n{\n    int lowcond, upcond;\n    lowcond = x > lower || Util_equal(x, lower);\n    upcond = x < upper || Util_equal(x, upper);\n    return lowcond && upcond;\n}\n\nint Util_in_range_strict(\n        const double lower, \n        const double upper, \n        const double x\n    )\n{\n    int lowcond, upcond;\n    lowcond = x > lower;\n    upcond = x < upper;\n    return lowcond && upcond;\n}\n\nvoid *Util_allocate(int nmemb, int size) {\n    void *rtn = malloc(nmemb * size);\n    if (rtn == NULL)\n    {\n        Util_runtime_error(\"Error when allocating memory\");\n    }\n    return rtn;\n}\n\nvoid *Util_allocate_initialize(int nmemb, int size) {\n    void *rtn = calloc(nmemb, size);\n    if (rtn == NULL)\n    {\n        Util_runtime_error(\"Error when allocating memory\");\n    }\n    return rtn;\n}\n\nvoid Util_runtime_error(char error_text[])\n{\n    fprintf(stderr,ANSI_COLOR_RED \"Runtime-error: %s\\n\" ANSI_COLOR_RESET,\n            error_text);\n    exit(1);\n}\n\n","/*****************************************************************************\n\n* File Name: math2D.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 06-07-2015\n\n*****************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#include \"constants.h\"\n#include \"vector.h\"\n#include \"util.h\"\n\nVector Vector_initialize(const double x, const double y)\n{\n    Vector rtn;\n    rtn.x = x;\n    rtn.y = y;\n    rtn.given_coords = 0;\n    rtn.len = sqrt(x * x + y * y);\n    return rtn;\n}\n\nVectorPointer Vector_create(double x, double y)\n{\n    VectorPointer rtn = (VectorPointer) malloc(sizeof(Vector));\n    *rtn = Vector_initialize(x, y);\n    return rtn;\n}\n\nVector Vector_zero()\n{\n    return Vector_initialize(0.0, 0.0);\n}\n\nVector Vector_add(Vector vec1, Vector vec2) \n{\n    return Vector_initialize(vec1.x + vec2.x, vec1.y + vec2.y);\n}\n\nVector Vector_sub(Vector vec1, Vector vec2) \n{\n    return Vector_initialize(vec1.x - vec2.x, vec1.y - vec2.y);\n}\n\nVector Vector_mult(Vector vec1, Vector vec2) \n{\n    return Vector_initialize(vec1.x * vec2.x, vec1.y * vec2.y);\n}\n\nVector Vector_negate(Vector vec) \n{\n    return Vector_initialize(-vec.x, -vec.y);\n}\n\nVector Vector_scalar_mult(Vector vec, double c)\n{\n    return Vector_initialize(c * vec.x, c * vec.y);\n}\n\nVector Vector_scalar_add(Vector vec, double c)\n{\n    return Vector_initialize(c + vec.x, c + vec.y);\n}\n\ndouble Vector_dot(Vector v1, Vector v2)\n{   \n    return v1.x * v2.x + v1.y * v2.y;\n}\n\ndouble Vector_norm(Vector v) \n{\n    return sqrt(Vector_dot(v, v));\n}\n\ndouble Vector_angle(Vector v1, Vector v2)\n{\n\n    double scalp;\n    scalp = Vector_dot(v1, v2);\n    assert(!(scalp != scalp));\n    \n    double lenp;\n    lenp = (v1.len * v2.len);\n    assert(lenp >= 0);\n\n    if (Util_is_zero(lenp)) {\n        return 0.0;\n        /*Util_runtime_error(\"Vector_angle: Division by zero\");*/\n    }\n    if (scalp != scalp) Util_runtime_error(\"Vector_angle: Nan scalp\");\n    if (\n            Util_equal(scalp, lenp) || \n            Util_equal(scalp, -lenp) || \n            Util_equal(-scalp, lenp)\n        )\n    {\n        return 0.0;\n    }\n\n    double div;\n    div = scalp / lenp;\n    if (fabs(div - 1.0) < EPS || fabs(div + 1.0) < EPS) \n        return 0.0;\n    if (!Util_in_range_strict(-1.0, 1.0, div)) {\n        Util_runtime_error(\"Vector_angle: Outside acos range\"); \n    }\n    return acos(div);\n}\n\nint Vector_parallel(Vector v1, Vector v2)\n{\n    return Util_equal(Vector_angle(v1, v2), 0);\n}\n\nint Vector_Util_equal(Vector v1, Vector v2)\n{\n    return Util_equal(v1.x, v2.x) && Util_equal(v1.y, v2.y);\n}\n\n/**\n * Magnitude of the vector that would result from a regular 3D space. \n */\n\ndouble Vector_cross(Vector vec1, Vector vec2)\n{\n    return (vec1.x * vec2.y) - (vec2.x * vec1.y);\n}\n\n","/*****************************************************************************\n\n* File Name: vertex.c\n\n* Author: Ludvpig Sundström\n\n* Description: \n\n* Creation Date: 28-07-2015\n\n*****************************************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n\n#include \"util.h\"\n#include \"vertex.h\"\n#include \"constants.h\"\n\n/* Private ******************************************************************/\n\nstatic Vector Vertex_to_center(const VertexPointer vp) \n{\n    int cx, cy;\n    cx = PANEL_X / 2; cy = PANEL_Y / 2;\n    Vector rtn;\n    rtn = Vector_initialize((double) cx - vp->pos.x, (double) cy - vp->pos.y);\n    return rtn;\n}\n\nstatic double potential_weight(const VertexPointer vp) \n{\n    return WPOT;\n}\n\n\n/* Public  ******************************************************************/\n\nint Vertex_zone_idx(const VertexPointer v)\n{\n    int rtn;\n    if (v->pos.x >= PANEL_X) {\n        rtn = PANEL_X / PADDING - 1;\n    } else if (v->pos.x <= 0) {\n        rtn = 0;\n    } else {\n        rtn = ((int) v->pos.x) / PADDING;\n    }\n    return rtn; \n}\n\nint Vertex_zone_idy(const VertexPointer v)\n{\n    int rtn;\n    if (v->pos.y >= PANEL_Y) {\n        rtn = PANEL_Y / PADDING - 1;\n    } else if (v->pos.y <= 0) {\n        rtn = 0;\n    } else {\n        rtn = ((int) v->pos.y) / PADDING;\n    }\n    return rtn;\n}\n\nvoid Vertex_reset_dynamics(const VertexPointer v) \n{\n    v->next = NULL;\n}\n\nVertex Vertex_copy(const Vertex v)\n{\n    Vertex rtn;\n    rtn.pos = v.pos;\n    rtn.tl = v.tl;\n    rtn.br = v.br;\n    rtn.pos0 = v.pos0;\n    rtn.grad0 = v.grad0;\n    rtn.id = v.id;\n    rtn.mass = v.mass;\n    rtn.crs_bof = v.crs_bof;\n    rtn.type = v.type;\n    rtn.next = v.next;\n\n    return rtn;\n}\n\nVertexPointer Vertex_create(\n       const int id, \n       const Vector pos,\n       const double wdth, \n       const double hght, \n       const char type, \n       const int nv\n    ) \n{\n    VertexPointer rtn;\n    rtn = Util_allocate_initialize(1, sizeof(Vertex));\n    rtn->id = id;\n    rtn->mass = 1;\n    rtn->pos = pos;\n    rtn->energy = 0.0;\n    rtn->gradient = Vector_zero();\n    rtn->g = Vector_zero(); \n    rtn->h = Vector_zero();\n    rtn->tl = Vector_sub(pos, Vector_initialize((PADDING + wdth) / 2, \n                (PADDING + hght) / 2));\n    rtn->br = Vector_add(pos, Vector_initialize((PADDING + wdth) / 2, \n                (PADDING + hght) / 2));\n    rtn->type = type;\n    rtn->crs_bof = (int *) calloc(nv, sizeof(int));\n    Vertex_reset_dynamics(rtn);\n    return rtn;\n}\n\nvoid Vertex_set_position(const VertexPointer v, const Vector pos)\n{\n    v->pos.x = pos.x;\n    v->pos.y = pos.y;\n\n    v->tl.x = pos.x - (PADDING / 2.0);\n    v->tl.y = pos.y - (PADDING / 2.0);\n\n    v->br.x = pos.x + (PADDING / 2.0);\n    v->br.y = pos.y + (PADDING / 2.0);\n}\n\nvoid Vertex_move(const VertexPointer v, const Vector ds) \n{\n    Vector new_pos;\n    new_pos = Vector_add(v->pos0, ds);\n\n    Vertex_set_position(v, new_pos);\n}\n\ndouble Vertex_potential_energy(const VertexPointer vp) \n{\n    Vector cdist;\n    cdist = Vertex_to_center(vp);\n\n    double w;\n    w = potential_weight(vp);\n    \n    return w * pow(Vector_norm(cdist), 2);\n}\n\nVector Vertex_potential_gradient(const VertexPointer vp)\n{\n    Vector cdist;\n    cdist = Vertex_to_center(vp);\n\n    double w;\n    w = potential_weight(vp);\n\n    return Vector_scalar_mult(cdist, 2 * w);\n}\n\nvoid Vertex_free(VertexPointer vp)\n{\n    free(vp->crs_bof);\n    free(vp);\n}\n\n","/*****************************************************************************\n\n* File Name: vertex_pair.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 31-07-2015\n\n*****************************************************************************/\n\n#include \"math.h\"\n#include \"constants.h\"\n#include \"vertex.h\"\n#include \"pair.h\"\n\n/* Private ******************************************************************/\n\nstatic double repulsion_weight(const Pair pr) \n{\n    return 2 * WREP;\n}\n\n/* Public *******************************************************************/\n\ndouble VertexPair_repulsion_energy(const Pair pr) \n{\n    double w;\n    w = repulsion_weight(pr);\n\n    VertexPointer vp0, vp1;\n    vp0 = (VertexPointer) pr.fst;\n    vp1 = (VertexPointer) pr.snd;\n\n    /*int cb;*/\n    /*cb = *(vp0->crs_bof + vp1->id);*/\n    /*if (cb) {*/\n        /*w *= REPULSION_REDUCE;*/\n    /*}*/\n    \n    double i_tl_x, i_tl_y, i_br_x, i_br_y;\n    i_tl_x = fmax(vp0->tl.x, vp1->tl.x);\n    i_tl_y = fmax(vp0->tl.y, vp1->tl.y);\n    i_br_x = fmin(vp0->br.x, vp1->br.x);\n    i_br_y = fmin(vp0->br.y, vp1->br.y);\n\n    if (i_tl_x > i_br_x || i_tl_y > i_br_y) {\n        return 0;\n    } else {\n        double i_dx, i_dy;\n        i_dx = i_br_x - i_tl_x;\n        i_dy = i_br_y - i_tl_y;\n        return w * pow(i_dx * i_dy, 2);\n    }\n}\n\n\nVector VertexPair_repulsion_gradient(const Pair pr)\n{\n    double w;\n    w = repulsion_weight(pr);\n\n    VertexPointer vp0, vp1;\n    vp0 = (VertexPointer) pr.fst;\n    vp1 = (VertexPointer) pr.snd;\n\n    /*int cb;*/\n    /*cb = *(vp0->crs_bof + vp1->id);*/\n    /*if (cb) {*/\n      /*w *= REPULSION_REDUCE;*/\n    /*}*/\n\n    double i_tl_x, i_tl_y, i_br_x, i_br_y;\n    i_tl_x = fmax(vp0->tl.x, vp1->tl.x);\n    i_tl_y = fmax(vp0->tl.y, vp1->tl.y);\n    i_br_x = fmin(vp0->br.x, vp1->br.x);\n    i_br_y = fmin(vp0->br.y, vp1->br.y);\n\n    Vector frc;\n\n    if (i_tl_x > i_br_x || i_tl_y > i_br_y) {\n        return Vector_zero();\n    } else {\n        double i_dx, i_dy;\n        i_dx = i_br_x - i_tl_x;\n        i_dy = i_br_y - i_tl_y;\n        if (vp0->pos.x <= vp1->pos.x) {\n            frc.x = -2 * i_dx * pow(i_dy, 2);\n        } else {\n            frc.x = 2 * i_dx * pow(i_dy, 2);\n        } \n        if (vp0->pos.y <= vp1->pos.y) {\n            frc.y = -2 * i_dy * pow(i_dx, 2);\n        } else {\n            frc.y = 2 * i_dy * pow(i_dx, 2);\n        } \n    }\n    return Vector_scalar_mult(frc, w);\n}\n\n","/*****************************************************************************\n\n* File Name: vertex_set.c\n\n* Author: Ludvig Sundström\n\n* Description: Represents a set of vertices\n\n* Creation Date: 31-07-2015\n\n*****************************************************************************/\n\n#include <stdlib.h>\n\n#include \"util.h\"\n#include \"constants.h\"\n#include \"vertex_set.h\"\n\nVertexSet VertexSet_initialize(json_value *contents, int *nvp)\n{\n    json_value *vsarr = contents->u.object.values[0].value;\n    *nvp = vsarr->u.array.length;\n\n    int nv;\n    nv = *nvp;\n\n    VertexSet rtn;\n    rtn.set = (VertexPointer *) Util_allocate(nv, sizeof(VertexPointer));\n    rtn.n = nv;\n\n    if (nv < 1) {\n        Util_runtime_error(\"No vertices\");\n    }\n\n    int i;\n    for (i = 0; i < nv; i++) {\n        \n        json_value *vertex;  \n        vertex = vsarr->u.array.values[i];\n\n        json_value *ident;\n        int id;\n        id = -99;\n        ident = vertex->u.object.values[0].value;\n        if (ident->type == json_integer) {\n            id = ident->u.integer;\n        } else {\n            Util_runtime_error(\"Bad JSON data: ident\");\n        }\n\n        Vector pos, zv;\n        zv = Vector_zero();\n        pos = zv;    \n        json_value *position;\n        position = vertex->u.object.values[1].value;\n        if (position->type == json_array) {\n            int length;\n            double x, y;\n            x = y = 0;\n            length = position->u.array.length;\n            if (length != 2) {\n                Util_runtime_error(\"Bad JSON data, position dimension not 2\");\n            }\n            json_value *j_x = position->u.array.values[0];\n            json_value *j_y = position->u.array.values[1];\n            if (j_x->type == json_integer) {\n                x = (double) j_x->u.integer;\n            } else if (j_x->type == json_double) {\n                x = (double) j_x->u.dbl;\n            } else {\n                Util_runtime_error(\"Bad JSON data: position: x\");\n            }\n            if (j_y->type == json_integer) {\n                y = (double) j_y->u.integer;\n            } else if (j_x->type == json_double) {\n                y = (double) j_y->u.dbl;\n            } else {\n                Util_runtime_error(\"Bad JSON data: position: y\");\n            }\n            pos = Vector_initialize(x, y);\n            pos.given_coords = 1;\n        } \n        else {\n            if (position->type != json_null) {\n                Util_runtime_error(\"Bad JSON data: position\");\n            }\n        }\n\n        char t;\n        t = 0;\n        json_value *vertex_type;\n        vertex_type = vertex->u.object.values[3].value;\n        if (vertex_type->type == json_string) {\n            t = vertex_type ->u.string.ptr[0];\n        } else {\n            Util_runtime_error(\"Bad JSON data: type\");\n        }\n\n        *(rtn.set + i) = Vertex_create(id, pos,\n                VERTEX_BASE_WIDTH, VERTEX_BASE_HEIGHT, t, nv);\n    }\n    return rtn;\n}\n\nVertexSetPointer VertexSet_create(json_value *contents, int *nvp)\n{\n    VertexSetPointer rtn;\n    rtn = (VertexSetPointer) malloc(sizeof(VertexSet));\n    *rtn = VertexSet_initialize(contents, nvp);\n    return rtn;\n}\n\nVertexPointer VertexSet_get_vertex(const VertexSet vs, const int i)\n{\n    return *(vs.set + i);\n}\n\nvoid VertexSet_store_gradient(const VertexSet vs)\n{\n    int i;\n    for (i = 0; i < vs.n; i++) {\n        VertexPointer v;\n        v = *(vs.set + i);\n        v->pos0 = v->pos;\n        v->grad0 = v->gradient;\n        v->gradient = Vector_zero();\n    }\n}\n\nvoid VertexSet_move(const VertexSet vs, const double x)\n{\n    int i;   \n    for (i = 0; i < vs.n; i++) {\n        VertexPointer v;\n        v = VertexSet_get_vertex(vs, i);\n\n        Vector ds;\n        ds = Vector_scalar_mult(v->grad0, x);\n\n        Vertex_move(v, ds);\n    }\n}\n\n    \n/**\n * Boost all members proportional to x along their current gradient\n */ \n\nvoid VertexSet_boost(const VertexSet vs, const double x)\n{\n    int i;    \n    for (i = 0; i < vs.n; i++) { \n        VertexPointer v;\n        v = *(vs.set + i);\n        Vector_scalar_mult(v->gradient, x);\n    }   \n}\n\nvoid VertexSet_create_sequences(\n        const VertexSet vs,\n        const int n,\n        const double gam, \n        const Strategy strat\n    )\n{\n    assert(n > 0 && n <= MAX_NV); \n    assert(strat == INITIALIZE || strat == UPDATE);\n    \n    int i;\n    for (i = 0; i < n; i++) {\n        VertexPointer v = VertexSet_get_vertex(vs, i);\n        v->g = Vector_negate(v->gradient);\n        if (strat == INITIALIZE) {\n            v->gradient = v->h = v->g;\n\n        } else {\n            Vector h_gam, g_h_gam;\n            h_gam = Vector_scalar_mult(v->h, gam);\n            g_h_gam = Vector_add(v->g, h_gam);\n\n            v->gradient = v->h = g_h_gam;\n        }\n    }\n}\n\n\nvoid VertexSet_calculate_score(\n        const VertexSet vs,\n        const int n,\n        double *gg, \n        double *dgg\n    )\n{\n    assert(n > 0 && n <= MAX_NV);\n    assert(Util_is_zero(*gg) && Util_is_zero(*dgg));\n\n    int i;\n    for (i = 0; i < n; i++) {\n        VertexPointer v = VertexSet_get_vertex(vs, i);\n        *gg += Vector_dot(v->g, v->g);\n        *dgg += Vector_dot(Vector_add(v->gradient, v->g), v->gradient);\n    }\n}\n\n\nfloat *VertexSet_to_array(const VertexSet vs)\n{\n    float *rtn = (float *) Util_allocate(vs.n * 2, sizeof(double));\n    int i;\n    for (i = 0; i < vs.n; i++) {\n        *(rtn + i * 2) = (float) (VertexSet_get_vertex(vs, i))->pos.x;\n        *(rtn + i * 2 + 1) = (float) (VertexSet_get_vertex(vs, i))->pos.y;\n    }\n    return rtn;\n\n}\n\nvoid VertexSet_free(VertexSet vs) \n{\n    int i;\n    for (i = 0; i < vs.n; i++) {\n        Vertex_free(VertexSet_get_vertex(vs, i));\n    }\n    free(vs.set);\n}\n\n\n","/*****************************************************************************\n\n* File Name: zone2d.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 24-07-2015\n\n*****************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"zone.h\"\n\nZonePointer Zone_create(\n        const int id, \n        const int i, \n        const int j, \n        const double minx,\n        const double miny, \n        const double width, \n        const double height\n    )\n{\n    ZonePointer rtn = malloc(sizeof(Zone));\n    rtn->id = id;\n    rtn->i = i;\n    rtn->j = j;\n    rtn->minx = minx; rtn->miny = miny;\n    rtn->width = width; rtn->height = height;\n    return rtn;\n}\n\n\nvoid Zones_free(ZonePointer *zs, int nz) \n{\n    int i;\n    for (i = 0; i < nz; i++) {\n        free(*(zs + i));\n    }\n    zs = NULL;\n}\n\n","/*****************************************************************************\n\n* File Name: zone_pair.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 31-07-2015\n\n*****************************************************************************/\n\n#include <stdlib.h>\n\n#include \"pair.h\"\n#include \"zone_pair.h\"\n\nZonePairPointer ZonePair_create(const Pair pr, const ZonePairPointer next)\n{\n    ZonePairPointer rtn = (ZonePairPointer) malloc(sizeof(ZonePair));\n    rtn->fst = (ZonePointer) pr.fst;\n    rtn->snd = (ZonePointer) pr.snd;\n    rtn->next = next;\n    return rtn;\n}\n\nvoid ZonePairs_free(ZonePairPointer z2p)\n{\n    ZonePairPointer cur = z2p;\n    while(cur != NULL) {\n        ZonePairPointer tmp = cur;\n        cur = cur->next;\n        free(tmp);\n    }\n}\n\n"]}