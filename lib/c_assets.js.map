{"version":3,"file":"lib/c_assets.js","sources":["lib/c/brent.c","lib/c/mnbrak.c","lib/c/gradient.c","lib/c/objective.c","lib/c/graph.c","lib/c/util.c","lib/c/minimizer.c","lib/c/frprmn.c","lib/c/math2D.c","lib/c/linmin.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA;AAAA;AACA;AAAA;AAEA;AAGA;;;AADA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAIA;AAAA;;;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;A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","sourcesContent":["/*****************************************************************************\n * Author: Numerical Recipies in C, Ludvig Sundström\n *\n * File Name: brent.c\n *\n * Description: \n * Given a function func, and given a bracketing triplet of abcissas ax, bx, cx\n * (such that bx is between ax and cx, and func(bx) is less than both f(ax) and\n * f(cx)), this routine isolates the minimum to a ffractional precition of\n * about tol using Brent's method.The abcissa of the minimum is returned as\n * xmin, and the minimum function value is returned as brent, the returned\n * function value.\n *\n * Creation Date : 25-06-2015\n *\n *****************************************************************************/\n\n#include <math.h>\n#include \"util.h\"\n#include \"constants.h\"\n\nfloat brent(float ax, float bx, float cx, float\n        (*func)(float), float tol, float *xmin)\n{\n    int iter;\n    float a,b,d,etemp,fu,fv,fw,fx,p,q,r,tol1,tol2,u,v,w,x,xm;\n    float e=0.0;\n    void rt_error(); \n\n    a=(ax < cx ? ax : cx);\n    b=(ax > cx ? ax : cx);\n    x = w = v = bx;\n    fw = fv = fx = (*func)(x);\n    for (iter = 1;iter <= ITMAX; iter++) {\n        xm = 0.5 * (a + b);\n        tol2 = 2.0 * (tol1 = tol * fabs(x) + ZEPS);\n        if (fabs(x-xm) <= (tol2-0.5*(b-a))) {\n            *xmin=x;\n            return fx;\n        }\n        if (fabs(e) > tol1) {\n            r = (x - w) * (fx - fv);\n            q =(x - v) * (fx - fw);\n            p = (x - v) * q - (x - w) * r;\n            q = 2.0 * (q - r);\n            if (q > 0.0) p = -p;\n            q=fabs(q);\n            etemp=e;\n            e=d;\n            if (fabs(p) >= fabs(0.5*q*etemp) || p <= q*(a-x) || p >= q*(b-x))\n                d=CGOLD*(e=(x >= xm ? a-x : b-x));\n            else {\n                d=p/q;\n                u=x+d;\n                if (u-a < tol2 || b-u < tol2)\n                    d=SIGN(tol1,xm-x);\n            }\n        } else {\n            d=CGOLD*(e=(x >= xm ? a-x : b-x));\n        }\n        u=(fabs(d) >= tol1 ? x+d : x+SIGN(tol1,d));\n        fu = (*func)(u);\n        if (fu <= fx) {\n            if (u >= x) a=x; else b=x;\n            SHFT(v,w,x,u)\n                SHFT(fv,fw,fx,fu)\n        } else {\n            if (u < x) a=u; else b=u;\n            if (fu <= fw || w == x) {\n                v=w;\n                w=u;\n                fv=fw;\n                fw=fu;\n            } else if (fu <= fv || v == x || v == w) {\n                v=u;\n                fv=fu;\n            }\n        }\n    }\n    rt_error(\"Too many iterations in brent\");\n    *xmin=x;\n    return fx;\n}\n\n#undef ITMAX\n#undef CGOLD\n#undef ZEPS\n#undef SHFT\n","/*****************************************************************************\n * Author: Numerical Recipies in C, Ludvig Sundström\n *\n * File Name: mnbrak.c\n *\n * Description: \n * Given a function func, and given distinct initial points ax, bx, this\n * routine searches in the downhill direction (defined by the function as\n * evaluated at the initial points) and returns new points ax, bx, cx that\n * bracket a minimum of the function. Also returned are the function values at\n * the three points fa, fb, fc\n *\n * Creation Date : 09-07-2015\n *\n *****************************************************************************/\n\n#include <math.h>\n#include \"util.h\"\n#include \"constants.h\"\n\nvoid mnbrak(float *ax, float *bx, float *cx, float *fa,\n        float *fb, float *fc, float (*func)())\n{\n    float ulim, u, r, q, fu, dum;\n\n    *fa=(*func)(*ax);\n    *fb=(*func)(*bx);\n    if (*fb > *fa) {\n        SHFT(dum,*ax,*bx,dum);\n        SHFT(dum,*fb,*fa,dum);\n    }\n    *cx=(*bx)+GOLD*(*bx-*ax);\n    *fc=(*func)(*cx);\n    while (*fb > *fc) {\n        r=(*bx-*ax)*(*fb-*fc);\n        q=(*bx-*cx)*(*fb-*fa);\n        u=(*bx)-((*bx-*cx)*q-(*bx-*ax)*r)/ (2.0*SIGN(MAX(fabs(q-r),TINY),q-r));\n        ulim=(*bx)+GLIMIT*(*cx-*bx);\n        if ((*bx-u)*(u-*cx) > 0.0) {\n            fu=(*func)(u);\n            if (fu < *fc) {\n                *ax=(*bx);\n                *bx=u;\n                *fa=(*fb);\n                *fb=fu;\n                return;\n            } else if (fu > *fb) {\n                *cx=u;\n                *fc=fu;\n                return;\n            }\n            u=(*cx)+GOLD*(*cx-*bx);\n            fu=(*func)(u);\n        } else if ((*cx-u)*(u-ulim) > 0.0) {\n            fu=(*func)(u);\n            if (fu < *fc) {\n                SHFT(*bx,*cx,u,*cx+GOLD*(*cx-*bx));\n                SHFT(*fb,*fc,fu,(*func)(u));\n            }\n        } else if ((u-ulim)*(ulim-*cx) >= 0.0) {\n            u=ulim;\n            fu=(*func)(u);\n        } else {\n            u=(*cx)+GOLD*(*cx-*bx);\n            fu=(*func)(u);\n        }\n        SHFT(*ax,*bx,*cx,u)\n        SHFT(*fa,*fb,*fc,fu)\n    }\n}\n\n","/*****************************************************************************\n\n* File Name: gradient.c\n\n* Author: Ludvig Sundström\n\n* Description: The gradient of the objective function.\n\n* Creation Date: 06-07-2015\n\n*****************************************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#include \"minimizer.h\"\n#include \"constants.h\"\n#include \"util.h\"\n\nstatic void addForce(struct point f, int i, float *df)\n{\n    *(df + i * 2) += f.x;\n    *(df + i * 2 + 1) += f.y;\n}\n\nstatic void df1(struct vertex **vs, float *df)\n{\n    int i, cx, cy;\n    float dx, dy;\n    struct vertex *vi;\n    struct point frc;\n    cx = sx / 2;\n    cy = sy / 2;\n    for (i = 0; i < nv; i++) {\n        vi = *(vs + i);\n        dx = vi->pos->x - (float) cx;    \n        dy = vi->pos->y - (float) cy;\n        frc.x = -2 * WG * dx;\n        frc.y = -2 * WG * dy;\n        addForce(frc, i, df);\n    }\n}\n\nstatic void df2rep(struct vertex **vs, float *df)\n{\n    int i, j;\n    float dij, dx, dy, critlen;\n    struct point frci;\n    struct vertex *vi, *vj;\n    for (i = 0; i < nv - 1; i++) {\n        for (j = i + 1; j < nv; j++) {\n            vi = *(vs + i);\n            vj = *(vs + j);\n            dx = vi->pos->x - vj->pos->x;\n            dy = vi->pos->y - vj->pos->y; \n            dij = sqrtf(dx * dx + dy * dy);\n            if (fabs(dij) < MIN_DIST) {\n                dij = MIN_DIST;\n            } \n            critlen = vi->radius + vj->radius + PADDING;\n            if (critlen > dij) {\n                frci.x = 2 * WR * dx * (dij - critlen) / dij;\n                frci.y = 2 * WR * dy * (dij - critlen) / dij;\n            } else {\n                frci.x = 0;\n                frci.y = 0;\n            }\n            addForce(frci, i, df);\n            addForce(negate(frci), j, df);\n        }\n    }\n}\n\nstatic void df2attr(struct bond *bs, float *df)\n{\n    int i;\n    float d0i, dx, dy, di, wi;\n    struct bond bi;\n    struct point frci;\n    for (i = 0; i < nb; i++) {\n        bi = *(bs + i);  \n        wi = bi.fst->mass * bi.snd->mass * DEFAULT_STIFFNESS;\n        d0i = bi.dist0 * elen;\n        dx = bi.fst->pos->x - bi.snd->pos->x;\n        dy = bi.fst->pos->y - bi.snd->pos->y; \n        di = sqrtf(dx * dx + dy * dy);\n        if (fabs(di) <  0.01) {\n            di = 0.01;\n        } \n        frci.x = -2 * wi * dx * (di - d0i) / di;\n        frci.y = -2 * wi * dy * (di - d0i) / di;\n        addForce(frci, bi.fst->id, df);\n        addForce(negate(frci), bi.snd->id, df);\n    }\n}\n\nstatic void df2(struct vertex **vs, struct bond *bs, float *df) \n{\n    df2attr(bs, df);\n    df2rep(vs, df);\n}\n\n\nvoid df3(struct point *ps, struct bond *bs, float *df)\n{\n    //TBI TODO\n}\n\nvoid df(struct vertex **vs, struct bond *bs, float *df) \n{\n    df1(vs, df);\n    df2(vs, bs, df);\n}\n\n","/*****************************************************************************\n\n* File Name: objective.c \n* Author: Ludvig Sundström\n\n* Description: The objective function F = F1 + F2 + F3 + F4 where FN considers\n* N nodes. \n\n* Creation Date: 05-07-2015\n\n*****************************************************************************/\n\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"minimizer.h\"\n#include \"constants.h\"\n#include \"util.h\"\n\n#include \"../../tests/minunit.h\"\n\nstatic float f1(struct vertex **vs) {\n    // Should we add repulsion from walls here? TODO\n    int i, cx, cy;\n    float dxc, dyc, rtn;\n    struct vertex *vi;\n    cx = sx / 2;\n    cy = sy / 2;\n    rtn = 0;\n    for (i = 0; i < nv; i++) {\n        vi = *(vs + i);\n        dxc =  (vi->pos)->x - (float) cx;    \n        dyc =  (vi->pos)->y - (float) cy;\n        rtn += WG * (powf(dxc, 2) + powf(dyc, 2));\n    }\n    return rtn;\n}\n\nstatic float f2attr(struct bond *bs) \n{\n    int i;\n    float rtn, d0i, di, wi, dx, dy;\n    struct bond bi;\n    rtn = 0; for (i = 0; i < nb; i++) {\n        bi = *(bs + i);\n        d0i = bi.dist0 * elen;\n        wi = bi.fst->mass * bi.snd->mass * bi.k;\n        dx = bi.fst->pos->x - bi.snd->pos->x;\n        dy = bi.fst->pos->y - bi.snd->pos->y;\n        di = sqrtf(dx * dx + dy * dy);\n        if (fabs(di) <  MIN_DIST) {\n            di = MIN_DIST;\n        } \n        rtn += wi * powf(di - d0i, 2);\n    }\n    return rtn;\n}\n\nstatic float f2rep(struct vertex **vs) \n{\n    int i, j;\n    float rtn, ri, rj, dx, dy, dij, critlen;\n    struct vertex *vi, *vj;\n    rtn = 0;\n    for (i = 0; i < nv - 1; i++) {\n        for (j = i + 1; j < nv; j++) {\n            vi = *(vs + i);\n            vj = *(vs + j);\n            ri = vi->radius;\n            rj = vj->radius;\n            dx = vi->pos->x - vj->pos->x;\n            dy = vi->pos->y - vj->pos->y;\n            dij = sqrtf(dx * dx + dy * dy);\n            if (fabs(dij) <  MIN_DIST) {\n                dij = MIN_DIST;\n            } \n            critlen = ri + rj + PADDING;\n            if (critlen > dij) {\n                rtn += WR * powf(dij - critlen, 2);\n            }\n        }\n    }\n    return rtn;\n}\n\nstatic float f2(struct vertex **vs, struct bond *bs) \n{\n    return f2attr(bs) + f2rep(vs);\n}\n\nstatic float f3(struct point *ps) \n{\n    int i, j, k; \n    float rtn, s, costheta, theta;\n    struct point pi, pj, pk;\n    struct vector2D vji, vjk;\n    rtn = 0; \n    for (i = 0; i < nv - 2; i++) {\n        for (j = i + 2; j < nv - 1; j++) {\n            for (k = j + 2; k < nv; k++) {\n                pi = *(ps + i);  \n                pj = *(ps + j);  \n                pk = *(ps + k);\n                vji = mk_vector(pi, pj);\n                vjk = mk_vector(pi, pk);\n                s = dot(vji, vjk);\n                costheta = s / (vji.len * vjk.len);\n                theta = fabs(acosf(costheta) - (M_PI / 2));\n                rtn += (1 / powf(theta, 2));\n            }\n        }\n    }\n    //TODO\n    /*return rtn;*/\n    return 0.0;\n}\n\nstatic float f4() \n{\n    // Edge crossings TODO\n    return 0.0;\n}\n\n\nfloat f(struct vertex **vs, struct bond *bs) \n{\n    float rtn = f1(vs) + f2(vs, bs);\n    return rtn;\n}\n///////////////////////////////////////\n\nstruct vertex **vs_test;\nstruct bond *bs_test;\n\nfloat gap = 100; \nint nv = 8; \nfloat dist = 1;\nfloat stiffness = 1;\nfloat mass = 1;\nfloat radius = 1;\nchar type = 'r';\n\nchar *test_objective() {\n    nb = 0;\n    vs_test = malloc(sizeof(struct vertex) * nv);\n    bs_test = malloc(sizeof(struct bond) * nv * nv);\n\n    mu_assert(\"Need to be able to allocate\", vs_test != NULL);\n    mu_assert(\"Need to be able to allocate \", bs_test != NULL);\n    for (int i = 0; i < nv; i++) {\n        struct point *pos = mk_point(0, i * gap);\n        *(vs_test + i) = mk_vertex(i, pos, mass, radius, type);\n        mu_assert(\"mk_vertex should not give NULL\", *(vs_test + i) != NULL);\n    }\n    for (int i = 0; i < nv - 1; i++) {\n        for (int j = i + 1; j < nv; j++) {\n            struct vertex *vi = *(vs_test + i);\n            struct vertex *vj = *(vs_test + j);\n            *(bs_test + nb) = mk_bond(vi, vj, dist, stiffness);\n            nb++;\n        }\n    }\n\n    float e = f(vs_test, bs_test);\n    float e1 = f1(vs_test);\n    /*float e2a = f2attr(bs_test);*/\n    /*float e2r = f2rep(vs_test);*/\n    /*printf(\"%f\\n\", e2r);*/\n    mu_assert(\"total energy should be bigger than 0\", e > 0 );\n    mu_assert(\"energy of f1 should be bigger than 0\", e1 > 0 );\n    /*mu_assert(\"energy of attraction 2 should be bigger than 0\", e2a > 0 );*/\n    /*mu_assert(\"energy of repuslsino 2 should be bigger than 0\", e2r > 0 );*/\n\n\n    return 0;\n}\n\n","/*****************************************************************************\n\n* File Name: graph.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 07-07-2015\n\n*****************************************************************************/\n\n#include <stdlib.h>\n#include <math.h>\n\n#include \"graph.h\"\n\nstruct vertex *mk_vertex(int id, struct point *pos, float mass, float radius, \n        char type) \n{\n    struct vertex *rtn = malloc(sizeof(struct vertex));\n    rtn->id = id;\n    rtn->pos = pos;\n    rtn->mass = mass;\n    rtn->radius = radius;\n    rtn->type = type;\n    return rtn;\n}\n\nstruct bond mk_bond(struct vertex *fst, struct vertex *snd, float dist0, \n        float k)\n{\n    struct bond rtn;\n    rtn.fst = fst;\n    rtn.snd = snd;\n    rtn.dist0 = dist0;\n    rtn.k = k;\n    return rtn;\n}\n\n","/*****************************************************************************\n\n * Author : Ludvig Sundström\n\n * File Name : util.c\n\n * Purpose : \n\n * Creation Date : 26-06-2015\n\n * Last Modified : \n\n *****************************************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n\n#include \"util.h\"\n\nvoid rt_error(char error_text[])\n{\n    fprintf(stderr,\"Run-time error...\\n\");\n    fprintf(stderr,\"%s\\n\",error_text);\n    fprintf(stderr,\"...now exiting to system...\\n\");\n    exit(1);\n}\n\nfloat *vector(long n) \n{\n    float *v;\n    v = (float *) malloc((size_t) (n * sizeof(float)));\n    if (v == NULL) {\n        rt_error(\"error while allocating memory\");\n    }\n    return v;\n}\n\nstruct point *arrtop(float arr[], int n) \n{   \n    int i;\n    struct point *ps = malloc(sizeof(struct point) * n);\n    if (ps == NULL) {\n        rt_error(\"Error while allocating memory\");\n    }\n    for (i = 0; i < n * 2; i += 2) {\n        struct point p;\n        p.x = arr[i]; \n        p.y = arr[i + 1];\n        *(ps + (i / 2)) = p;\n    }\n    return ps;\n}\n\n","/***************************************************************************** \n * Author: Ludvig Sundström\n\n * File Name: minimizer.c\n* Description: Defines an energy function and its derivatives aswell as\n * working as minimize() which is the exported function by emscripten.\n\n * Creation Date: 24-06-2015\n\n *****************************************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n\n#include \"util.h\"\n#include \"frprmn.h\"\n#include \"constants.h\"\n#include \"get_clustersizes.h\"\n\n#include \"minimizer.h\"\n\nint dim, pox, poy;\nfloat *fdm;\n\nstruct vertex **vs;\nstruct bond *bs;\n\nfloat f(struct vertex **vs, struct bond *bs);\nvoid df(struct vertex **vs, struct bond *bs, float *df);\n\nvoid frprmn(struct vertex **vs, struct bond *bs, int n, float ftol,\n        int *iter, float *fret, float (*func)(), void (*dfunc)());\n\nstatic void initDMT(const char *fname) \n{\n    FILE *fp;\n    char *pend, *p, *buf;\n    int i, j, ij;\n\n    const long rowMaxLen = (PRECISION_DIGITS + 3) * nv;\n\n    buf = malloc(sizeof(char) * rowMaxLen);\n    fp = fopen(fname, \"r\"); \n\n    if (buf == NULL) {\n        rt_error(\"error in getDMT while allocating memory\");\n    }\n    if (fp == NULL) {\n        printf(\"Error while opening file: %s for reading\", fname);\n        rt_error(\"Error...\");\n    }\n\n    for (i = 0; i < nv; i++) {\n        fgets(buf, rowMaxLen, fp);\n        p = buf;\n        for (j = 0; j < nv; j++) {\n            ij = j + (i * nv);\n            fdm[ij] = strtof(p, &pend);\n            if (fabs(fdm[ij]) < MIN_DIST) {\n                fdm[ij] = MIN_DIST;\n            }\n            p = pend + 1;\n        }\n    }\n    fclose(fp);\n    free(buf);\n}\n\nstatic void create_vertices(int customSizes) \n{\n    int i, n, vdim, rows, cols;\n    float gapx, gapy, offsetx, offsety, x, y;\n    struct vertex *vi;\n    struct point *pi;\n    n = nv; \n    while (fabs(sqrt(n) - (int) sqrt(n)) > 0.01) {\n        n++;\n    }\n    vdim = sqrt(n);\n    gapx = sx / vdim;\n    gapy = sy / vdim;\n    offsetx = gapx / 2;\n    offsety = gapy / 2;\n    rows = 0;\n    cols = -1;\n    for (i = 0; i < nv; i++) {\n        if (i % vdim == 0) {\n            rows++;\n            cols = 0;\n        }\n        x = cols * gapx + offsetx + pox;\n        y = rows * gapy + offsety + poy; \n        pi = mk_point(x, y);\n        vi = mk_vertex(i, pi, DEFAULT_RADIUS, DEFAULT_MASS, DEFAULT_TYPE);\n        *(vs + i) = vi;\n        cols++;\n    }\n}\n\nstatic void create_bonds() \n{\n    int i, j, ij;\n\n    struct vertex *vi, *vj;\n    struct bond bij;\n    float d0ij;\n    for (i = 0; i < nv - 1; i++) {\n        for (j = i + 1; j < nv; j++) {\n            vi = *(vs + i);\n            vj = *(vs + j);\n            ij = i * nv + j;\n            d0ij = fdm[ij];\n            if (d0ij > MIN_DIST && d0ij < DISTANCE_DELIMITER) {\n                bij = mk_bond(vi, vj, d0ij, DEFAULT_STIFFNESS);\n                *(bs + nb) = bij;\n                nb++;\n            }\n        }\n    }\n}\n\nstatic void set_positions(float *ps) {\n    int i;\n    for (i = 0; i < nv; i++) {\n        *(ps + i * 2) = (*(vs + i))->pos->x ; \n        *(ps + i * 2 + 1) = (*(vs + i))->pos->y ; \n    }\n}\n\nstatic void btonumarr(int *bsarr) {\n    int i;\n    *bsarr = nb;\n    for (i = 2; i < nb + 2; i++) {\n        *(bsarr + i * 2) = (bs + i)->fst->id;\n        *(bsarr + i * 2 + 1) = (bs + i)->snd->id;\n    }\n}\n\nint minimize (const char *dmtFilename, const char *ssFilename, float *flatpos,\n        int *bsarr, const int len, const int panelx, const int panely,\n        const int panelOffsetX, const int panelOffsetY, const float fact) {\n    int i, customSizes;\n    int *iter;\n    float *fret;\n\n    float (*func)(struct vertex **vs, struct bond *bs);\n    void (*dfunc)(struct vertex **vs, struct bond *bs, float *df);\n\n    func = f;\n    dfunc = df;\n\n    customSizes = strcmp(ssFilename, \"noCustomSizes\") != 0;\n\n    pox = panelOffsetX;\n    poy = panelOffsetY;\n    sx = panelx * fact;\n    sy = panely * fact;\n    elen = SPRING_LENGTH * fact;\n\n    dim = len;\n    nv = len / 2;\n    nb = 0;\n\n    vs = malloc(sizeof(struct vertex) * nv);\n    bs = malloc(sizeof(struct bond) * nv * nv);\n    fdm = malloc(sizeof(float) * (nv * nv));\n\n    iter = malloc(sizeof(int));\n    fret = malloc(sizeof(float));\n\n    if (iter == NULL || fret == NULL || fdm == NULL) {\n        rt_error(\"Error in minimize when allocating memory\");\n    }\n    \n    initDMT(dmtFilename);\n\n    create_vertices(customSizes);    \n    create_bonds();\n    set_positions(flatpos); \n\n    frprmn(vs, bs, dim, FTOL, iter, fret, func, dfunc);\n\n    printf(\"%d iterations\\n\", *iter);\n\n    for (i = 0; i < nv; i++) {\n        *(flatpos + i * 2) = (*(vs + i))->pos->x;\n        *(flatpos + i * 2 + 1) = (*(vs + i))->pos->y;\n    }\n\n    btonumarr(bsarr);\n\n    free(fret);\n    free(iter);\n    free(fdm);\n    for (i = 0; i < nv; i++) {\n        free((*(vs + i))->pos);\n        free(*(vs + i));\n    }\n    free(vs);\n    free(bs);\n\n    return 0;\n}\n\n","/*****************************************************************************\n\n * Author : Numerical recepies in C, modiefied by Ludvig Sundström\n\n * File Name : frprmn.c\n\n * Purpose : Performs Fletcher-Reeves-Polak-Ribiere minimization Given a\n * Set of vertices vs and a set of bonds bs, performs minimization on a\n * function func using its gradient calculated by dfunc. The convergence\n * tolerance of func is ftol.  Returned quatities are p - the location of the\n * minimum, iter - the number of iterations performed and fret - the minimum\n * value of value.  Calls routine linmin to perform line minimizations.\n\n * Creation Date : 25-06-2015\n\n *****************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#include \"constants.h\"\n#include \"util.h\"\n\n#define FREEALL free(xi);free(h);free(g);\n\nvoid linmin(struct vertex **vs, struct bond *bs, float xi[], int n,\n        float *fret, float (*func)());\n\nvoid vstoarr(struct vertex **vs, float *arr, int n) {\n    int i;\n    for (i = 0; i < n / 2; i++) {\n        *(arr + i * 2) = (*(vs + i))->pos->x;\n        *(arr + i * 2 + 1) = (*(vs + i))->pos->y;\n    }\n}\nvoid frprmn(struct vertex **vs, struct bond *bs, int n, float ftol,\n        int *iter, float *fret, float (*func)(), void (*dfunc)())\n{\n    int i, its;\n    float gg, gam, fp, dgg;\n    float *g, *h, *xi;\n    \n    g = vector(n);\n    h = vector(n);\n    xi = vector(n);\n\n    fp = (*func)(vs, bs);\n    (*dfunc)(vs, bs, xi);\n        \n    for (i = 0; i < n; i++) {\n        g[i] = -xi[i];\n        xi[i] = h[i] = g[i];\n    }\n    for (its = 0; its < ITMAX; its++) {\n        *iter = its;\n        linmin(vs, bs, xi, n, fret, func);\n        if (2.0 * fabs(*fret - fp) <= ftol * (fabs(*fret) + fabs(fp) + EPS)) {\n            FREEALL;\n            return;\n        }\n        fp = (*func)(vs, bs);\n        (*dfunc)(vs, bs, xi);\n        dgg = gg = 0.0;\n        for (i = 0; i < n; i++) {\n            gg += g[i] * g[i];\n            dgg += (xi[i] + g[i]) * xi[i];\n        }\n        if (fabs(gg) < EPS) {\n            FREEALL;\n            return;\n        }\n        gam = dgg / gg;\n        for (i = 0; i < n; i++) {\n            g[i] = -xi[i];\n            xi[i] = h[i] = g[i] + gam * h[i];\n        }\n    }\n    FREEALL\n    rt_error(\"Too many iterations in frprmn()\");\n}\n\n","/*****************************************************************************\n\n* File Name: math2D.c\n\n* Author: Ludvig Sundström\n\n* Description: \n\n* Creation Date: 06-07-2015\n\n*****************************************************************************/\n\n#include <stdlib.h>\n#include <math.h>\n#include \"math2D.h\"\n\nstruct point *mk_point(float x, float y) \n{\n    struct point *rtn = malloc(sizeof(struct point));\n    rtn->x = x;\n    rtn->y = y;\n    return rtn;\n}\n\nstruct vector2D mk_vector(struct point src, struct point tar)\n{\n    struct vector2D rtn;\n    rtn.src = src;\n    rtn.tar = tar;\n    rtn.x = src.x - tar.x;\n    rtn.y = src.y - tar.y;\n    rtn.len = sqrtf(rtn.x * rtn.x + rtn.y * rtn.y);\n    return rtn;\n}\n\nstruct point negate(struct point p) \n{\n    struct point rtn;\n    rtn.x = -p.x;\n    rtn.y = -p.y;\n    return rtn;\n}\n\nstruct point add(struct point p1, struct point p2) \n{\n    struct point rtn;\n    rtn.x = p1.x + p2.x;\n    rtn.y = p1.y + p2.y;\n    return rtn;\n}\n\nfloat dot(struct vector2D v1, struct vector2D v2)\n{   \n    return v1.x * v2.x + v1.y * v1.y;\n}\n\n","/*****************************************************************************\n\n * Author: Numerical recepies in C, modified by Ludvig Sundström\n\n * File Name: linmin.c\n\n * Description: \n * Given an n-dimensional point p[1..n] and an n-dimensional direction\n * xi[1..n], moves and resets p to where the function func(p) takes on a\n * minimum along the direction xi from p, and replaces xi by the actual vector\n * displacement that p was moved. Also returns as fret the value of func at the\n * returned location p. This is actually all accomplished by calling the\n * routines mnbrak and brent.  \n\n * Creation Date: 25-06-2015\n\n *****************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"constants.h\"\n#include \"util.h\"\n\nint ncom; \nfloat *pcom, *xicom, (*nrfunc)();   \n\nstruct vertex **vertices;\nstruct bond *bonds;\n\nfloat brent(float ax, float bx, float cx,   \n        float (*f)(float), float tol, float *xmin);   \n\nvoid mnbrak(float *ax, float *bx, float *cx, float *fa,\n        float *fb, float *fc, float (*func)(float));   \n\nfloat f1dim(float x);   \n\nvoid linmin(struct vertex **vs, struct bond *bs, float *xi, int n,\n        float *fret, float (*func)())   \n{   \n    int i;   \n    float xx, xmin, fx, fb, fa, bx, ax;   \n    vertices = vs;\n    bonds = bs;\n    ncom = n; \n    pcom = vector(n);   \n    xicom = vector(n);   \n    \n    nrfunc = func;   \n    for (i = 0; i < ncom; i += 2) {\n        struct vertex *vptr = *(vs + i / 2);\n        pcom[i] = vptr->pos->x;\n        pcom[i + 1]=  vptr->pos->y;\n        xicom[i] = xi[i];   \n        xicom[i + 1] = xi[i + 1];   \n    }\n    ax = 0.0; \n    xx = 1.0;   \n    mnbrak(&ax, &xx, &bx, &fa, &fx, &fb, f1dim);   \n    *fret = brent(ax, xx, bx, f1dim, TOL, &xmin);   \n    for (i=0; i < n; i++) { \n        xi[i] *= xmin;   \n        \n    }   \n    free(xicom);\n    free(pcom);\n}   \n\nfloat f1dim(float x)   \n{   \n    int i;   \n    float f;\n    for (i = 0; i < ncom; i += 2) {\n        struct vertex *vptr = *(vertices + i / 2);\n        vptr->pos->x = pcom[i] + x * xicom[i];\n        vptr->pos->y = pcom[i + 1] + x * xicom[i + 1];\n    }\n    f = (*nrfunc)(vertices, bonds);\n    return f;\n} \n\n"]}