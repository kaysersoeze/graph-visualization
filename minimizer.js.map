{"version":3,"file":"../../minimizer.js","sources":["nrutil.c","brent.c","mnbrak.c","linmin.c","frprmn.c","minimizer.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAWA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;;;;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAoMA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpMA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AALA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAAA;;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AACA;AAAA;;;;AANA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;;;AAvCA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AACA;AAAA;AA4CA;AAAA;;;AAHA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;AAAA;AADA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;AAMA;AAAA;AAAA;AAAA;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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AAA;AAAA;AAAA;AAAA;AAAA;AAUA;;;AADA;AACA;;;;;;;;;;;;;;ACjDA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;;AAMA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAGA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAbA;AAAA;AAAA;;AADA;AAAA;;AA6BA;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;;AAMA;AACA;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAEA;;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAPA;AAAA;AAAA;;AADA;AAAA;;AAWA;AAAA;AACA;AAAA;;;;;;;;;;;AASA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;;;;;;;;;;;;;;;;;;;;AAgBA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AACA;;AAAA;AAAA;AAAA;;;;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;AAAA;AAAA;;AADA;AAAA;AAAA;;AAOA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAIA","sourcesContent":["#if defined(__STDC__) || defined(ANSI) || defined(NRANSI) /* ANSI */\n\n#include <stdio.h>\n#include <stddef.h>\n#include <stdlib.h>\n#define NR_END 1\n#define FREE_ARG char*\n\nvoid nrerror(char error_text[])\n/* Numerical Recipes standard error handler */\n{\n        fprintf(stderr,\"Numerical Recipes run-time error...\\n\");\n        fprintf(stderr,\"%s\\n\",error_text);\n        fprintf(stderr,\"...now exiting to system...\\n\");\n        exit(1);\n}\n\nfloat *vector(long nl, long nh)\n/* allocate a float vector with subscript range v[nl..nh] */\n{\n        float *v;\n\n        v=(float *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(float)));\n        if (!v) nrerror(\"allocation failure in vector()\");\n        return v-nl+NR_END;\n}\n\nint *ivector(long nl, long nh)\n/* allocate an int vector with subscript range v[nl..nh] */\n{\n        int *v;\n\n        v=(int *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(int)));\n        if (!v) nrerror(\"allocation failure in ivector()\");\n        return v-nl+NR_END;\n}\n\nunsigned char *cvector(long nl, long nh)\n/* allocate an unsigned char vector with subscript range v[nl..nh] */\n{\n        unsigned char *v;\n\n        v=(unsigned char *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(unsigned char)));\n        if (!v) nrerror(\"allocation failure in cvector()\");\n        return v-nl+NR_END;\n}\n\nunsigned long *lvector(long nl, long nh)\n/* allocate an unsigned long vector with subscript range v[nl..nh] */\n{\n        unsigned long *v;\n\n        v=(unsigned long *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(long)));\n        if (!v) nrerror(\"allocation failure in lvector()\");\n        return v-nl+NR_END;\n}\n\ndouble *dvector(long nl, long nh)\n/* allocate a double vector with subscript range v[nl..nh] */\n{\n        double *v;\n\n        v=(double *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(double)));\n        if (!v) nrerror(\"allocation failure in dvector()\");\n        return v-nl+NR_END;\n}\n\nfloat **matrix(long nrl, long nrh, long ncl, long nch)\n/* allocate a float matrix with subscript range m[nrl..nrh][ncl..nch] */\n{\n        long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;\n        float **m;\n\n        /* allocate pointers to rows */\n        m=(float **) malloc((size_t)((nrow+NR_END)*sizeof(float*)));\n        if (!m) nrerror(\"allocation failure 1 in matrix()\");\n        m += NR_END;\n        m -= nrl;\n\n        /* allocate rows and set pointers to them */\n        m[nrl]=(float *) malloc((size_t)((nrow*ncol+NR_END)*sizeof(float)));\n        if (!m[nrl]) nrerror(\"allocation failure 2 in matrix()\");\n        m[nrl] += NR_END;\n        m[nrl] -= ncl;\n\n        for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;\n\n        /* return pointer to array of pointers to rows */\n        return m;\n}\n\ndouble **dmatrix(long nrl, long nrh, long ncl, long nch)\n/* allocate a double matrix with subscript range m[nrl..nrh][ncl..nch] */\n{\n        long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;\n        double **m;\n\n        /* allocate pointers to rows */\n        m=(double **) malloc((size_t)((nrow+NR_END)*sizeof(double*)));\n        if (!m) nrerror(\"allocation failure 1 in matrix()\");\n        m += NR_END;\n        m -= nrl;\n\n        /* allocate rows and set pointers to them */\n        m[nrl]=(double *) malloc((size_t)((nrow*ncol+NR_END)*sizeof(double)));\n        if (!m[nrl]) nrerror(\"allocation failure 2 in matrix()\");\n        m[nrl] += NR_END;\n        m[nrl] -= ncl;\n\n        for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;\n\n        /* return pointer to array of pointers to rows */\n        return m;\n}\n\nint **imatrix(long nrl, long nrh, long ncl, long nch)\n/* allocate a int matrix with subscript range m[nrl..nrh][ncl..nch] */\n{\n        long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;\n        int **m;\n\n        /* allocate pointers to rows */\n        m=(int **) malloc((size_t)((nrow+NR_END)*sizeof(int*)));\n        if (!m) nrerror(\"allocation failure 1 in matrix()\");\n        m += NR_END;\n        m -= nrl;\n\n\n        /* allocate rows and set pointers to them */\n        m[nrl]=(int *) malloc((size_t)((nrow*ncol+NR_END)*sizeof(int)));\n        if (!m[nrl]) nrerror(\"allocation failure 2 in matrix()\");\n        m[nrl] += NR_END;\n        m[nrl] -= ncl;\n\n        for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;\n\n        /* return pointer to array of pointers to rows */\n        return m;\n}\n\nfloat **submatrix(float **a, long oldrl, long oldrh, long oldcl, long oldch,\n        long newrl, long newcl)\n/* point a submatrix [newrl..][newcl..] to a[oldrl..oldrh][oldcl..oldch] */\n{\n        long i,j,nrow=oldrh-oldrl+1,ncol=oldcl-newcl;\n        float **m;\n\n        /* allocate array of pointers to rows */\n        m=(float **) malloc((size_t) ((nrow+NR_END)*sizeof(float*)));\n        if (!m) nrerror(\"allocation failure in submatrix()\");\n        m += NR_END;\n        m -= newrl;\n\n        /* set pointers to rows */\n        for(i=oldrl,j=newrl;i<=oldrh;i++,j++) m[j]=a[i]+ncol;\n\n        /* return pointer to array of pointers to rows */\n        return m;\n}\n\nfloat **convert_matrix(float *a, long nrl, long nrh, long ncl, long nch)\n/* allocate a float matrix m[nrl..nrh][ncl..nch] that points to the matrix\ndeclared in the standard C manner as a[nrow][ncol], where nrow=nrh-nrl+1\nand ncol=nch-ncl+1. The routine should be called with the address\n&a[0][0] as the first argument. */\n{\n        long i,j,nrow=nrh-nrl+1,ncol=nch-ncl+1;\n        float **m;\n\n        /* allocate pointers to rows */\n        m=(float **) malloc((size_t) ((nrow+NR_END)*sizeof(float*)));\n        if (!m) nrerror(\"allocation failure in convert_matrix()\");\n        m += NR_END;\n        m -= nrl;\n\n        /* set pointers to rows */\n        m[nrl]=a-ncl;\n        for(i=1,j=nrl+1;i<nrow;i++,j++) m[j]=m[j-1]+ncol;\n        /* return pointer to array of pointers to rows */\n        return m;\n}\n\nfloat ***f3tensor(long nrl, long nrh, long ncl, long nch, long ndl, long ndh)\n/* allocate a float 3tensor with range t[nrl..nrh][ncl..nch][ndl..ndh] */\n{\n        long i,j,nrow=nrh-nrl+1,ncol=nch-ncl+1,ndep=ndh-ndl+1;\n        float ***t;\n\n        /* allocate pointers to pointers to rows */\n        t=(float ***) malloc((size_t)((nrow+NR_END)*sizeof(float**)));\n        if (!t) nrerror(\"allocation failure 1 in f3tensor()\");\n        t += NR_END;\n        t -= nrl;\n\n        /* allocate pointers to rows and set pointers to them */\n        t[nrl]=(float **) malloc((size_t)((nrow*ncol+NR_END)*sizeof(float*)));\n        if (!t[nrl]) nrerror(\"allocation failure 2 in f3tensor()\");\n        t[nrl] += NR_END;\n        t[nrl] -= ncl;\n\n        /* allocate rows and set pointers to them */\n        t[nrl][ncl]=(float *) malloc((size_t)((nrow*ncol*ndep+NR_END)*sizeof(float)));\n        if (!t[nrl][ncl]) nrerror(\"allocation failure 3 in f3tensor()\");\n        t[nrl][ncl] += NR_END;\n        t[nrl][ncl] -= ndl;\n\n        for(j=ncl+1;j<=nch;j++) t[nrl][j]=t[nrl][j-1]+ndep;\n        for(i=nrl+1;i<=nrh;i++) {\n                t[i]=t[i-1]+ncol;\n                t[i][ncl]=t[i-1][ncl]+ncol*ndep;\n                for(j=ncl+1;j<=nch;j++) t[i][j]=t[i][j-1]+ndep;\n        }\n\n        /* return pointer to array of pointers to rows */\n        return t;\n}\n\nvoid free_vector(float *v, long nl, long nh)\n/* free a float vector allocated with vector() */\n{\n        free((FREE_ARG) (v+nl-NR_END));\n}\n\nvoid free_ivector(int *v, long nl, long nh)\n/* free an int vector allocated with ivector() */\n{\n        free((FREE_ARG) (v+nl-NR_END));\n}\n\nvoid free_cvector(unsigned char *v, long nl, long nh)\n/* free an unsigned char vector allocated with cvector() */\n{\n        free((FREE_ARG) (v+nl-NR_END));\n}\n\nvoid free_lvector(unsigned long *v, long nl, long nh)\n/* free an unsigned long vector allocated with lvector() */\n{\n        free((FREE_ARG) (v+nl-NR_END));\n}\n\nvoid free_dvector(double *v, long nl, long nh)\n/* free a double vector allocated with dvector() */\n{\n        free((FREE_ARG) (v+nl-NR_END));\n}\n\nvoid free_matrix(float **m, long nrl, long nrh, long ncl, long nch)\n/* free a float matrix allocated by matrix() */\n{\n        free((FREE_ARG) (m[nrl]+ncl-NR_END));\n        free((FREE_ARG) (m+nrl-NR_END));\n}\n\nvoid free_dmatrix(double **m, long nrl, long nrh, long ncl, long nch)\n/* free a double matrix allocated by dmatrix() */\n{\n        free((FREE_ARG) (m[nrl]+ncl-NR_END));\n        free((FREE_ARG) (m+nrl-NR_END));\n}\n\nvoid free_imatrix(int **m, long nrl, long nrh, long ncl, long nch)\n/* free an int matrix allocated by imatrix() */\n{\n        free((FREE_ARG) (m[nrl]+ncl-NR_END));\n        free((FREE_ARG) (m+nrl-NR_END));\n}\n\nvoid free_submatrix(float **b, long nrl, long nrh, long ncl, long nch)\n/* free a submatrix allocated by submatrix() */\n{\n        free((FREE_ARG) (b+nrl-NR_END));\n}\n\nvoid free_convert_matrix(float **b, long nrl, long nrh, long ncl, long nch)\n/* free a matrix allocated by convert_matrix() */\n{\n        free((FREE_ARG) (b+nrl-NR_END));\n}\n\nvoid free_f3tensor(float ***t, long nrl, long nrh, long ncl, long nch,\n        long ndl, long ndh)\n/* free a float f3tensor allocated by f3tensor() */\n{\n        free((FREE_ARG) (t[nrl][ncl]+ndl-NR_END));\n        free((FREE_ARG) (t[nrl]+ncl-NR_END));\n        free((FREE_ARG) (t+nrl-NR_END));\n}\n\n#else /* ANSI */\n/* traditional - K&R */\n\n#include <stdio.h>\n#define NR_END 1\n#define FREE_ARG char*\n\nvoid nrerror(error_text)\nchar error_text[];\n/* Numerical Recipes standard error handler */\n{\n        void exit();\n\n        fprintf(stderr,\"Numerical Recipes run-time error...\\n\");\n        fprintf(stderr,\"%s\\n\",error_text);\n        fprintf(stderr,\"...now exiting to system...\\n\");\n        exit(1);\n}\n\nfloat *vector(nl,nh)\nlong nh,nl;\n/* allocate a float vector with subscript range v[nl..nh] */\n{\n        float *v;\n\n        v=(float *)malloc((unsigned int) ((nh-nl+1+NR_END)*sizeof(float)));\n        if (!v) nrerror(\"allocation failure in vector()\");\n        return v-nl+NR_END;\n}\n\nint *ivector(nl,nh)\nlong nh,nl;\n/* allocate an int vector with subscript range v[nl..nh] */\n{\n        int *v;\n\n        v=(int *)malloc((unsigned int) ((nh-nl+1+NR_END)*sizeof(int)));\n        if (!v) nrerror(\"allocation failure in ivector()\");\n        return v-nl+NR_END;\n}\n\nunsigned char *cvector(nl,nh)\nlong nh,nl;\n/* allocate an unsigned char vector with subscript range v[nl..nh] */\n{\n        unsigned char *v;\n\n        v=(unsigned char *)malloc((unsigned int) ((nh-nl+1+NR_END)*sizeof(unsigned char)));\n        if (!v) nrerror(\"allocation failure in cvector()\");\n        return v-nl+NR_END;\n}\n\nunsigned long *lvector(nl,nh)\nlong nh,nl;\n/* allocate an unsigned long vector with subscript range v[nl..nh] */\n{\n        unsigned long *v;\n\n        v=(unsigned long *)malloc((unsigned int) ((nh-nl+1+NR_END)*sizeof(long)));\n        if (!v) nrerror(\"allocation failure in lvector()\");\n        return v-nl+NR_END;\n}\n\ndouble *dvector(nl,nh)\nlong nh,nl;\n/* allocate a double vector with subscript range v[nl..nh] */\n{\n        double *v;\n\n        v=(double *)malloc((unsigned int) ((nh-nl+1+NR_END)*sizeof(double)));\n        if (!v) nrerror(\"allocation failure in dvector()\");\n        return v-nl+NR_END;\n}\n\nfloat **matrix(nrl,nrh,ncl,nch)\nlong nch,ncl,nrh,nrl;\n/* allocate a float matrix with subscript range m[nrl..nrh][ncl..nch] */\n{\n        long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;\n        float **m;\n\n        /* allocate pointers to rows */\n        m=(float **) malloc((unsigned int)((nrow+NR_END)*sizeof(float*)));\n        if (!m) nrerror(\"allocation failure 1 in matrix()\");\n        m += NR_END;\n        m -= nrl;\n\n        /* allocate rows and set pointers to them */\n        m[nrl]=(float *) malloc((unsigned int)((nrow*ncol+NR_END)*sizeof(float)));\n        if (!m[nrl]) nrerror(\"allocation failure 2 in matrix()\");\n        m[nrl] += NR_END;\n        m[nrl] -= ncl;\n\n        for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;\n\n        /* return pointer to array of pointers to rows */\n        return m;\n}\n\ndouble **dmatrix(nrl,nrh,ncl,nch)\nlong nch,ncl,nrh,nrl;\n/* allocate a double matrix with subscript range m[nrl..nrh][ncl..nch] */\n{\n        long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;\n        double **m;\n\n        /* allocate pointers to rows */\n        m=(double **) malloc((unsigned int)((nrow+NR_END)*sizeof(double*)));\n        if (!m) nrerror(\"allocation failure 1 in matrix()\");\n        m += NR_END;\n        m -= nrl;\n\n        /* allocate rows and set pointers to them */\n        m[nrl]=(double *) malloc((unsigned int)((nrow*ncol+NR_END)*sizeof(double)));\n        if (!m[nrl]) nrerror(\"allocation failure 2 in matrix()\");\n        m[nrl] += NR_END;\n        m[nrl] -= ncl;\n\n        for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;\n\n        /* return pointer to array of pointers to rows */\n        return m;\n}\n\nint **imatrix(nrl,nrh,ncl,nch)\nlong nch,ncl,nrh,nrl;\n/* allocate a int matrix with subscript range m[nrl..nrh][ncl..nch] */\n{\n        long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;\n        int **m;\n\n        /* allocate pointers to rows */\n        m=(int **) malloc((unsigned int)((nrow+NR_END)*sizeof(int*)));\n        if (!m) nrerror(\"allocation failure 1 in matrix()\");\n        m += NR_END;\n        m -= nrl;\n\n\n        /* allocate rows and set pointers to them */\n        m[nrl]=(int *) malloc((unsigned int)((nrow*ncol+NR_END)*sizeof(int)));\n        if (!m[nrl]) nrerror(\"allocation failure 2 in matrix()\");\n        m[nrl] += NR_END;\n        m[nrl] -= ncl;\n\n        for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;\n\n        /* return pointer to array of pointers to rows */\n        return m;\n}\n\nfloat **submatrix(a,oldrl,oldrh,oldcl,oldch,newrl,newcl)\nfloat **a;\nlong newcl,newrl,oldch,oldcl,oldrh,oldrl;\n/* point a submatrix [newrl..][newcl..] to a[oldrl..oldrh][oldcl..oldch] */\n{\n        long i,j,nrow=oldrh-oldrl+1,ncol=oldcl-newcl;\n        float **m;\n\n        /* allocate array of pointers to rows */\n        m=(float **) malloc((unsigned int) ((nrow+NR_END)*sizeof(float*)));\n        if (!m) nrerror(\"allocation failure in submatrix()\");\n        m += NR_END;\n        m -= newrl;\n\n        /* set pointers to rows */\n        for(i=oldrl,j=newrl;i<=oldrh;i++,j++) m[j]=a[i]+ncol;\n\n        /* return pointer to array of pointers to rows */\n        return m;\n}\n\nfloat **convert_matrix(a,nrl,nrh,ncl,nch)\nfloat *a;\nlong nch,ncl,nrh,nrl;\n/* allocate a float matrix m[nrl..nrh][ncl..nch] that points to the matrix\ndeclared in the standard C manner as a[nrow][ncol], where nrow=nrh-nrl+1\nand ncol=nch-ncl+1. The routine should be called with the address\n&a[0][0] as the first argument. */\n{\n        long i,j,nrow=nrh-nrl+1,ncol=nch-ncl+1;\n        float **m;\n\n        /* allocate pointers to rows */\n        m=(float **) malloc((unsigned int) ((nrow+NR_END)*sizeof(float*)));\n        if (!m) nrerror(\"allocation failure in convert_matrix()\");\n        m += NR_END;\n        m -= nrl;\n\n        /* set pointers to rows */\n        m[nrl]=a-ncl;\n        for(i=1,j=nrl+1;i<nrow;i++,j++) m[j]=m[j-1]+ncol;\n        /* return pointer to array of pointers to rows */\n        return m;\n}\n\nfloat ***f3tensor(nrl,nrh,ncl,nch,ndl,ndh)\nlong nch,ncl,ndh,ndl,nrh,nrl;\n/* allocate a float 3tensor with range t[nrl..nrh][ncl..nch][ndl..ndh] */\n{\n        long i,j,nrow=nrh-nrl+1,ncol=nch-ncl+1,ndep=ndh-ndl+1;\n        float ***t;\n\n        /* allocate pointers to pointers to rows */\n        t=(float ***) malloc((unsigned int)((nrow+NR_END)*sizeof(float**)));\n        if (!t) nrerror(\"allocation failure 1 in f3tensor()\");\n        t += NR_END;\n        t -= nrl;\n\n        /* allocate pointers to rows and set pointers to them */\n        t[nrl]=(float **) malloc((unsigned int)((nrow*ncol+NR_END)*sizeof(float*)));\n        if (!t[nrl]) nrerror(\"allocation failure 2 in f3tensor()\");\n        t[nrl] += NR_END;\n        t[nrl] -= ncl;\n\n        /* allocate rows and set pointers to them */\n        t[nrl][ncl]=(float *) malloc((unsigned int)((nrow*ncol*ndep+NR_END)*sizeof(float)));\n        if (!t[nrl][ncl]) nrerror(\"allocation failure 3 in f3tensor()\");\n        t[nrl][ncl] += NR_END;\n        t[nrl][ncl] -= ndl;\n\n        for(j=ncl+1;j<=nch;j++) t[nrl][j]=t[nrl][j-1]+ndep;\n        for(i=nrl+1;i<=nrh;i++) {\n                t[i]=t[i-1]+ncol;\n                t[i][ncl]=t[i-1][ncl]+ncol*ndep;\n                for(j=ncl+1;j<=nch;j++) t[i][j]=t[i][j-1]+ndep;\n        }\n\n        /* return pointer to array of pointers to rows */\n        return t;\n}\n\nvoid free_vector(v,nl,nh)\nfloat *v;\nlong nh,nl;\n/* free a float vector allocated with vector() */\n{\n        free((FREE_ARG) (v+nl-NR_END));\n}\n\nvoid free_ivector(v,nl,nh)\nint *v;\nlong nh,nl;\n/* free an int vector allocated with ivector() */\n{\n        free((FREE_ARG) (v+nl-NR_END));\n}\n\nvoid free_cvector(v,nl,nh)\nlong nh,nl;\nunsigned char *v;\n/* free an unsigned char vector allocated with cvector() */\n{\n        free((FREE_ARG) (v+nl-NR_END));\n}\n\nvoid free_lvector(v,nl,nh)\nlong nh,nl;\nunsigned long *v;\n/* free an unsigned long vector allocated with lvector() */\n{\n        free((FREE_ARG) (v+nl-NR_END));\n}\n\nvoid free_dvector(v,nl,nh)\ndouble *v;\nlong nh,nl;\n/* free a double vector allocated with dvector() */\n{\n        free((FREE_ARG) (v+nl-NR_END));\n}\n\nvoid free_matrix(m,nrl,nrh,ncl,nch)\nfloat **m;\nlong nch,ncl,nrh,nrl;\n/* free a float matrix allocated by matrix() */\n{\n        free((FREE_ARG) (m[nrl]+ncl-NR_END));\n        free((FREE_ARG) (m+nrl-NR_END));\n}\n\nvoid free_dmatrix(m,nrl,nrh,ncl,nch)\ndouble **m;\nlong nch,ncl,nrh,nrl;\n/* free a double matrix allocated by dmatrix() */\n{\n        free((FREE_ARG) (m[nrl]+ncl-NR_END));\n        free((FREE_ARG) (m+nrl-NR_END));\n}\n\nvoid free_imatrix(m,nrl,nrh,ncl,nch)\nint **m;\nlong nch,ncl,nrh,nrl;\n/* free an int matrix allocated by imatrix() */\n{\n        free((FREE_ARG) (m[nrl]+ncl-NR_END));\n        free((FREE_ARG) (m+nrl-NR_END));\n}\n\nvoid free_submatrix(b,nrl,nrh,ncl,nch)\nfloat **b;\nlong nch,ncl,nrh,nrl;\n/* free a submatrix allocated by submatrix() */\n{\n        free((FREE_ARG) (b+nrl-NR_END));\n}\n\nvoid free_convert_matrix(b,nrl,nrh,ncl,nch)\nfloat **b;\nlong nch,ncl,nrh,nrl;\n/* free a matrix allocated by convert_matrix() */\n{\n        free((FREE_ARG) (b+nrl-NR_END));\n}\n\nvoid free_f3tensor(t,nrl,nrh,ncl,nch,ndl,ndh)\nfloat ***t;\nlong nch,ncl,ndh,ndl,nrh,nrl;\n/* free a float f3tensor allocated by f3tensor() */\n{\n        free((FREE_ARG) (t[nrl][ncl]+ndl-NR_END));\n        free((FREE_ARG) (t[nrl]+ncl-NR_END));\n        free((FREE_ARG) (t+nrl-NR_END));\n}\n\n#endif /* ANSI */\n","/*****************************************************************************\n\n* Author : Ludvig Sundström\n\n* File Name : brent2.c\n\n* Purpose : \n\n* Creation Date : 25-06-2015\n\n* Last Modified : \n\n*****************************************************************************/\n#include <math.h>\n#define NRANSI\n#include \"nrutil.h\"\n#define ITMAX 100\n#define CGOLD 0.3819660\n#define ZEPS 1.0e-10\n#define SHFT(a,b,c,d) (a)=(b);(b)=(c);(c)=(d);\nfloat brent(float ax, float bx, float cx, float (*f)(float), float tol,\n        float *xmin)\n{\n  int iter;\n  float a,b,d,etemp,fu,fv,fw,fx,p,q,r,tol1,tol2,u,v,w,x,xm;\n  float e=0.0;\n\n  a=(ax < cx ? ax : cx);\n  b=(ax > cx ? ax : cx);\n  x=w=v=bx;\n  fw=fv=fx=(*f)(x);\n  for (iter=1;iter<=ITMAX;iter++) {\n    xm=0.5*(a+b);\n    tol2=2.0*(tol1=tol*fabs(x)+ZEPS);\n    if (fabs(x-xm) <= (tol2-0.5*(b-a))) {\n      *xmin=x;\n      return fx;\n    }\n    if (fabs(e) > tol1) {\n      r=(x-w)*(fx-fv);\n      q=(x-v)*(fx-fw);\n      p=(x-v)*q-(x-w)*r;\n      q=2.0*(q-r);\n      if (q > 0.0) p = -p;\n      q=fabs(q);\n      etemp=e;\n      e=d;\n      if (fabs(p) >= fabs(0.5*q*etemp) || p <= q*(a-x) || p >= q*(b-x))\n      d=CGOLD*(e=(x >= xm ? a-x : b-x));\n      else {\n        d=p/q;\n        u=x+d;\n        if (u-a < tol2 || b-u < tol2)\n        d=SIGN(tol1,xm-x);\n      }\n    } else {\n      d=CGOLD*(e=(x >= xm ? a-x : b-x));\n    }\n    u=(fabs(d) >= tol1 ? x+d : x+SIGN(tol1,d));\n    fu=(*f)(u);\n    if (fu <= fx) {\n      if (u >= x) a=x; else b=x;\n      SHFT(v,w,x,u)\n      SHFT(fv,fw,fx,fu)\n    } else {\n      if (u < x) a=u; else b=u;\n      if (fu <= fw || w == x) {\n        v=w;\n        w=u;\n        fv=fw;\n        fw=fu;\n      } else if (fu <= fv || v == x || v == w) {\n        v=u;\n        fv=fu;\n      }\n    }\n  }\n  nrerror(\"Too many iterations in brent\");\n  *xmin=x;\n  return fx;\n}\n\n#undef ITMAX\n#undef CGOLD\n#undef ZEPS\n#undef SHFT\n#undef NRANSI\n","#include <math.h>\n\n#define GOLD 1.618034\n#define GLIMIT 100.0\n#define TINY 1.0e-20\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define SIGN(a,b) ((b) > 0.0 ? fabs(a) : -fabs(a))\n#define SHFT(a,b,c,d) (a)=(b);(b)=(c);(c)=(d);\n\nvoid mnbrak(ax,bx,cx,fa,fb,fc,func)\nfloat *ax,*bx,*cx,*fa,*fb,*fc;\nfloat (*func)();\t/* ANSI: float (*func)(float); */\n{\n\tfloat ulim,u,r,q,fu,dum;\n\n\t*fa=(*func)(*ax);\n\t*fb=(*func)(*bx);\n\tif (*fb > *fa) {\n\t\tSHFT(dum,*ax,*bx,dum)\n\t\tSHFT(dum,*fb,*fa,dum)\n\t}\n\t*cx=(*bx)+GOLD*(*bx-*ax);\n\t*fc=(*func)(*cx);\n\twhile (*fb > *fc) {\n\t\tr=(*bx-*ax)*(*fb-*fc);\n\t\tq=(*bx-*cx)*(*fb-*fa);\n\t\tu=(*bx)-((*bx-*cx)*q-(*bx-*ax)*r)/\n\t\t\t(2.0*SIGN(MAX(fabs(q-r),TINY),q-r));\n\t\tulim=(*bx)+GLIMIT*(*cx-*bx);\n\t\tif ((*bx-u)*(u-*cx) > 0.0) {\n\t\t\tfu=(*func)(u);\n\t\t\tif (fu < *fc) {\n\t\t\t\t*ax=(*bx);\n\t\t\t\t*bx=u;\n\t\t\t\t*fa=(*fb);\n\t\t\t\t*fb=fu;\n\t\t\t\treturn;\n\t\t\t} else if (fu > *fb) {\n\t\t\t\t*cx=u;\n\t\t\t\t*fc=fu;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tu=(*cx)+GOLD*(*cx-*bx);\n\t\t\tfu=(*func)(u);\n\t\t} else if ((*cx-u)*(u-ulim) > 0.0) {\n\t\t\tfu=(*func)(u);\n\t\t\tif (fu < *fc) {\n\t\t\t\tSHFT(*bx,*cx,u,*cx+GOLD*(*cx-*bx))\n\t\t\t\tSHFT(*fb,*fc,fu,(*func)(u))\n\t\t\t}\n\t\t} else if ((u-ulim)*(ulim-*cx) >= 0.0) {\n\t\t\tu=ulim;\n\t\t\tfu=(*func)(u);\n\t\t} else {\n\t\t\tu=(*cx)+GOLD*(*cx-*bx);\n\t\t\tfu=(*func)(u);\n\t\t}\n\t\tSHFT(*ax,*bx,*cx,u)\n\t\tSHFT(*fa,*fb,*fc,fu)\n\t}\n}\n\n#undef GOLD\n#undef GLIMIT\n#undef TINY\n#undef MAX\n#undef SIGN\n#undef SHFT\n","/*****************************************************************************\n\n* Author : Ludvig Sundström\n\n* File Name : linmin2.c\n\n* Purpose : \n\n* Creation Date : 25-06-2015\n\n* Last Modified : \n\n*****************************************************************************/\n\n#include \"nrutil.h\"   \n#define TOL 2.0e-4 //Tolerance passed to brent.   \nint ncom; //Global variables communicate with f1dim.   \nfloat *pcom,*xicom,(*nrfunc)(float []);   \n\n/*  Given an n-dimensional point p[1..n] and an n-dimensional direction\nxi[1..n], moves and resets p to where the function func(p) takes on a\nminimum along the direction xi from p, and replaces xi by the actual\nvector displacement that p was moved. Also returns as fret the value\nof func at the returned location p. This is actually all accomplished\nby calling the routines mnbrak and brent.  \n*/   \nvoid linmin(float p[], float xi[], int n, float *fret, float (*func)(float []))   \n{   \n  float brent(float ax, float bx, float cx,   \n  float (*f)(float), float tol, float *xmin);   \n  float f1dim(float x);   \n  void mnbrak(float *ax, float *bx, float *cx, float *fa, float *fb,   \n  float *fc, float (*func)(float));   \n  int j;   \n  float xx,xmin,fx,fb,fa,bx,ax;   \n  ncom=n; //Define the global variables.   \n  pcom=vector(1,n);   \n  xicom=vector(1,n);   \n  nrfunc=func;   \n  for (j=1;j<=n;j++) {   \n    pcom[j]=p[j];   \n    xicom[j]=xi[j];   \n  }   \n  ax=0.0; //Initial guess for brackets.   \n  xx=1.0;   \n  mnbrak(&ax,&xx,&bx,&fa,&fx,&fb,f1dim);   \n  *fret=brent(ax,xx,bx,f1dim,TOL,&xmin);   \n  for (j=1;j<=n;j++) { \n    //Construct the vector results to return.   \n    xi[j] *= xmin;   \n    p[j] += xi[j];   \n  }   \n  free_vector(xicom,1,n);   \n  free_vector(pcom,1,n);   \n}   \n\n\n//Must accompany linmin.   \nfloat f1dim(float x)   \n{   \n  int j;   \n  float f,*xt;   \n  xt=vector(1,ncom);   \n  for (j=1;j<=ncom;j++) xt[j]=pcom[j]+x*xicom[j];   \n  f=(*nrfunc)(xt);   \n  free_vector(xt,1,ncom);   \n  return f;   \n}  \n","/*****************************************************************************\n\n* Author : Ludvig Sundström\n\n* File Name : frprmn2.c\n\n* Purpose : \n\n* Creation Date : 25-06-2015\n\n* Last Modified : \n\n*****************************************************************************/\n\n#include <math.h>\n#include <stdio.h>\n\n#define ITMAX 200\n#define EPS 1.0e-10\n#define FREEALL free_vector(xi,1,n);free_vector(h,1,n);free_vector(g,1,n);\n\nvoid frprmn(p, n, ftol, iter, fret, func, dfunc)\nfloat p[], ftol, *fret, (*func)();\nvoid (*dfunc)();\nint n, *iter;\n{\n  int j, its;\n  float gg, gam, fp, dgg;\n  float *g, *h, *xi, *vector();\n  void linmin(), nrerror(), free_vector();\n\n  g = vector(1,n);\n  h = vector(1,n);\n  xi = vector(1,n);\n  fp = (*func)(p);\n  (*dfunc)(p, xi);\n  for (j = 1; j <= n; j++) {\n    g[j] = -xi[j];\n    xi[j] = h[j] = g[j];\n  }\n  for (its = 1; its <= ITMAX; its++) {\n    for (j = 1; j <= n; j++) {\n      printf(\"%f ,\", p[j]);\n    }\n    printf(\"\\n\");\n    for (j = 1; j <= n; j++) {\n      printf(\"%f ,\", xi[j]);\n    }\n    printf(\"\\n\");\n    *iter = its;\n    linmin(p, xi, n, fret, func);\n    printf(\" fabs(*fret -fp): %f\\n\", fabs(*fret - fp));\n    printf(\" ftol %f\\n\", ftol);\n    printf(\" 2 * fabs(*fret -fp): %f\\n\", 2 * fabs(*fret - fp));\n    printf(\" ftol *(fabs(*fret)+fabs(fp)+EPS) %f\\n\", \n        ftol * (fabs(*fret) + fabs(fp) + EPS));\n    printf(\"*fret: %f\\n\", *fret);\n    printf(\"fp: %f\\n\", fp);\n    printf(\"______________________________________\\n\");\n    if (2.0 * fabs(*fret - fp) <= ftol * (fabs(*fret) + fabs(fp) + EPS)) {\n      printf(\"%f\\n\", fp);\n      FREEALL\n      return;\n    }\n    fp = (*func)(p);\n    (*dfunc)(p, xi);\n    dgg = gg = 0.0;\n    for (j = 1; j <= n; j++) {\n      gg += g[j] * g[j];\n      /*\t\t  dgg += xi[j]*xi[j];\t*/\n      dgg += (xi[j] + g[j]) * xi[j];\n    }\n    if (gg == 0.0) {\n      FREEALL\n      return;\n    }\n    gam = dgg / gg;\n    for (j = 1; j <= n; j++) {\n      g[j] = -xi[j];\n      xi[j] = h[j] = g[j] + gam * h[j];\n    }\n  }\n  nrerror(\"Too many iterations in FRPRMN\");\n}\n\n#undef ITMAX\n#undef EPS\n#undef FREEALL\n\n","/*****************************************************************************\n\n* Author : Ludvig Sundström\n\n* File Name : minimize.c\n\n* Purpose :   \n\n* Creation Date : 24-06-2015\n\n* Last Modified : \n\n*****************************************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <math.h>\n\n#define SPRING_LENGTH 200.0\n#define STIFFNESS (1 / 20.0)\n\n//Distance matrix\nfloat **dmat;\n\n// Dimesion of the coordinate vector\nint len;\n\nstruct point {\n  float x;\n  float y;\n};\n\nfloat springEnergy (struct point pi, struct point pj, float wij, float dij) {\n  float dx = pi.x - pj.x;\n  float dy = pi.y - pj.y;\n  float dist = (float) sqrt(dx * dx + dy * dy);\n  if (fabs(dist) <  0.1) {\n    dist = 1;\n  } \n  return wij * (float) pow(dist - dij, 2);\n}\n\nfloat forceX (struct point pi, struct point pj, float wij, float dij) {\n  float dx = pi.x - pj.x;\n  float dy = pi.y - pj.y;\n  float dist = (float) sqrt(dx * dx + dy * dy);\n  if (fabs(dist) <  0.1) {\n    dist = 1;\n  } \n  return -2 * wij * dx * (dist - dij) / dist;\n} \nfloat forceY (struct point pi, struct point pj, float wij, float dij) {\n  float dx = pi.x - pj.x;\n  float dy = pi.y - pj.y;\n  float dist = (float) sqrt(dx * dx + dy * dy);\n  if (fabs(dist) <  0.1) {\n    dist = 1;\n  } \n  return -2 * wij * dy * (dist - dij) / dist;\n} \n\nvoid calcVectorGradient (float p[], float df[]) {\n  int nPositions = len / 2; \n  struct point *positions = malloc(sizeof(struct point) * nPositions + 1);\n  int i, j;\n  for (i = 1; i <= len; i += 2) {\n    struct point cp;\n    cp.x = p[i];\n    cp.y = p[i + 1];\n    *(positions + (i / 2) + 1) = cp;\n  }\n  for (i = 1; i <= nPositions; i++) {\n    for (j = i + 1; j <= nPositions; j++) {\n      \n      struct point cpj, cpi;\n      printf(\"cpi: %d, cpj: %d\\n\", i, j);\n      cpi = positions[i];\n      cpj = positions[j];\n      float d = dmat[i - 1][j - 1];\n      float wij = d * STIFFNESS;\n      float dij = d * SPRING_LENGTH;\n\n      df[(i - 1) * 2 + 1] += forceX(cpi, cpj, wij, dij);\n      df[(i - 1) * 2 + 2] += forceY(cpi, cpj, wij, dij);\n      df[(j - 1) * 2 + 1] += -forceX(cpi, cpj, wij, dij);\n      df[(j - 1) * 2 + 2] += -forceY(cpi, cpj, wij, dij);\n\n/*printf(\"Adding %f X to df[%d]\\n\", */\n    /*forceX(cpi, cpj, d * STIFFNESS, d * SPRING_LENGTH), i * 2);*/\n/*printf(\"Adding %f Y to df[%d]\\n\", */\n    /*forceY(cpi, cpj, d * STIFFNESS, d * SPRING_LENGTH), i * 2 + 1);*/\n\n/*printf(\"Adding %f X to df[%d]\\n\", */\n    /*-forceX(cpi, cpj, d * STIFFNESS, d * SPRING_LENGTH), j * 2);*/\n/*printf(\"Adding %f Y to df[%d]\\n\", */\n    /*-forceY(cpi, cpj, d * STIFFNESS, d * SPRING_LENGTH), j * 2 + 1);*/\n    }\n  }\n  /*printf(\"-----------------\\n\");*/\n\n}\n\nfloat calcEnergy (float p[]) {\n  int nPositions = len / 2; \n  struct point *positions = malloc(sizeof(struct point) * nPositions);\n  int i, j;\n  for (i = 1; i <= len; i += 2) {\n    struct point cp;\n    cp.x = p[i];\n    cp.y = p[i + 1];\n    *(positions + (i - 1) / 2) = cp;\n  }\n  float energy = 0;\n  for (i = 0; i < nPositions - 1; i++) {\n    for (j = i + 1; j < nPositions; j++) {\n      struct point cpi, cpj;\n      cpi = positions[i];\n      cpj = positions[j];\n      int d = dmat[i][j];\n      float wij = d * STIFFNESS;\n      float dij = d * SPRING_LENGTH;\n      energy += springEnergy(cpi, cpj, wij, dij);\n    }\n  }\n  free(positions);\n  return energy;\n}\n\nfloat (*func)(float []) = calcEnergy;\nvoid (*dfunc)(float [], float []) = calcVectorGradient;\n\nfloat *convert(float *arr, int len) {\n  float *vector();\n  int j;\n  float *rtn = vector(1, len);\n  for (j = 1; j <= len; j++) {\n    *(rtn + j) = *(arr - 1 + j);\n  }\n  return rtn;\n}\n\nvoid printvec(float *vec, int len) {\n  int j;\n  for (j = 1; j <= len; j++) {\n    printf(\"%f\", *(vec + j));\n    if (j != len) printf(\", \");\n  }\n  printf(\"\\n\");\n}\n\n\nint minimize (float *flatpos, float *flatdmat, int posLen) {\n  void frprmn();\n  int i, j, count;\n  int nPositions = posLen / 2; \n\n  //Initialize dmat\n  dmat = malloc(sizeof(void *) * nPositions);\n  for (i = 0; i < nPositions; i++) {\n    *(dmat + i) = malloc(sizeof(float) * nPositions);\n  }\n  count = 0;\n  for (i = 0; i < nPositions; i++) {\n    for (j = 0; j < nPositions; j++) {\n      *(*(dmat + i) + j) = flatdmat[count];  \n      count++;\n    }\n  }\n\n  len = posLen;\n\n  int *iter = malloc(sizeof(int));\n  float *fret = malloc(sizeof(float));\n  \n  float *mflatpos = convert(flatpos, posLen);\n\n  frprmn(mflatpos, posLen, 0.000001, iter, fret, func, dfunc);\n\n  printf(\"\\n\");\n  printf(\"Min:\");\n  printf(\"%f\\n\", *fret);\n  printf(\"iterations: %d\\n\", *iter);\n\n  free(dmat);\n\n  for (i = 0; i < posLen; i++) {\n    *(flatpos + i) = *(mflatpos + i + 1);\n  }\n\n  return 0; \n\n}\n\n  /*for (i = 0; i < len; i++) {*/\n    /*printf(\"%f, \", flatpos[i]);*/\n  /*}*/\n  /*printf(\"\\n\");*/\n  /*calcVectorGradient(flatpos, gradient);*/\n  /*for (i = 0; i < len; i++) {*/\n    /*printf(\"%f, \", gradient[i]);*/\n  /*}*/\n  /*printf(\"\\n\");*/\n  /*for (i = 0; i < len; i++) {*/\n    /*printf(\"%f, \", flatpos[i]);*/\n  /*}*/\n  /*printf(\"\\n\");*/\n\n  /*printf(\"After: \\n\");*/\n  /*printf(\"Energy: %f\\n\", calcEnergy(flatpos));*/\n  /*printf(\"Positions:\\n\");*/\n  /*for (i = 0; i <= len; i++) {*/\n    /*printf(\"%f, \", flatpos[i]);*/\n  /*}*/\n\n/*printf(\"dmat: %f\\n\", dmat[i][j]);*/\n\n"]}